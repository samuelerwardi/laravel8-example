/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/jquery-1.12.3.js":
/*!***************************************!*\
  !*** ./resources/js/jquery-1.12.3.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v1.12.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-04-05T19:16Z\n */\n(function (global, factory) {\n  if (( false ? 0 : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Support: Firefox 18+\n  // Can't be in strict mode, several libs including ASP.NET trace\n  // the stack via arguments.caller.callee and Firefox dies if\n  // you try to trace through \"use strict\" call chains. (#13335)\n  //\"use strict\";\n  var deletedIds = [];\n  var document = window.document;\n  var _slice = deletedIds.slice;\n  var concat = deletedIds.concat;\n  var push = deletedIds.push;\n  var indexOf = deletedIds.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var support = {};\n\n  var version = \"1.12.3\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  },\n      // Support: Android<4.1, IE<9\n  // Make sure we trim BOM and NBSP\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      // Matches dashed string for camelizing\n  rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([\\da-z])/gi,\n      // Used by jQuery.camelCase as callback to replace()\n  fcamelCase = function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // Start with an empty selector\n    selector: \"\",\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      return num != null ? // Return just the one element from the set\n      num < 0 ? this[num + this.length] : this[num] : // Return all the elements in a clean array\n      _slice.call(this);\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this;\n      ret.context = this.context; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: deletedIds.sort,\n    splice: deletedIds.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var src,\n        copyIsArray,\n        copy,\n        name,\n        options,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !jQuery.isFunction(target)) {\n      target = {};\n    } // extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : [];\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    // See test/unit/core.js for details concerning isFunction.\n    // Since version 1.3, DOM methods and functions like alert\n    // aren't supported. They return false on IE (#2968).\n    isFunction: function isFunction(obj) {\n      return jQuery.type(obj) === \"function\";\n    },\n    isArray: Array.isArray || function (obj) {\n      return jQuery.type(obj) === \"array\";\n    },\n    isWindow: function isWindow(obj) {\n      /* jshint eqeqeq: false */\n      return obj != null && obj == obj.window;\n    },\n    isNumeric: function isNumeric(obj) {\n      // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n      // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n      // subtraction forces infinities to NaN\n      // adding 1 corrects loss of precision from parseFloat (#15100)\n      var realStringObj = obj && obj.toString();\n      return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    isPlainObject: function isPlainObject(obj) {\n      var key; // Must be an Object.\n      // Because of IE, we also have to check the presence of the constructor property.\n      // Make sure that DOM nodes and window objects don't pass through, as well\n\n      if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n        return false;\n      }\n\n      try {\n        // Not own constructor property must be Object\n        if (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n          return false;\n        }\n      } catch (e) {\n        // IE8,9 Will throw exceptions on certain host objects #9897\n        return false;\n      } // Support: IE<9\n      // Handle iteration over inherited properties before own properties.\n\n\n      if (!support.ownFirst) {\n        for (key in obj) {\n          return hasOwn.call(obj, key);\n        }\n      } // Own properties are enumerated firstly, so to speed up,\n      // if last one is own, then all properties are own.\n\n\n      for (key in obj) {}\n\n      return key === undefined || hasOwn.call(obj, key);\n    },\n    type: function type(obj) {\n      if (obj == null) {\n        return obj + \"\";\n      }\n\n      return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n    },\n    // Workarounds based on findings by Jim Driscoll\n    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    globalEval: function globalEval(data) {\n      if (data && jQuery.trim(data)) {\n        // We use execScript on Internet Explorer\n        // We use an anonymous function so that context is window\n        // rather than jQuery in Firefox\n        (window.execScript || function (data) {\n          window[\"eval\"].call(window, data); // jscs:ignore requireDotNotation\n        })(data);\n      }\n    },\n    // Convert dashed to camelCase; used by the css and data modules\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function camelCase(string) {\n      return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    },\n    nodeName: function nodeName(elem, name) {\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Support: Android<4.1, IE<9\n    trim: function trim(text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      var len;\n\n      if (arr) {\n        if (indexOf) {\n          return indexOf.call(arr, elem, i);\n        }\n\n        len = arr.length;\n        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n        for (; i < len; i++) {\n          // Skip accessing in sparse arrays\n          if (i in arr && arr[i] === elem) {\n            return i;\n          }\n        }\n      }\n\n      return -1;\n    },\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      while (j < len) {\n        first[i++] = second[j++];\n      } // Support: IE<9\n      // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\n\n      if (len !== len) {\n        while (second[j] !== undefined) {\n          first[i++] = second[j++];\n        }\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function proxy(fn, context) {\n      var args, proxy, tmp;\n\n      if (typeof context === \"string\") {\n        tmp = fn[context];\n        context = fn;\n        fn = tmp;\n      } // Quick check to determine if target is callable, in the spec\n      // this throws a TypeError, but we will just return undefined.\n\n\n      if (!jQuery.isFunction(fn)) {\n        return undefined;\n      } // Simulated bind\n\n\n      args = _slice.call(arguments, 2);\n\n      proxy = function proxy() {\n        return fn.apply(context || this, args.concat(_slice.call(arguments)));\n      }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n      return proxy;\n    },\n    now: function now() {\n      return +new Date();\n    },\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  }); // JSHint would error on this code due to the Symbol not being defined in ES5.\n  // Defining this global in .jshintrc would create a danger of using the global\n  // unguarded in another place, it seems safer to just disable JSHint for these\n  // three lines.\n\n  /* jshint ignore: start */\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = deletedIds[Symbol.iterator];\n  }\n  /* jshint ignore: end */\n  // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: iOS 8.2 (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = jQuery.type(obj);\n\n    if (type === \"function\" || jQuery.isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.2.1\n   * http://sizzlejs.com/\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license\n   * http://jquery.org/license\n   *\n   * Date: 2015-10-17\n   */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // General-purpose constants\n    MAX_NEGATIVE = 1 << 31,\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // http://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        rescape = /'|\\\\/g,\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n        funescape = function funescape(_, escaped, escapedWhitespace) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n      // Support: Firefox<24\n      // Workaround erroneous numeric interpretation of +\"0x\"\n\n      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    }; // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          push_native.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          nidselect,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n          setDocument(context);\n        }\n\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !compilerCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n            if (nodeType !== 1) {\n              newContext = context;\n              newSelector = selector; // qSA looks outside Element context, which is not what we want\n              // Thanks to Andrew Dupont for this workaround technique\n              // Support: IE <=8\n              // Exclude object elements\n            } else if (context.nodeName.toLowerCase() !== \"object\") {\n              // Capture the context ID, setting it first if necessary\n              if (nid = context.getAttribute(\"id\")) {\n                nid = nid.replace(rescape, \"\\\\$&\");\n              } else {\n                context.setAttribute(\"id\", nid = expando);\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n              nidselect = ridentifier.test(nid) ? \"#\" + nid : \"[id='\" + nid + \"']\";\n\n              while (i--) {\n                groups[i] = nidselect + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n            }\n\n            if (newSelector) {\n              try {\n                push.apply(results, newContext.querySelectorAll(newSelector));\n                return results;\n              } catch (qsaError) {} finally {\n                if (nid === expando) {\n                  context.removeAttribute(\"id\");\n                }\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created div and expects a boolean result\n     */\n\n\n    function assert(fn) {\n      var div = document.createElement(\"div\");\n\n      try {\n        return !!fn(div);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (div.parentNode) {\n          div.parentNode.removeChild(div);\n        } // release memory in IE\n\n\n        div = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      // documentElement is verified for cases where it doesn't yet exist\n      // (such as loading iframes in IE - #4833)\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n      return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          parent,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n      if ((parent = document.defaultView) && parent.top !== parent) {\n        // Support: IE 11\n        if (parent.addEventListener) {\n          parent.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (parent.attachEvent) {\n          parent.attachEvent(\"onunload\", unloadHandler);\n        }\n      }\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n\n      support.attributes = assert(function (div) {\n        div.className = \"i\";\n        return !div.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (div) {\n        div.appendChild(document.createComment(\"\"));\n        return !div.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (div) {\n        docElem.appendChild(div).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID find and filter\n\n      if (support.getById) {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var m = context.getElementById(id);\n            return m ? [m] : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n      } else {\n        // Support: IE6/7\n        // getElementById is not reliable as a find shortcut\n        delete Expr.find[\"ID\"];\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See http://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (div) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // http://bugs.jquery.com/ticket/12359\n          docElem.appendChild(div).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (div.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!div.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!div.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibing-combinator selector` fails\n\n\n          if (!div.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          }\n        });\n        assert(function (div) {\n          // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          div.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (div.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":enabled\").length) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          div.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (div) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(div, \"div\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(div, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n\n\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n\n          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      } // Make sure that attribute selectors are quoted\n\n\n      expr = expr.replace(rattributeQuotes, \"='$1']\");\n\n      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {}\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": function enabled(elem) {\n          return elem.disabled === false;\n        },\n        \"disabled\": function disabled(elem) {\n          return elem.disabled === true;\n        },\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          checkNonElements = base && dir === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[dir] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          outermostContext = context === document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            if (!context && elem.ownerDocument !== document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (div1) {\n      // Should return 1, but returns 4 (following)\n      return div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (div) {\n      div.innerHTML = \"<a href='#'></a>\";\n      return div.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (div) {\n      div.innerHTML = \"<input/>\";\n      div.firstChild.setAttribute(\"value\", \"\");\n      return div.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (div) {\n      return div.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors;\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n  var rsingleTag = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/;\n  var risSimple = /^.[^:#\\[\\.,]*$/; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (jQuery.isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        /* jshint -W018 */\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    }\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    }\n\n    if (typeof qualifier === \"string\") {\n      if (risSimple.test(qualifier)) {\n        return jQuery.filter(qualifier, elements, not);\n      }\n\n      qualifier = jQuery.filter(qualifier, elements);\n    }\n\n    return jQuery.grep(elements, function (elem) {\n      return jQuery.inArray(elem, qualifier) > -1 !== not;\n    });\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret = [],\n          self = this,\n          len = self.length;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      } // Needed because $( selector, context ) becomes $( context ).find( selector )\n\n\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n      ret.selector = this.selector ? this.selector + \" \" + selector : selector;\n      return ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // init accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (jQuery.isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns\n          // nodes that are no longer in the document #6963\n\n          if (elem && elem.parentNode) {\n            // Handle the case where IE and Opera return items\n            // by name instead of ID\n            if (elem.id !== match[2]) {\n              return rootjQuery.find(selector);\n            } // Otherwise, we inject the element directly into the jQuery object\n\n\n            this.length = 1;\n            this[0] = elem;\n          }\n\n          this.context = document;\n          this.selector = selector;\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this.context = this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (jQuery.isFunction(selector)) {\n      return typeof root.ready !== \"undefined\" ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    if (selector.selector !== undefined) {\n      this.selector = selector.selector;\n      this.context = selector.context;\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var i,\n          targets = jQuery(target, this),\n          len = targets.length;\n      return this.filter(function () {\n        for (i = 0; i < len; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n      for (; i < l; i++) {\n        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n          // Always skip document fragments\n          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : // Don't pass non-elements to Sizzle\n          cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n            matched.push(cur);\n            break;\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within\n    // the matched set of elements\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // index in selector\n\n\n      if (typeof elem === \"string\") {\n        return jQuery.inArray(this[0], jQuery(elem));\n      } // Locate the position of the desired element\n\n\n      return jQuery.inArray( // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem, this);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    do {\n      cur = cur[dir];\n    } while (cur && cur.nodeType !== 1);\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      return jQuery.nodeName(elem, \"iframe\") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var ret = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        ret = jQuery.filter(selector, ret);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          ret = jQuery.uniqueSort(ret);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          ret = ret.reverse();\n        }\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnotwhite = /\\S+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to prevent firing\n    _locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function fire() {\n      // Enforce single-firing\n      _locked = options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      _fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (_locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (jQuery.isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && jQuery.type(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = true;\n\n        if (!memory) {\n          self.disable();\n        }\n\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, listener list, final state\n      [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        then: function\n          /* fnDone, fnFail, fnProgress */\n        then() {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              var fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && jQuery.isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Keep pipe for back-compat\n\n      _promise.pipe = _promise.then; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = [ resolved | rejected ]\n            _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n        } // deferred[ resolve | reject | notify ]\n\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n          return this;\n        };\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(subordinate\n    /* , ..., subordinateN */\n    ) {\n      var i = 0,\n          resolveValues = _slice.call(arguments),\n          length = resolveValues.length,\n          // the count of uncompleted subordinates\n      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n          // the master Deferred.\n      // If resolveValues consist of only a single Deferred, just use that.\n      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n          // Update function for both resolve and progress values\n      updateFunc = function updateFunc(i, contexts, values) {\n        return function (value) {\n          contexts[i] = this;\n          values[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (values === progressValues) {\n            deferred.notifyWith(contexts, values);\n          } else if (! --remaining) {\n            deferred.resolveWith(contexts, values);\n          }\n        };\n      },\n          progressValues,\n          progressContexts,\n          resolveContexts; // add listeners to Deferred subordinates; treat others as resolved\n\n\n      if (length > 1) {\n        progressValues = new Array(length);\n        progressContexts = new Array(length);\n        resolveContexts = new Array(length);\n\n        for (; i < length; i++) {\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);\n          } else {\n            --remaining;\n          }\n        }\n      } // if we're not waiting on anything, resolve the master\n\n\n      if (!remaining) {\n        deferred.resolveWith(resolveContexts, resolveValues);\n      }\n\n      return deferred.promise();\n    }\n  }); // The deferred used on DOM ready\n\n  var readyList;\n\n  jQuery.fn.ready = function (fn) {\n    // Add the callback\n    jQuery.ready.promise().done(fn);\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Hold (or release) the ready event\n    holdReady: function holdReady(hold) {\n      if (hold) {\n        jQuery.readyWait++;\n      } else {\n        jQuery.ready(true);\n      }\n    },\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events\n\n      if (jQuery.fn.triggerHandler) {\n        jQuery(document).triggerHandler(\"ready\");\n        jQuery(document).off(\"ready\");\n      }\n    }\n  });\n  /**\n   * Clean-up method for dom ready events\n   */\n\n  function detach() {\n    if (document.addEventListener) {\n      document.removeEventListener(\"DOMContentLoaded\", completed);\n      window.removeEventListener(\"load\", completed);\n    } else {\n      document.detachEvent(\"onreadystatechange\", completed);\n      window.detachEvent(\"onload\", completed);\n    }\n  }\n  /**\n   * The ready event handler and self cleanup method\n   */\n\n\n  function completed() {\n    // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n    if (document.addEventListener || window.event.type === \"load\" || document.readyState === \"complete\") {\n      detach();\n      jQuery.ready();\n    }\n  }\n\n  jQuery.ready.promise = function (obj) {\n    if (!readyList) {\n      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called\n      // after the browser event has already occurred.\n      // Support: IE6-10\n      // Older IE sometimes signals \"interactive\" too soon\n\n      if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        window.setTimeout(jQuery.ready); // Standards-based browsers support DOMContentLoaded\n      } else if (document.addEventListener) {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n        window.addEventListener(\"load\", completed); // If IE event model is used\n      } else {\n        // Ensure firing before onload, maybe late but safe also for iframes\n        document.attachEvent(\"onreadystatechange\", completed); // A fallback to window.onload, that will always work\n\n        window.attachEvent(\"onload\", completed); // If IE and not a frame\n        // continually check to see if the document is ready\n\n        var top = false;\n\n        try {\n          top = window.frameElement == null && document.documentElement;\n        } catch (e) {}\n\n        if (top && top.doScroll) {\n          (function doScrollCheck() {\n            if (!jQuery.isReady) {\n              try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n              } catch (e) {\n                return window.setTimeout(doScrollCheck, 50);\n              } // detach all dom ready events\n\n\n              detach(); // and execute any waiting functions\n\n              jQuery.ready();\n            }\n          })();\n        }\n      }\n    }\n\n    return readyList.promise(obj);\n  }; // Kick off the DOM ready check even if the user does not\n\n\n  jQuery.ready.promise(); // Support: IE<9\n  // Iteration over object's inherited properties before its own\n\n  var i;\n\n  for (i in jQuery(support)) {\n    break;\n  }\n\n  support.ownFirst = i === \"0\"; // Note: most support tests are defined in their respective modules.\n  // false until the test is run\n\n  support.inlineBlockNeedsLayout = false; // Execute ASAP in case we need to set body.style.zoom\n\n  jQuery(function () {\n    // Minified: var a,b,c,d\n    var val, div, body, container;\n    body = document.getElementsByTagName(\"body\")[0];\n\n    if (!body || !body.style) {\n      // Return for frameset docs that don't have a body\n      return;\n    } // Setup\n\n\n    div = document.createElement(\"div\");\n    container = document.createElement(\"div\");\n    container.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n    body.appendChild(container).appendChild(div);\n\n    if (typeof div.style.zoom !== \"undefined\") {\n      // Support: IE<8\n      // Check if natively block-level elements act like inline-block\n      // elements when setting their display to 'inline' and giving\n      // them layout\n      div.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n      support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n\n      if (val) {\n        // Prevent IE 6 from affecting layout for positioned elements #11048\n        // Prevent IE from shrinking the body in IE 7 mode #12869\n        // Support: IE<8\n        body.style.zoom = 1;\n      }\n    }\n\n    body.removeChild(container);\n  });\n\n  (function () {\n    var div = document.createElement(\"div\"); // Support: IE<9\n\n    support.deleteExpando = true;\n\n    try {\n      delete div.test;\n    } catch (e) {\n      support.deleteExpando = false;\n    } // Null elements to avoid leaks in IE.\n\n\n    div = null;\n  })();\n\n  var acceptData = function acceptData(elem) {\n    var noData = jQuery.noData[(elem.nodeName + \" \").toLowerCase()],\n        nodeType = +elem.nodeType || 1; // Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\n    return nodeType !== 1 && nodeType !== 9 ? false : // Nodes accept data unless otherwise specified; rejection can be conditional\n    !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n  };\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /([A-Z])/g;\n\n  function dataAttr(elem, key, data) {\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      var name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null : // Only convert to a number if it doesn't change the string\n          +data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        jQuery.data(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  } // checks a cache object for emptiness\n\n\n  function isEmptyDataObject(obj) {\n    var name;\n\n    for (name in obj) {\n      // if the public data object is empty, the private is still empty\n      if (name === \"data\" && jQuery.isEmptyObject(obj[name])) {\n        continue;\n      }\n\n      if (name !== \"toJSON\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function internalData(elem, name, data, pvt\n  /* Internal Use Only */\n  ) {\n    if (!acceptData(elem)) {\n      return;\n    }\n\n    var ret,\n        thisCache,\n        internalKey = jQuery.expando,\n        // We have to handle DOM nodes and JS objects differently because IE6-7\n    // can't GC object references properly across the DOM-JS boundary\n    isNode = elem.nodeType,\n        // Only DOM nodes need the global jQuery cache; JS object data is\n    // attached directly to the object so GC can occur automatically\n    cache = isNode ? jQuery.cache : elem,\n        // Only defining an ID for JS objects if its cache already exists allows\n    // the code to shortcut on the same path as a DOM node with no cache\n    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey; // Avoid doing any more work than we need to when trying to get data on an\n    // object that has no data at all\n\n    if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === \"string\") {\n      return;\n    }\n\n    if (!id) {\n      // Only DOM nodes need a new unique ID for each element since their data\n      // ends up in the global cache\n      if (isNode) {\n        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;\n      } else {\n        id = internalKey;\n      }\n    }\n\n    if (!cache[id]) {\n      // Avoid exposing jQuery metadata on plain JS objects when the object\n      // is serialized using JSON.stringify\n      cache[id] = isNode ? {} : {\n        toJSON: jQuery.noop\n      };\n    } // An object can be passed to jQuery.data instead of a key/value pair; this gets\n    // shallow copied over onto the existing cache\n\n\n    if (_typeof(name) === \"object\" || typeof name === \"function\") {\n      if (pvt) {\n        cache[id] = jQuery.extend(cache[id], name);\n      } else {\n        cache[id].data = jQuery.extend(cache[id].data, name);\n      }\n    }\n\n    thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data\n    // cache in order to avoid key collisions between internal data and user-defined\n    // data.\n\n    if (!pvt) {\n      if (!thisCache.data) {\n        thisCache.data = {};\n      }\n\n      thisCache = thisCache.data;\n    }\n\n    if (data !== undefined) {\n      thisCache[jQuery.camelCase(name)] = data;\n    } // Check for both converted-to-camel and non-converted data property names\n    // If a data property was specified\n\n\n    if (typeof name === \"string\") {\n      // First Try to find as-is property data\n      ret = thisCache[name]; // Test for null|undefined property data\n\n      if (ret == null) {\n        // Try to find the camelCased property\n        ret = thisCache[jQuery.camelCase(name)];\n      }\n    } else {\n      ret = thisCache;\n    }\n\n    return ret;\n  }\n\n  function internalRemoveData(elem, name, pvt) {\n    if (!acceptData(elem)) {\n      return;\n    }\n\n    var thisCache,\n        i,\n        isNode = elem.nodeType,\n        // See jQuery.data for more information\n    cache = isNode ? jQuery.cache : elem,\n        id = isNode ? elem[jQuery.expando] : jQuery.expando; // If there is already no cache entry for this object, there is no\n    // purpose in continuing\n\n    if (!cache[id]) {\n      return;\n    }\n\n    if (name) {\n      thisCache = pvt ? cache[id] : cache[id].data;\n\n      if (thisCache) {\n        // Support array or space separated string names for data keys\n        if (!jQuery.isArray(name)) {\n          // try the string as a key before any manipulation\n          if (name in thisCache) {\n            name = [name];\n          } else {\n            // split the camel cased version by spaces unless a key with the spaces exists\n            name = jQuery.camelCase(name);\n\n            if (name in thisCache) {\n              name = [name];\n            } else {\n              name = name.split(\" \");\n            }\n          }\n        } else {\n          // If \"name\" is an array of keys...\n          // When data is initially created, via (\"key\", \"val\") signature,\n          // keys will be converted to camelCase.\n          // Since there is no way to tell _how_ a key was added, remove\n          // both plain key and camelCase key. #12786\n          // This will only penalize the array argument path.\n          name = name.concat(jQuery.map(name, jQuery.camelCase));\n        }\n\n        i = name.length;\n\n        while (i--) {\n          delete thisCache[name[i]];\n        } // If there is no data left in the cache, we want to continue\n        // and let the cache object itself get destroyed\n\n\n        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {\n          return;\n        }\n      }\n    } // See jQuery.data for more information\n\n\n    if (!pvt) {\n      delete cache[id].data; // Don't destroy the parent cache unless the internal data object\n      // had been the only thing left in it\n\n      if (!isEmptyDataObject(cache[id])) {\n        return;\n      }\n    } // Destroy the cache\n\n\n    if (isNode) {\n      jQuery.cleanData([elem], true); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\n      /* jshint eqeqeq: false */\n    } else if (support.deleteExpando || cache != cache.window) {\n      /* jshint eqeqeq: true */\n      delete cache[id]; // When all else fails, undefined\n    } else {\n      cache[id] = undefined;\n    }\n  }\n\n  jQuery.extend({\n    cache: {},\n    // The following elements (space-suffixed to avoid Object.prototype collisions)\n    // throw uncatchable exceptions if you attempt to set expando properties\n    noData: {\n      \"applet \": true,\n      \"embed \": true,\n      // ...but Flash objects (which have this classid) *can* handle expandos\n      \"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n    },\n    hasData: function hasData(elem) {\n      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];\n      return !!elem && !isEmptyDataObject(elem);\n    },\n    data: function data(elem, name, _data) {\n      return internalData(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      return internalRemoveData(elem, name);\n    },\n    // For internal use only.\n    _data: function _data(elem, name, data) {\n      return internalData(elem, name, data, true);\n    },\n    _removeData: function _removeData(elem, name) {\n      return internalRemoveData(elem, name, true);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Special expections of .data basically thwart jQuery.access,\n      // so implement the relevant behavior ourselves\n      // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = jQuery.data(elem);\n\n          if (elem.nodeType === 1 && !jQuery._data(elem, \"parsedAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE11+\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = jQuery.camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            jQuery._data(elem, \"parsedAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          jQuery.data(this, key);\n        });\n      }\n\n      return arguments.length > 1 ? // Sets one value\n      this.each(function () {\n        jQuery.data(this, key, value);\n      }) : // Gets one value\n      // Try to fetch any internally stored data first\n      elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        jQuery.removeData(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || jQuery.isArray(data)) {\n            queue = jQuery._data(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // not intended for public consumption - generates a queueHooks object,\n    // or returns the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return jQuery._data(elem, key) || jQuery._data(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          jQuery._removeData(elem, type + \"queue\");\n\n          jQuery._removeData(elem, key);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = jQuery._data(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n\n  (function () {\n    var shrinkWrapBlocksVal;\n\n    support.shrinkWrapBlocks = function () {\n      if (shrinkWrapBlocksVal != null) {\n        return shrinkWrapBlocksVal;\n      } // Will be changed later if needed.\n\n\n      shrinkWrapBlocksVal = false; // Minified: var b,c,d\n\n      var div, body, container;\n      body = document.getElementsByTagName(\"body\")[0];\n\n      if (!body || !body.style) {\n        // Test fired too early or in an unsupported environment, exit.\n        return;\n      } // Setup\n\n\n      div = document.createElement(\"div\");\n      container = document.createElement(\"div\");\n      container.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n      body.appendChild(container).appendChild(div); // Support: IE6\n      // Check if elements with layout shrink-wrap their children\n\n      if (typeof div.style.zoom !== \"undefined\") {\n        // Reset CSS: box-sizing; display; margin; border\n        div.style.cssText = // Support: Firefox<29, Android 2.3\n        // Vendor-prefix box-sizing\n        \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" + \"box-sizing:content-box;display:block;margin:0;border:0;\" + \"padding:1px;width:1px;zoom:1\";\n        div.appendChild(document.createElement(\"div\")).style.width = \"5px\";\n        shrinkWrapBlocksVal = div.offsetWidth !== 3;\n      }\n\n      body.removeChild(container);\n      return shrinkWrapBlocksVal;\n    };\n  })();\n\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n\n  var isHidden = function isHidden(elem, el) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n    return jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale = 1,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Trust units reported by jQuery.css\n      unit = unit || initialInUnit[3]; // Make sure we update the tween properties later on\n\n      valueParts = valueParts || []; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      do {\n        // If previous iteration zeroed out, double until we get *something*.\n        // Use string for doubling so we don't accidentally see scale as unchanged below\n        scale = scale || \".5\"; // Adjust and apply\n\n        initialInUnit = initialInUnit / scale;\n        jQuery.style(elem, prop, initialInUnit + unit); // Update scale, tolerating zero or NaN from tween.cur()\n        // Break the loop if scale is unchanged or perfect, or if we've just had enough.\n      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        length = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (jQuery.type(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!jQuery.isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < length; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    return chainable ? elems : // Gets\n    bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;\n  };\n\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([\\w:-]+)/;\n  var rscriptType = /^$|\\/(?:java|ecma)script/i;\n  var rleadingWhitespace = /^\\s+/;\n  var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|\" + \"details|dialog|figcaption|figure|footer|header|hgroup|main|\" + \"mark|meter|nav|output|picture|progress|section|summary|template|time|video\";\n\n  function createSafeFragment(document) {\n    var list = nodeNames.split(\"|\"),\n        safeFrag = document.createDocumentFragment();\n\n    if (safeFrag.createElement) {\n      while (list.length) {\n        safeFrag.createElement(list.pop());\n      }\n    }\n\n    return safeFrag;\n  }\n\n  (function () {\n    var div = document.createElement(\"div\"),\n        fragment = document.createDocumentFragment(),\n        input = document.createElement(\"input\"); // Setup\n\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\"; // IE strips leading whitespace when .innerHTML is used\n\n    support.leadingWhitespace = div.firstChild.nodeType === 3; // Make sure that tbody elements aren't automatically inserted\n    // IE will insert them into empty tables\n\n    support.tbody = !div.getElementsByTagName(\"tbody\").length; // Make sure that link elements get serialized correctly by innerHTML\n    // This requires a wrapper element in IE\n\n    support.htmlSerialize = !!div.getElementsByTagName(\"link\").length; // Makes sure cloning an html5 element does not cause problems\n    // Where outerHTML is undefined, this still works\n\n    support.html5Clone = document.createElement(\"nav\").cloneNode(true).outerHTML !== \"<:nav></:nav>\"; // Check if a disconnected checkbox will retain its checked\n    // value of true after appended to the DOM (IE6/7)\n\n    input.type = \"checkbox\";\n    input.checked = true;\n    fragment.appendChild(input);\n    support.appendChecked = input.checked; // Make sure textarea (and checkbox) defaultValue is properly cloned\n    // Support: IE6-IE11+\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // #11217 - WebKit loses check when the name is after the checked attribute\n\n    fragment.appendChild(div); // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n    // old WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<9\n    // Cloned elements keep attachEvent handlers, we use addEventListener on IE9+\n\n    support.noCloneEvent = !!div.addEventListener; // Support: IE<9\n    // Since attributes and properties are the same in IE,\n    // cleanData must set properties to undefined rather than use removeAttribute\n\n    div[jQuery.expando] = 1;\n    support.attributes = !div.getAttribute(jQuery.expando);\n  })(); // We have to close these tags to support XHTML (#13200)\n\n\n  var wrapMap = {\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    legend: [1, \"<fieldset>\", \"</fieldset>\"],\n    area: [1, \"<map>\", \"</map>\"],\n    // Support: IE8\n    param: [1, \"<object>\", \"</object>\"],\n    thead: [1, \"<table>\", \"</table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n    // unless wrapped in a div with non-breaking characters in front of it.\n    _default: support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]\n  }; // Support: IE8-IE9\n\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n\n  function getAll(context, tag) {\n    var elems,\n        elem,\n        i = 0,\n        found = typeof context.getElementsByTagName !== \"undefined\" ? context.getElementsByTagName(tag || \"*\") : typeof context.querySelectorAll !== \"undefined\" ? context.querySelectorAll(tag || \"*\") : undefined;\n\n    if (!found) {\n      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {\n        if (!tag || jQuery.nodeName(elem, tag)) {\n          found.push(elem);\n        } else {\n          jQuery.merge(found, getAll(elem, tag));\n        }\n      }\n    }\n\n    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var elem,\n        i = 0;\n\n    for (; (elem = elems[i]) != null; i++) {\n      jQuery._data(elem, \"globalEval\", !refElements || jQuery._data(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/,\n      rtbody = /<tbody/i;\n\n  function fixDefaultChecked(elem) {\n    if (rcheckableType.test(elem.type)) {\n      elem.defaultChecked = elem.checked;\n    }\n  }\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var j,\n        elem,\n        contains,\n        tmp,\n        tag,\n        tbody,\n        wrap,\n        l = elems.length,\n        // Ensure a safe fragment\n    safe = createSafeFragment(context),\n        nodes = [],\n        i = 0;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (jQuery.type(elem) === \"object\") {\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || safe.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Manually add leading whitespace removed by IE\n\n\n          if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {\n            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));\n          } // Remove IE's autoinserted <tbody> from table fragments\n\n\n          if (!support.tbody) {\n            // String was a <table>, *may* have spurious <tbody>\n            elem = tag === \"table\" && !rtbody.test(elem) ? tmp.firstChild : // String was a bare <thead> or <tfoot>\n            wrap[1] === \"<table>\" && !rtbody.test(elem) ? tmp : 0;\n            j = elem && elem.childNodes.length;\n\n            while (j--) {\n              if (jQuery.nodeName(tbody = elem.childNodes[j], \"tbody\") && !tbody.childNodes.length) {\n                elem.removeChild(tbody);\n              }\n            }\n          }\n\n          jQuery.merge(nodes, tmp.childNodes); // Fix #12392 for WebKit and IE > 9\n\n          tmp.textContent = \"\"; // Fix #12392 for oldIE\n\n          while (tmp.firstChild) {\n            tmp.removeChild(tmp.firstChild);\n          } // Remember the top-level container for proper cleanup\n\n\n          tmp = safe.lastChild;\n        }\n      }\n    } // Fix #11356: Clear elements from fragment\n\n\n    if (tmp) {\n      safe.removeChild(tmp);\n    } // Reset defaultChecked for any radios and checkboxes\n    // about to be appended to the DOM in IE 6/7 (#8060)\n\n\n    if (!support.appendChecked) {\n      jQuery.grep(getAll(nodes, \"input\"), fixDefaultChecked);\n    }\n\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment\n\n      tmp = getAll(safe.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (contains) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    tmp = null;\n    return safe;\n  }\n\n  (function () {\n    var i,\n        eventName,\n        div = document.createElement(\"div\"); // Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)\n\n    for (i in {\n      submit: true,\n      change: true,\n      focusin: true\n    }) {\n      eventName = \"on\" + i;\n\n      if (!(support[i] = eventName in window)) {\n        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n        div.setAttribute(eventName, \"t\");\n        support[i] = div.attributes[eventName].expando === false;\n      }\n    } // Null elements to avoid leaks in IE.\n\n\n    div = null;\n  })();\n\n  var rformElems = /^(?:input|select|textarea)$/i,\n      rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE9\n  // See #13393 for more info\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var tmp,\n          events,\n          t,\n          handleObjIn,\n          special,\n          eventHandle,\n          handleObj,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery._data(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;\n        }; // Add elem as a property of the handle fn to prevent a memory leak\n        // with IE non-native events\n\n\n        eventHandle.elem = elem;\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            // Bind the global event handler to the element\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle, false);\n            } else if (elem.attachEvent) {\n              elem.attachEvent(\"on\" + type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      } // Nullify elem to prevent memory leaks in IE\n\n\n      elem = null;\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          handleObj,\n          tmp,\n          origCount,\n          t,\n          events,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery.hasData(elem) && jQuery._data(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty\n        // so use it instead of delete\n\n        jQuery._removeData(elem, \"events\");\n      }\n    },\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var handle,\n          ontype,\n          cur,\n          bubbleType,\n          special,\n          tmp,\n          i,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (jQuery._data(cur, \"events\") || {})[event.type] && jQuery._data(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name name as the event.\n          // Can't use an .isFunction() check here because IE6/7 fails that test.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && elem[type] && !jQuery.isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            try {\n              elem[type]();\n            } catch (e) {// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n              // only reproducible on winXP IE8 native, not IE9 in IE8 mode\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    dispatch: function dispatch(event) {\n      // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(event);\n\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue = [],\n          args = _slice.call(arguments),\n          handlers = (jQuery._data(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n\n      args[0] = event;\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n          // a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          matches,\n          sel,\n          handleObj,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Support (at least): Chrome, IE9\n      // Find delegate handlers\n      // Black-hole SVG <use> instance trees (#13180)\n      //\n      // Support: Firefox<=42+\n      // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)\n\n      if (delegateCount && cur.nodeType && (event.type !== \"click\" || isNaN(event.button) || event.button < 1)) {\n        /* jshint eqeqeq: false */\n        for (; cur != this; cur = cur.parentNode || this) {\n          /* jshint eqeqeq: true */\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\")) {\n            matches = [];\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matches[sel] === undefined) {\n                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matches[sel]) {\n                matches.push(handleObj);\n              }\n            }\n\n            if (matches.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matches\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: this,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    fix: function fix(event) {\n      if (event[jQuery.expando]) {\n        return event;\n      } // Create a writable copy of the event object and normalize some properties\n\n\n      var i,\n          prop,\n          copy,\n          type = event.type,\n          originalEvent = event,\n          fixHook = this.fixHooks[type];\n\n      if (!fixHook) {\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n      }\n\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n      event = new jQuery.Event(originalEvent);\n      i = copy.length;\n\n      while (i--) {\n        prop = copy[i];\n        event[prop] = originalEvent[prop];\n      } // Support: IE<9\n      // Fix target property (#1925)\n\n\n      if (!event.target) {\n        event.target = originalEvent.srcElement || document;\n      } // Support: Safari 6-8+\n      // Target should not be a text node (#504, #13143)\n\n\n      if (event.target.nodeType === 3) {\n        event.target = event.target.parentNode;\n      } // Support: IE<9\n      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\n\n      event.metaKey = !!event.metaKey;\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n    },\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: (\"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase \" + \"metaKey relatedTarget shiftKey target timeStamp view which\").split(\" \"),\n    fixHooks: {},\n    keyHooks: {\n      props: \"char charCode key keyCode\".split(\" \"),\n      filter: function filter(event, original) {\n        // Add which for key events\n        if (event.which == null) {\n          event.which = original.charCode != null ? original.charCode : original.keyCode;\n        }\n\n        return event;\n      }\n    },\n    mouseHooks: {\n      props: (\"button buttons clientX clientY fromElement offsetX offsetY \" + \"pageX pageY screenX screenY toElement\").split(\" \"),\n      filter: function filter(event, original) {\n        var body,\n            eventDoc,\n            doc,\n            button = original.button,\n            fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available\n\n        if (event.pageX == null && original.clientX != null) {\n          eventDoc = event.target.ownerDocument || document;\n          doc = eventDoc.documentElement;\n          body = eventDoc.body;\n          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n        } // Add relatedTarget, if necessary\n\n\n        if (!event.relatedTarget && fromElement) {\n          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n        } // Add which for click: 1 === left; 2 === middle; 3 === right\n        // Note: button is not normalized, so don't use it\n\n\n        if (!event.which && button !== undefined) {\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n        }\n\n        return event;\n      }\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      focus: {\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function trigger() {\n          if (this !== safeActiveElement() && this.focus) {\n            try {\n              this.focus();\n              return false;\n            } catch (e) {// Support: IE<9\n              // If we error on focus to hidden element (#1486, #12518),\n              // let .trigger() run the handlers\n            }\n          }\n        },\n        delegateType: \"focusin\"\n      },\n      blur: {\n        trigger: function trigger() {\n          if (this === safeActiveElement() && this.blur) {\n            this.blur();\n            return false;\n          }\n        },\n        delegateType: \"focusout\"\n      },\n      click: {\n        // For checkbox, fire native event so checked state will be right\n        trigger: function trigger() {\n          if (jQuery.nodeName(this, \"input\") && this.type === \"checkbox\" && this.click) {\n            this.click();\n            return false;\n          }\n        },\n        // For cross-browser consistency, don't fire native .click() on links\n        _default: function _default(event) {\n          return jQuery.nodeName(event.target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    },\n    // Piggyback on a donor event to simulate a different one\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true // Previously, `originalEvent: {}` was set here, so stopPropagation call\n        // would not be triggered on donor event, since in our own\n        // jQuery.event.stopPropagation function we had a check for existence of\n        // originalEvent.stopPropagation method, so, consequently it would be a noop.\n        //\n        // Guard for simulated events was moved to jQuery.event.stopPropagation function\n        // since `originalEvent` should point to the original event for the\n        // constancy with other events and for more focused logic\n\n      });\n      jQuery.event.trigger(e, null, elem);\n\n      if (e.isDefaultPrevented()) {\n        event.preventDefault();\n      }\n    }\n  };\n  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  } : function (elem, type, handle) {\n    var name = \"on\" + type;\n\n    if (elem.detachEvent) {\n      // #8545, #7054, preventing memory leaks for custom events in IE6-8\n      // detachEvent needed property on element, by name of that event,\n      // to properly expose it to GC\n      if (typeof elem[name] === \"undefined\") {\n        elem[name] = null;\n      }\n\n      elem.detachEvent(name, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: IE < 9, Android < 4.0\n      src.returnValue === false ? returnTrue : returnFalse; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (!e) {\n        return;\n      } // If preventDefault exists, run it on the original event\n\n\n      if (e.preventDefault) {\n        e.preventDefault(); // Support: IE\n        // Otherwise set the returnValue property of the original event to false\n      } else {\n        e.returnValue = false;\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (!e || this.isSimulated) {\n        return;\n      } // If stopPropagation exists, run it on the original event\n\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } // Support: IE\n      // Set the cancelBubble property of the original event to true\n\n\n      e.cancelBubble = true;\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && e.stopImmediatePropagation) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://code.google.com/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  }); // IE submit delegation\n\n  if (!support.submit) {\n    jQuery.event.special.submit = {\n      setup: function setup() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Lazy-add a submit handler when a descendant form may potentially be submitted\n\n\n        jQuery.event.add(this, \"click._submit keypress._submit\", function (e) {\n          // Node name check avoids a VML-related crash in IE (#9807)\n          var elem = e.target,\n              form = jQuery.nodeName(elem, \"input\") || jQuery.nodeName(elem, \"button\") ? // Support: IE <=8\n          // We use jQuery.prop instead of elem.form\n          // to allow fixing the IE8 delegated submit issue (gh-2332)\n          // by 3rd party polyfills/workarounds.\n          jQuery.prop(elem, \"form\") : undefined;\n\n          if (form && !jQuery._data(form, \"submit\")) {\n            jQuery.event.add(form, \"submit._submit\", function (event) {\n              event._submitBubble = true;\n            });\n\n            jQuery._data(form, \"submit\", true);\n          }\n        }); // return undefined since we don't need an event listener\n      },\n      postDispatch: function postDispatch(event) {\n        // If form was submitted by the user, bubble the event up the tree\n        if (event._submitBubble) {\n          delete event._submitBubble;\n\n          if (this.parentNode && !event.isTrigger) {\n            jQuery.event.simulate(\"submit\", this.parentNode, event);\n          }\n        }\n      },\n      teardown: function teardown() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\n\n        jQuery.event.remove(this, \"._submit\");\n      }\n    };\n  } // IE change delegation and checkbox/radio fix\n\n\n  if (!support.change) {\n    jQuery.event.special.change = {\n      setup: function setup() {\n        if (rformElems.test(this.nodeName)) {\n          // IE doesn't fire change on a check/radio until blur; trigger it on click\n          // after a propertychange. Eat the blur-change in special.change.handle.\n          // This still fires onchange a second time for check/radio after blur.\n          if (this.type === \"checkbox\" || this.type === \"radio\") {\n            jQuery.event.add(this, \"propertychange._change\", function (event) {\n              if (event.originalEvent.propertyName === \"checked\") {\n                this._justChanged = true;\n              }\n            });\n            jQuery.event.add(this, \"click._change\", function (event) {\n              if (this._justChanged && !event.isTrigger) {\n                this._justChanged = false;\n              } // Allow triggered, simulated change events (#11500)\n\n\n              jQuery.event.simulate(\"change\", this, event);\n            });\n          }\n\n          return false;\n        } // Delegated event; lazy-add a change handler on descendant inputs\n\n\n        jQuery.event.add(this, \"beforeactivate._change\", function (e) {\n          var elem = e.target;\n\n          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, \"change\")) {\n            jQuery.event.add(elem, \"change._change\", function (event) {\n              if (this.parentNode && !event.isSimulated && !event.isTrigger) {\n                jQuery.event.simulate(\"change\", this.parentNode, event);\n              }\n            });\n\n            jQuery._data(elem, \"change\", true);\n          }\n        });\n      },\n      handle: function handle(event) {\n        var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above\n\n        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== \"radio\" && elem.type !== \"checkbox\") {\n          return event.handleObj.handler.apply(this, arguments);\n        }\n      },\n      teardown: function teardown() {\n        jQuery.event.remove(this, \"._change\");\n        return !rformElems.test(this.nodeName);\n      }\n    };\n  } // Support: Firefox\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome, Safari\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\n\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          var doc = this.ownerDocument || this,\n              attaches = jQuery._data(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          jQuery._data(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this,\n              attaches = jQuery._data(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n\n            jQuery._removeData(doc, fix);\n          } else {\n            jQuery._data(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    },\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n  var rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n      rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      // Support: IE 10-11, Edge 10240+\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rscriptTypeMasked = /^true\\/(.*)/,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n      safeFragment = createSafeFragment(document),\n      fragmentDiv = safeFragment.appendChild(document.createElement(\"div\")); // Support: IE<8\n  // Manipulating tables requires a tbody\n\n  function manipulationTarget(elem, content) {\n    return jQuery.nodeName(elem, \"table\") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (jQuery.find.attr(elem, \"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    var match = rscriptTypeMasked.exec(elem.type);\n\n    if (match) {\n      elem.type = match[1];\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {\n      return;\n    }\n\n    var type,\n        i,\n        l,\n        oldData = jQuery._data(src),\n        curData = jQuery._data(dest, oldData),\n        events = oldData.events;\n\n    if (events) {\n      delete curData.handle;\n      curData.events = {};\n\n      for (type in events) {\n        for (i = 0, l = events[type].length; i < l; i++) {\n          jQuery.event.add(dest, type, events[type][i]);\n        }\n      }\n    } // make the cloned public data object a copy from the original\n\n\n    if (curData.data) {\n      curData.data = jQuery.extend({}, curData.data);\n    }\n  }\n\n  function fixCloneNodeIssues(src, dest) {\n    var nodeName, e, data; // We do not need to do anything for non-Elements\n\n    if (dest.nodeType !== 1) {\n      return;\n    }\n\n    nodeName = dest.nodeName.toLowerCase(); // IE6-8 copies events bound via attachEvent when using cloneNode.\n\n    if (!support.noCloneEvent && dest[jQuery.expando]) {\n      data = jQuery._data(dest);\n\n      for (e in data.events) {\n        jQuery.removeEvent(dest, e, data.handle);\n      } // Event data gets referenced instead of copied if the expando gets copied too\n\n\n      dest.removeAttribute(jQuery.expando);\n    } // IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\n\n    if (nodeName === \"script\" && dest.text !== src.text) {\n      disableScript(dest).text = src.text;\n      restoreScript(dest); // IE6-10 improperly clones children of object elements using classid.\n      // IE10 throws NoModificationAllowedError if parent is null, #12132.\n    } else if (nodeName === \"object\") {\n      if (dest.parentNode) {\n        dest.outerHTML = src.outerHTML;\n      } // This path appears unavoidable for IE9. When cloning an object\n      // element in IE9, the outerHTML strategy above is not sufficient.\n      // If the src has innerHTML and the destination does not,\n      // copy the src.innerHTML into the dest.innerHTML. #10324\n\n\n      if (support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {\n        dest.innerHTML = src.innerHTML;\n      }\n    } else if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      // IE6-8 fails to persist the checked state of a cloned checkbox\n      // or radio button. Worse, IE6-7 fail to give the cloned element\n      // a checked appearance if the defaultChecked value isn't also set\n      dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned\n      // checkbox/radio button to an empty string instead of \"on\"\n\n      if (dest.value !== src.value) {\n        dest.value = src.value;\n      } // IE6-8 fails to return the selected option to the default selected\n      // state when cloning options\n\n    } else if (nodeName === \"option\") {\n      dest.defaultSelected = dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when\n      // cloning other types of input fields\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = concat.apply([], args);\n    var first,\n        node,\n        hasScripts,\n        scripts,\n        doc,\n        fragment,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (isFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (isFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android<4.1, PhantomJS<2\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !jQuery._data(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src) {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl) {\n                  jQuery._evalUrl(node.src);\n                }\n              } else {\n                jQuery.globalEval((node.text || node.textContent || node.innerHTML || \"\").replace(rcleanScript, \"\"));\n              }\n            }\n          }\n        } // Fix #11809: Avoid leaking memory\n\n\n        fragment = first = null;\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        elems = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = elems[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && jQuery.contains(node.ownerDocument, node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html.replace(rxhtmlTag, \"<$1></$2>\");\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var destElements,\n          node,\n          clone,\n          i,\n          srcElements,\n          inPage = jQuery.contains(elem.ownerDocument, elem);\n\n      if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test(\"<\" + elem.nodeName + \">\")) {\n        clone = elem.cloneNode(true); // IE<=8 does not properly clone detached, unknown element nodes\n      } else {\n        fragmentDiv.innerHTML = elem.outerHTML;\n        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);\n      }\n\n      if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem); // Fix all IE cloning issues\n\n        for (i = 0; (node = srcElements[i]) != null; ++i) {\n          // Ensure that the destination node is not null; Fixes #9587\n          if (destElements[i]) {\n            fixCloneNodeIssues(node, destElements[i]);\n          }\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0; (node = srcElements[i]) != null; i++) {\n            cloneCopyEvent(node, destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      }\n\n      destElements = srcElements = node = null; // Return the cloned set\n\n      return clone;\n    },\n    cleanData: function cleanData(elems,\n    /* internal */\n    forceAcceptData) {\n      var elem,\n          type,\n          id,\n          data,\n          i = 0,\n          internalKey = jQuery.expando,\n          cache = jQuery.cache,\n          attributes = support.attributes,\n          special = jQuery.event.special;\n\n      for (; (elem = elems[i]) != null; i++) {\n        if (forceAcceptData || acceptData(elem)) {\n          id = elem[internalKey];\n          data = id && cache[id];\n\n          if (data) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Remove cache only if it was not already removed by jQuery.event.remove\n\n\n            if (cache[id]) {\n              delete cache[id]; // Support: IE<9\n              // IE does not allow us to delete expando properties from nodes\n              // IE creates expando attributes along with the property\n              // IE does not have a removeAttribute function on Document nodes\n\n              if (!attributes && typeof elem.removeAttribute !== \"undefined\") {\n                elem.removeAttribute(internalKey); // Webkit & Blink performance suffers when deleting properties\n                // from DOM nodes, so set to undefined instead\n                // https://code.google.com/p/chromium/issues/detail?id=378607\n              } else {\n                elem[internalKey] = undefined;\n              }\n\n              deletedIds.push(id);\n            }\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    // Keep domManip exposed until 3.0 (gh-2225)\n    domManip: domManip,\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        // Remove element nodes and prevent memory leaks\n        if (elem.nodeType === 1) {\n          jQuery.cleanData(getAll(elem, false));\n        } // Remove any remaining nodes\n\n\n        while (elem.firstChild) {\n          elem.removeChild(elem.firstChild);\n        } // If this is a select, ensure that it displays empty (#12336)\n        // Support: IE<9\n\n\n        if (elem.options && jQuery.nodeName(elem, \"select\")) {\n          elem.options.length = 0;\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined) {\n          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, \"\") : undefined;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              // Remove element nodes and prevent memory leaks\n              elem = this[i] || {};\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          i = 0,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var iframe,\n      elemdisplay = {\n    // Support: Firefox\n    // We have to pre-define these values for FF (#10227)\n    HTML: \"block\",\n    BODY: \"block\"\n  };\n  /**\n   * Retrieve the actual display of a element\n   * @param {String} name nodeName of the element\n   * @param {Object} doc Document object\n   */\n  // Called only from within defaultDisplay\n\n  function actualDisplay(name, doc) {\n    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n        display = jQuery.css(elem[0], \"display\"); // We don't have any data stored on the element,\n    // so use \"detach\" method as fast way to get rid of the element\n\n    elem.detach();\n    return display;\n  }\n  /**\n   * Try to determine the default display value of an element\n   * @param {String} nodeName\n   */\n\n\n  function defaultDisplay(nodeName) {\n    var doc = document,\n        display = elemdisplay[nodeName];\n\n    if (!display) {\n      display = actualDisplay(nodeName, doc); // If the simple way fails, read from inside an iframe\n\n      if (display === \"none\" || !display) {\n        // Use the already-created iframe if possible\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\n        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document; // Support: IE\n\n        doc.write();\n        doc.close();\n        display = actualDisplay(nodeName, doc);\n        iframe.detach();\n      } // Store the correct default display\n\n\n      elemdisplay[nodeName] = display;\n    }\n\n    return display;\n  }\n\n  var rmargin = /^margin/;\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var swap = function swap(elem, options, callback, args) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.apply(elem, args || []); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  var documentElement = document.documentElement;\n\n  (function () {\n    var pixelPositionVal,\n        pixelMarginRightVal,\n        boxSizingReliableVal,\n        reliableHiddenOffsetsVal,\n        reliableMarginRightVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    }\n\n    div.style.cssText = \"float:left;opacity:.5\"; // Support: IE<9\n    // Make sure that element opacity exists (as opposed to filter)\n\n    support.opacity = div.style.opacity === \"0.5\"; // Verify style float existence\n    // (IE uses styleFloat instead of cssFloat)\n\n    support.cssFloat = !!div.style.cssFloat;\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    container = document.createElement(\"div\");\n    container.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" + \"padding:0;margin-top:1px;position:absolute\";\n    div.innerHTML = \"\";\n    container.appendChild(div); // Support: Firefox<29, Android 2.3\n    // Vendor-prefix box-sizing\n\n    support.boxSizing = div.style.boxSizing === \"\" || div.style.MozBoxSizing === \"\" || div.style.WebkitBoxSizing === \"\";\n    jQuery.extend(support, {\n      reliableHiddenOffsets: function reliableHiddenOffsets() {\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return reliableHiddenOffsetsVal;\n      },\n      boxSizingReliable: function boxSizingReliable() {\n        // We're checking for pixelPositionVal here instead of boxSizingReliableVal\n        // since that compresses better and they're computed together anyway.\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return boxSizingReliableVal;\n      },\n      pixelMarginRight: function pixelMarginRight() {\n        // Support: Android 4.0-4.3\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return pixelMarginRightVal;\n      },\n      pixelPosition: function pixelPosition() {\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return pixelPositionVal;\n      },\n      reliableMarginRight: function reliableMarginRight() {\n        // Support: Android 2.3\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return reliableMarginRightVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n        if (pixelPositionVal == null) {\n          computeStyleTests();\n        }\n\n        return reliableMarginLeftVal;\n      }\n    });\n\n    function computeStyleTests() {\n      var contents,\n          divStyle,\n          documentElement = document.documentElement; // Setup\n\n      documentElement.appendChild(container);\n      div.style.cssText = // Support: Android 2.3\n      // Vendor-prefix box-sizing\n      \"-webkit-box-sizing:border-box;box-sizing:border-box;\" + \"position:relative;display:block;\" + \"margin:auto;border:1px;padding:1px;\" + \"top:1%;width:50%\"; // Support: IE<9\n      // Assume reasonable values in the absence of getComputedStyle\n\n      pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;\n      pixelMarginRightVal = reliableMarginRightVal = true; // Check for getComputedStyle so that this code is not run in IE<9.\n\n      if (window.getComputedStyle) {\n        divStyle = window.getComputedStyle(div);\n        pixelPositionVal = (divStyle || {}).top !== \"1%\";\n        reliableMarginLeftVal = (divStyle || {}).marginLeft === \"2px\";\n        boxSizingReliableVal = (divStyle || {\n          width: \"4px\"\n        }).width === \"4px\"; // Support: Android 4.0 - 4.3 only\n        // Some styles come back with percentage values, even though they shouldn't\n\n        div.style.marginRight = \"50%\";\n        pixelMarginRightVal = (divStyle || {\n          marginRight: \"4px\"\n        }).marginRight === \"4px\"; // Support: Android 2.3 only\n        // Div with explicit width and no margin-right incorrectly\n        // gets computed margin-right based on width of container (#3333)\n        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\n        contents = div.appendChild(document.createElement(\"div\")); // Reset CSS: box-sizing; display; margin; border; padding\n\n        contents.style.cssText = div.style.cssText = // Support: Android 2.3\n        // Vendor-prefix box-sizing\n        \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" + \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n        contents.style.marginRight = contents.style.width = \"0\";\n        div.style.width = \"1px\";\n        reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents) || {}).marginRight);\n        div.removeChild(contents);\n      } // Support: IE6-8\n      // First check that getClientRects works as expected\n      // Check if table cells still have offsetWidth/Height when they are set\n      // to display:none and there are still other visible table cells in a\n      // table row; if so, offsetWidth/Height are not reliable for use when\n      // determining if an element has been hidden directly using\n      // display:none (it is still safe to use offsets if a parent element is\n      // hidden; don safety goggles and see bug #4512 for more information).\n\n\n      div.style.display = \"none\";\n      reliableHiddenOffsetsVal = div.getClientRects().length === 0;\n\n      if (reliableHiddenOffsetsVal) {\n        div.style.display = \"\";\n        div.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n        contents = div.getElementsByTagName(\"td\");\n        contents[0].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n        reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;\n\n        if (reliableHiddenOffsetsVal) {\n          contents[0].style.display = \"\";\n          contents[1].style.display = \"none\";\n          reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;\n        }\n      } // Teardown\n\n\n      documentElement.removeChild(container);\n    }\n  })();\n\n  var getStyles,\n      curCSS,\n      rposition = /^(top|right|bottom|left)$/;\n\n  if (window.getComputedStyle) {\n    getStyles = function getStyles(elem) {\n      // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n      // IE throws on elements created in popups\n      // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n      var view = elem.ownerDocument.defaultView;\n\n      if (!view || !view.opener) {\n        view = window;\n      }\n\n      return view.getComputedStyle(elem);\n    };\n\n    curCSS = function curCSS(elem, name, computed) {\n      var width,\n          minWidth,\n          maxWidth,\n          ret,\n          style = elem.style;\n      computed = computed || getStyles(elem); // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\n      ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined; // Support: Opera 12.1x only\n      // Fall back to style even without computed\n      // computed is undefined for elems on document fragments\n\n      if ((ret === \"\" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {\n        ret = jQuery.style(elem, name);\n      }\n\n      if (computed) {\n        // A tribute to the \"awesome hack by Dean Edwards\"\n        // Chrome < 17 and Safari 5.0 uses \"computed value\"\n        // instead of \"used value\" for margin-right\n        // Safari 5.1.7 (at least) returns percentage for a larger set of values,\n        // but width seems to be reliably pixels\n        // this is against the CSSOM draft spec:\n        // http://dev.w3.org/csswg/cssom/#resolved-values\n        if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\n          // Remember the original values\n          width = style.width;\n          minWidth = style.minWidth;\n          maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n          style.minWidth = style.maxWidth = style.width = ret;\n          ret = computed.width; // Revert the changed values\n\n          style.width = width;\n          style.minWidth = minWidth;\n          style.maxWidth = maxWidth;\n        }\n      } // Support: IE\n      // IE returns zIndex value as an integer.\n\n\n      return ret === undefined ? ret : ret + \"\";\n    };\n  } else if (documentElement.currentStyle) {\n    getStyles = function getStyles(elem) {\n      return elem.currentStyle;\n    };\n\n    curCSS = function curCSS(elem, name, computed) {\n      var left,\n          rs,\n          rsLeft,\n          ret,\n          style = elem.style;\n      computed = computed || getStyles(elem);\n      ret = computed ? computed[name] : undefined; // Avoid setting ret to empty string here\n      // so we don't default to auto\n\n      if (ret == null && style && style[name]) {\n        ret = style[name];\n      } // From the awesome hack by Dean Edwards\n      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n      // If we're not dealing with a regular pixel number\n      // but a number that has a weird ending, we need to convert it to pixels\n      // but not position css attributes, as those are\n      // proportional to the parent element instead\n      // and we can't measure the parent instead because it\n      // might trigger a \"stacking dolls\" problem\n\n\n      if (rnumnonpx.test(ret) && !rposition.test(name)) {\n        // Remember the original values\n        left = style.left;\n        rs = elem.runtimeStyle;\n        rsLeft = rs && rs.left; // Put in the new values to get a computed value out\n\n        if (rsLeft) {\n          rs.left = elem.currentStyle.left;\n        }\n\n        style.left = name === \"fontSize\" ? \"1em\" : ret;\n        ret = style.pixelLeft + \"px\"; // Revert the changed values\n\n        style.left = left;\n\n        if (rsLeft) {\n          rs.left = rsLeft;\n        }\n      } // Support: IE\n      // IE returns zIndex value as an integer.\n\n\n      return ret === undefined ? ret : ret + \"\" || \"auto\";\n    };\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var ralpha = /alpha\\([^)]*\\)/i,\n      ropacity = /opacity\\s*=\\s*([^)]*)/i,\n      // swappable if display is none or starts with table except\n  // \"table\", \"table-cell\", or \"table-caption\"\n  // see here for display values:\n  // https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rnumsplit = new RegExp(\"^(\" + pnum + \")(.*)$\", \"i\"),\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  },\n      cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style; // return a css property mapped to a potentially vendor prefixed property\n\n  function vendorPropName(name) {\n    // shortcut for names that are not vendor prefixed\n    if (name in emptyStyle) {\n      return name;\n    } // check for vendor prefixed names\n\n\n    var capName = name.charAt(0).toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      values[index] = jQuery._data(elem, \"olddisplay\");\n      display = elem.style.display;\n\n      if (show) {\n        // Reset the inline display of this element to learn if it is\n        // being hidden by cascaded rules or not\n        if (!values[index] && display === \"none\") {\n          elem.style.display = \"\";\n        } // Set elements which have been overridden with display: none\n        // in a stylesheet to whatever the default browser style is\n        // for such an element\n\n\n        if (elem.style.display === \"\" && isHidden(elem)) {\n          values[index] = jQuery._data(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n        }\n      } else {\n        hidden = isHidden(elem);\n\n        if (display && display !== \"none\" || !hidden) {\n          jQuery._data(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n        }\n      }\n    } // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      if (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n        elem.style.display = show ? values[index] || \"\" : \"none\";\n      }\n    }\n\n    return elements;\n  }\n\n  function setPositiveNumber(elem, value, subtract) {\n    var matches = rnumsplit.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n  }\n\n  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n    var i = extra === (isBorderBox ? \"border\" : \"content\") ? // If we already have the right measurement, avoid augmentation\n    4 : // Otherwise initialize for horizontal or vertical properties\n    name === \"width\" ? 1 : 0,\n        val = 0;\n\n    for (; i < 4; i += 2) {\n      // both box models exclude margin, so add it if we want it\n      if (extra === \"margin\") {\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n      }\n\n      if (isBorderBox) {\n        // border-box includes padding, so remove it if we want content\n        if (extra === \"content\") {\n          val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // at this point, extra isn't border nor margin, so remove border\n\n\n        if (extra !== \"margin\") {\n          val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      } else {\n        // at this point, extra isn't content, so add padding\n        val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // at this point, extra isn't content nor padding, so add border\n\n        if (extra !== \"padding\") {\n          val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    }\n\n    return val;\n  }\n\n  function getWidthOrHeight(elem, name, extra) {\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles(elem),\n        isBorderBox = support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Support: IE11 only\n    // In IE 11 fullscreen elements inside of an iframe have\n    // 100x too small dimensions (gh-1764).\n\n    if (document.msFullscreenElement && window.top !== window) {\n      // Support: IE11 only\n      // Running getBoundingClientRect on a disconnected node\n      // in IE throws an error.\n      if (elem.getClientRects().length) {\n        val = Math.round(elem.getBoundingClientRect()[name] * 100);\n      }\n    } // some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\n\n    if (val <= 0 || val == null) {\n      // Fall back to computed then uncomputed css if necessary\n      val = curCSS(elem, name, styles);\n\n      if (val < 0 || val == null) {\n        val = elem.style[name];\n      } // Computed unit is not pixels. Stop here and return.\n\n\n      if (rnumnonpx.test(val)) {\n        return val;\n      } // we need the check for style in case a browser which returns unreliable values\n      // for getComputedStyle silently falls back to the reliable elem.style\n\n\n      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]); // Normalize \"\", auto, and prepare for extra\n\n      val = parseFloat(val) || 0;\n    } // use the active box-sizing model to add/subtract irrelevant styles\n\n\n    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n      // normalize float css property\n      \"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = jQuery.camelCase(name),\n          style = elem.style;\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set. See: #7116\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n\n\n        if (type === \"number\") {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n        // but it would mean to define eight\n        // (for every problematic property) identical functions\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          // Support: IE\n          // Swallow errors from 'invalid' CSS values (#5509)\n          try {\n            style[name] = value;\n          } catch (e) {}\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var num,\n          val,\n          hooks,\n          origName = jQuery.camelCase(name); // Make sure that we're working with the right name\n\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } //convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Return, converting to number if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (i, name) {\n    jQuery.cssHooks[name] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // certain elements can have dimension info if we invisibly show them\n          // however, it must have a current display style that would benefit from this\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, name, extra);\n          }) : getWidthOrHeight(elem, name, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var styles = extra && getStyles(elem);\n        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n      }\n    };\n  });\n\n  if (!support.opacity) {\n    jQuery.cssHooks.opacity = {\n      get: function get(elem, computed) {\n        // IE uses filters for opacity\n        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ? 0.01 * parseFloat(RegExp.$1) + \"\" : computed ? \"1\" : \"\";\n      },\n      set: function set(elem, value) {\n        var style = elem.style,\n            currentStyle = elem.currentStyle,\n            opacity = jQuery.isNumeric(value) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n            filter = currentStyle && currentStyle.filter || style.filter || \"\"; // IE has trouble with opacity if it does not have layout\n        // Force it by setting the zoom level\n\n        style.zoom = 1; // if setting opacity to 1, and no other filters exist -\n        // attempt to remove filter attribute #6652\n        // if value === \"\", then remove inline opacity #12685\n\n        if ((value >= 1 || value === \"\") && jQuery.trim(filter.replace(ralpha, \"\")) === \"\" && style.removeAttribute) {\n          // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n          // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n          // style.removeAttribute is IE Only, but so apparently is this code path...\n          style.removeAttribute(\"filter\"); // if there is no filter style applied in a css rule\n          // or unset inline opacity, we are done\n\n          if (value === \"\" || currentStyle && !currentStyle.filter) {\n            return;\n          }\n        } // otherwise, set new filter values\n\n\n        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + \" \" + opacity;\n      }\n    };\n  }\n\n  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\n    if (computed) {\n      return swap(elem, {\n        \"display\": \"inline-block\"\n      }, curCSS, [elem, \"marginRight\"]);\n    }\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || ( // Support: IE<=11+\n      // Running getBoundingClientRect on a disconnected node in IE throws an error\n      // Support: IE8 only\n      // getClientRects() errors on disconnected elems\n      jQuery.contains(elem.ownerDocument, elem) ? elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      }) : 0)) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (!rmargin.test(prefix)) {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (jQuery.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    },\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHidden(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails\n        // so, simple values such as \"10px\" are parsed to Float.\n        // complex values such as \"rotate(1rad)\" are returned as is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // use step hook for back compat - use cssHook if its there - use .style if its\n        // available and use plain properties where available\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back Compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      timerId,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/; // Animations created synchronously will run synchronously\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = jQuery.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        attrs = {\n      height: type\n    },\n        i = 0; // if we include width, step value is 1 to do all cssExpand values,\n    // if we don't include width, step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // we're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    /* jshint validthis: true */\n    var prop,\n        value,\n        toggle,\n        tween,\n        hooks,\n        oldfire,\n        display,\n        checkDisplay,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHidden(elem),\n        dataShow = jQuery._data(elem, \"fxshow\"); // handle queue: false promises\n\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // doing this makes sure that the complete handler will be called\n        // before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // height/width overflow pass\n\n\n    if (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n      // Make sure that nothing sneaks out\n      // Record all 3 overflow attributes because IE does not\n      // change the overflow attribute when overflowX and\n      // overflowY are set to the same value\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width\n      // animations on inline elements that are having width/height animated\n\n      display = jQuery.css(elem, \"display\"); // Test default display if display is currently \"none\"\n\n      checkDisplay = display === \"none\" ? jQuery._data(elem, \"olddisplay\") || defaultDisplay(elem.nodeName) : display;\n\n      if (checkDisplay === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n        // inline-level elements accept inline-block;\n        // block-level elements need to be inline with layout\n        if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === \"inline\") {\n          style.display = \"inline-block\";\n        } else {\n          style.zoom = 1;\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n\n      if (!support.shrinkWrapBlocks()) {\n        anim.always(function () {\n          style.overflow = opts.overflow[0];\n          style.overflowX = opts.overflow[1];\n          style.overflowY = opts.overflow[2];\n        });\n      }\n    } // show/hide pass\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.exec(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // If there is dataShow left over from a stopped hide or show\n          // and we are going to proceed with show, we should pretend to be hidden\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true;\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop); // Any non-fx value stops us from restoring the original display value\n      } else {\n        display = undefined;\n      }\n    }\n\n    if (!jQuery.isEmptyObject(orig)) {\n      if (dataShow) {\n        if (\"hidden\" in dataShow) {\n          hidden = dataShow.hidden;\n        }\n      } else {\n        dataShow = jQuery._data(elem, \"fxshow\", {});\n      } // store state if its toggle - enables .stop().toggle() to \"reverse\"\n\n\n      if (toggle) {\n        dataShow.hidden = !hidden;\n      }\n\n      if (hidden) {\n        jQuery(elem).show();\n      } else {\n        anim.done(function () {\n          jQuery(elem).hide();\n        });\n      }\n\n      anim.done(function () {\n        var prop;\n\n        jQuery._removeData(elem, \"fxshow\");\n\n        for (prop in orig) {\n          jQuery.style(elem, prop, orig[prop]);\n        }\n      });\n\n      for (prop in orig) {\n        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n        if (!(prop in dataShow)) {\n          dataShow[prop] = tween.start;\n\n          if (hidden) {\n            tween.end = tween.start;\n            tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n          }\n        }\n      } // If this is a noop like .hide().hide(), restore an overwritten display value\n\n    } else if ((display === \"none\" ? defaultDisplay(elem.nodeName) : display) === \"inline\") {\n      style.display = display;\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = jQuery.camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (jQuery.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // not quite $.extend, this wont overwrite keys already present.\n        // also - reusing 'index' from above because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]);\n\n      if (percent < 1 && length) {\n        return remaining;\n      } else {\n        deferred.resolveWith(elem, [animation]);\n        return false;\n      }\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // if we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // resolve when we played the last frame\n        // otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (jQuery.isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (jQuery.isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    })); // attach callbacks from options\n\n    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (jQuery.isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnotwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n    };\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> \"fx\"\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (jQuery.isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // show any hidden elements after setting opacity to 0\n      return this.filter(isHidden).css(\"opacity\", 0).show() // animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || jQuery._data(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = jQuery._data(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // start the next in the queue if the last step wasn't forced\n        // timers currently will call their complete callbacks, which will dequeue\n        // but only if they were gotoEnd\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = jQuery._data(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // enable finishing flag on private data\n\n\n        data.finish = true; // empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        timers = jQuery.timers,\n        i = 0;\n    fxNow = jQuery.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Checks the timer has not already been removed\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n\n    if (timer()) {\n      jQuery.fx.start();\n    } else {\n      jQuery.timers.pop();\n    }\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (!timerId) {\n      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);\n    }\n  };\n\n  jQuery.fx.stop = function () {\n    window.clearInterval(timerId);\n    timerId = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var a,\n        input = document.createElement(\"input\"),\n        div = document.createElement(\"div\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\")); // Setup\n\n    div = document.createElement(\"div\");\n    div.setAttribute(\"className\", \"t\");\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n    a = div.getElementsByTagName(\"a\")[0]; // Support: Windows Web Apps (WWA)\n    // `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"checkbox\");\n    div.appendChild(input);\n    a = div.getElementsByTagName(\"a\")[0]; // First batch of tests.\n\n    a.style.cssText = \"top:1px\"; // Test setAttribute on camelCase class.\n    // If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\n    support.getSetAttribute = div.className !== \"t\"; // Get the style information from getAttribute\n    // (IE uses .cssText instead)\n\n    support.style = /top/.test(a.getAttribute(\"style\")); // Make sure that URLs aren't manipulated\n    // (IE normalizes it by default)\n\n    support.hrefNormalized = a.getAttribute(\"href\") === \"/a\"; // Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\n    support.checkOn = !!input.value; // Make sure that a selected-by-default option has a working selected property.\n    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\n    support.optSelected = opt.selected; // Tests for enctype support on a form (#6743)\n\n    support.enctype = !!document.createElement(\"form\").enctype; // Make sure that the options inside disabled selects aren't marked as disabled\n    // (WebKit marks them as disabled)\n\n    select.disabled = true;\n    support.optDisabled = !opt.disabled; // Support: IE8 only\n    // Check if we can trust getAttribute(\"value\")\n\n    input = document.createElement(\"input\");\n    input.setAttribute(\"value\", \"\");\n    support.input = input.getAttribute(\"value\") === \"\"; // Check if an input maintains its value after becoming a radio\n\n    input.value = \"t\";\n    input.setAttribute(\"type\", \"radio\");\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var rreturn = /\\r/g,\n      rspaces = /[\\x20\\t\\r\\n\\f]+/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          isFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value;\n          return typeof ret === \"string\" ? // handle most common string cases\n          ret.replace(rreturn, \"\") : // handle cases where value is null/undef or number\n          ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      isFunction = jQuery.isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (isFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (jQuery.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE10-11+\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          jQuery.trim(jQuery.text(elem)).replace(rspaces, \" \");\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\" || index < 0,\n              values = one ? null : [],\n              max = one ? index + 1 : options.length,\n              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options\n\n          for (; i < max; i++) {\n            option = options[i]; // oldIE doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup\n            support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n\n            if (jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              // Support: IE6\n              // When new option element is added to select box we need to\n              // force reflow of newly added node in order to workaround delay\n              // of initialization properties\n              try {\n                option.selected = optionSet = true;\n              } catch (_) {\n                // Will be executed only in IE6\n                option.scrollHeight;\n              }\n            } else {\n              option.selected = false;\n            }\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return options;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (jQuery.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  });\n  var nodeHook,\n      boolHook,\n      attrHandle = jQuery.expr.attrHandle,\n      ruseDefault = /^(?:checked|selected)$/i,\n      getSetAttribute = support.getSetAttribute,\n      getSetInput = support.input;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // All attributes are lowercase\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        name = name.toLowerCase();\n        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n            // Setting the type on a radio button after the value resets the value in IE8-9\n            // Reset value to default in case type is set after value during creation\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          propName,\n          i = 0,\n          attrNames = value && value.match(rnotwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          propName = jQuery.propFix[name] || name; // Boolean attributes get special treatment (#10870)\n\n          if (jQuery.expr.match.bool.test(name)) {\n            // Set corresponding property to false\n            if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n              elem[propName] = false; // Support: IE<9\n              // Also clear defaultChecked/defaultSelected (if appropriate)\n            } else {\n              elem[jQuery.camelCase(\"default-\" + name)] = elem[propName] = false;\n            } // See #9699 for explanation of this approach (setting first, then removal)\n\n          } else {\n            jQuery.attr(elem, name, \"\");\n          }\n\n          elem.removeAttribute(getSetAttribute ? name : propName);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n        // IE<8 needs the *property* name\n        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);\n      } else {\n        // Support: IE<9\n        // Use defaultChecked and defaultSelected for oldIE\n        elem[jQuery.camelCase(\"default-\" + name)] = elem[name] = true;\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n      attrHandle[name] = function (elem, name, isXML) {\n        var ret, handle;\n\n        if (!isXML) {\n          // Avoid an infinite loop by temporarily removing this function from the getter\n          handle = attrHandle[name];\n          attrHandle[name] = ret;\n          ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;\n          attrHandle[name] = handle;\n        }\n\n        return ret;\n      };\n    } else {\n      attrHandle[name] = function (elem, name, isXML) {\n        if (!isXML) {\n          return elem[jQuery.camelCase(\"default-\" + name)] ? name.toLowerCase() : null;\n        }\n      };\n    }\n  }); // fix oldIE attroperties\n\n  if (!getSetInput || !getSetAttribute) {\n    jQuery.attrHooks.value = {\n      set: function set(elem, value, name) {\n        if (jQuery.nodeName(elem, \"input\")) {\n          // Does not return so that setAttribute is also used\n          elem.defaultValue = value;\n        } else {\n          // Use nodeHook if defined (#1954); otherwise setAttribute is fine\n          return nodeHook && nodeHook.set(elem, value, name);\n        }\n      }\n    };\n  } // IE6/7 do not support getting/setting some attributes with get/setAttribute\n\n\n  if (!getSetAttribute) {\n    // Use this for any attribute in IE6/7\n    // This fixes almost every IE6/7 issue\n    nodeHook = {\n      set: function set(elem, value, name) {\n        // Set the existing or create a new attribute node\n        var ret = elem.getAttributeNode(name);\n\n        if (!ret) {\n          elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));\n        }\n\n        ret.value = value += \"\"; // Break association with cloned elements by also using setAttribute (#9646)\n\n        if (name === \"value\" || value === elem.getAttribute(name)) {\n          return value;\n        }\n      }\n    }; // Some attributes are constructed with empty-string values when not defined\n\n    attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {\n      var ret;\n\n      if (!isXML) {\n        return (ret = elem.getAttributeNode(name)) && ret.value !== \"\" ? ret.value : null;\n      }\n    }; // Fixing value retrieval on a button requires this module\n\n\n    jQuery.valHooks.button = {\n      get: function get(elem, name) {\n        var ret = elem.getAttributeNode(name);\n\n        if (ret && ret.specified) {\n          return ret.value;\n        }\n      },\n      set: nodeHook.set\n    }; // Set contenteditable to false on removals(#10429)\n    // Setting to empty string throws an error as an invalid value\n\n    jQuery.attrHooks.contenteditable = {\n      set: function set(elem, value, name) {\n        nodeHook.set(elem, value === \"\" ? false : value, name);\n      }\n    }; // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    // This is for removals\n\n    jQuery.each([\"width\", \"height\"], function (i, name) {\n      jQuery.attrHooks[name] = {\n        set: function set(elem, value) {\n          if (value === \"\") {\n            elem.setAttribute(name, \"auto\");\n            return value;\n          }\n        }\n      };\n    });\n  }\n\n  if (!support.style) {\n    jQuery.attrHooks.style = {\n      get: function get(elem) {\n        // Return undefined in the case of empty string\n        // Note: IE uppercases css property names, but if we were to .toLowerCase()\n        // .cssText, that would destroy case sensitivity in URL's, like in \"background\"\n        return elem.style.cssText || undefined;\n      },\n      set: function set(elem, value) {\n        return elem.style.cssText = value + \"\";\n      }\n    };\n  }\n\n  var rfocusable = /^(?:input|select|textarea|button|object)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      name = jQuery.propFix[name] || name;\n      return this.each(function () {\n        // try/catch handles cases where IE balks (such as removing a property on window)\n        try {\n          this[name] = undefined;\n          delete this[name];\n        } catch (e) {}\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Some attributes require a special call on IE\n  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n  if (!support.hrefNormalized) {\n    // href/src property should get the full normalized URL (#10299/#12915)\n    jQuery.each([\"href\", \"src\"], function (i, name) {\n      jQuery.propHooks[name] = {\n        get: function get(elem) {\n          return elem.getAttribute(name, 4);\n        }\n      };\n    });\n  } // Support: Safari, IE9+\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex; // Make sure that it also works with optgroups, see #5701\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n\n        return null;\n      },\n      set: function set(elem) {\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // IE6/7 call enctype encoding\n\n  if (!support.enctype) {\n    jQuery.propFix.enctype = \"encoding\";\n  }\n\n  var rclass = /[\\t\\r\\n\\f]/g;\n\n  function getClass(elem) {\n    return jQuery.attr(elem, \"class\") || \"\";\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (typeof value === \"string\" && value) {\n        classes = value.match(rnotwhite) || [];\n\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && (\" \" + curValue + \" \").replace(rclass, \" \");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // only assign if different to avoid unneeded rendering.\n\n\n            finalValue = jQuery.trim(cur);\n\n            if (curValue !== finalValue) {\n              jQuery.attr(elem, \"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      if (typeof value === \"string\" && value) {\n        classes = value.match(rnotwhite) || [];\n\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && (\" \" + curValue + \" \").replace(rclass, \" \");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = jQuery.trim(cur);\n\n            if (curValue !== finalValue) {\n              jQuery.attr(elem, \"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value);\n\n      if (typeof stateVal === \"boolean\" && type === \"string\") {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (type === \"string\") {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = value.match(rnotwhite) || [];\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // store className if set\n            jQuery._data(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed \"false\",\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          jQuery.attr(this, \"class\", className || value === false ? \"\" : jQuery._data(this, \"__className__\") || \"\");\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + getClass(elem) + \" \").replace(rclass, \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n  jQuery.fn.extend({\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  var location = window.location;\n  var nonce = jQuery.now();\n  var rquery = /\\?/;\n  var rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\n  jQuery.parseJSON = function (data) {\n    // Attempt to parse using the native JSON parser first\n    if (window.JSON && window.JSON.parse) {\n      // Support: Android 2.3\n      // Workaround failure to string-cast null input\n      return window.JSON.parse(data + \"\");\n    }\n\n    var requireNonComma,\n        depth = null,\n        str = jQuery.trim(data + \"\"); // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n    // after removing valid tokens\n\n    return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {\n      // Force termination if we see a misplaced comma\n      if (requireNonComma && comma) {\n        depth = 0;\n      } // Perform no more replacements after returning to outermost depth\n\n\n      if (depth === 0) {\n        return token;\n      } // Commas must not follow \"[\", \"{\", or \",\"\n\n\n      requireNonComma = open || comma; // Determine new depth\n      // array/object open (\"[\" or \"{\"): depth += true - false (increment)\n      // array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n      // other cases (\",\" or primitive): depth += true - true (numeric cast)\n\n      depth += !close - !open; // Remove this token\n\n      return \"\";\n    })) ? Function(\"return \" + str)() : jQuery.error(\"Invalid JSON: \" + data);\n  }; // Cross-browser xml parsing\n\n\n  jQuery.parseXML = function (data) {\n    var xml, tmp;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    }\n\n    try {\n      if (window.DOMParser) {\n        // Standard\n        tmp = new window.DOMParser();\n        xml = tmp.parseFromString(data, \"text/xml\");\n      } else {\n        // IE\n        xml = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n        xml.async = \"false\";\n        xml.loadXML(data);\n      }\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rhash = /#.*$/,\n      rts = /([?&])_=[^&]*/,\n      // IE leaves an \\r character at EOL\n  rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n      rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Document location\n  ajaxLocation = location.href,\n      // Segment location into parts\n  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\n\n      if (jQuery.isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType.charAt(0) === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var deep,\n        key,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var firstDataType,\n        ct,\n        finalDataType,\n        type,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              // jscs:ignore requireDotNotation\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: ajaxLocation,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(ajaxLocParts[1]),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": jQuery.parseJSON,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var // Cross-domain detection vars\n      parts,\n          // Loop variable\n      i,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers as string\n      responseHeadersString,\n          // timeout handle\n      timeoutTimer,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          transport,\n          // Response headers\n      responseHeaders,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // The jqXHR state\n      state = 0,\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (state === 2) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase()] = match[2];\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase()];\n          }\n\n          return match == null ? null : match;\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return state === 2 ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          var lname = name.toLowerCase();\n\n          if (!state) {\n            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (!state) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (state < 2) {\n              for (code in map) {\n                // Lazy-add the new callback in a way that preserves old ones\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            } else {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR).complete = completeDeferred.add;\n      jqXHR.success = jqXHR.done;\n      jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)\n      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"]; // A cross-domain request is in order when we have a protocol:host:port mismatch\n\n      if (s.crossDomain == null) {\n        parts = rurl.exec(s.url.toLowerCase());\n        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (state === 2) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n\n      cacheURL = s.url; // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // If data is available, append data to url\n        if (s.data) {\n          cacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add anti-cache in url if needed\n\n\n        if (s.cache === false) {\n          s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value\n          cacheURL.replace(rts, \"$1_=\" + nonce++) : // Otherwise add one to the end\n          cacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\n        }\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      for (i in {\n        success: 1,\n        error: 1,\n        complete: 1\n      }) {\n        jqXHR[i](s[i]);\n      } // Get transport\n\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (state === 2) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          state = 1;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Propagate exception as error if not done\n          if (state < 2) {\n            done(-1, e); // Simply rethrow otherwise\n          } else {\n            throw e;\n          }\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Called once\n\n        if (state === 2) {\n          return;\n        } // State is \"done\" now\n\n\n        state = 2; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // We extract error from statusText\n          // then normalize statusText and status for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // shift arguments if data argument was omitted\n      if (jQuery.isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n\n  jQuery._evalUrl = function (url) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      \"throws\": true\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapAll(html.call(this, i));\n        });\n      }\n\n      if (this[0]) {\n        // The elements to wrap the target around\n        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstChild && elem.firstChild.nodeType === 1) {\n            elem = elem.firstChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var isFunction = jQuery.isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap() {\n      return this.parent().each(function () {\n        if (!jQuery.nodeName(this, \"body\")) {\n          jQuery(this).replaceWith(this.childNodes);\n        }\n      }).end();\n    }\n  });\n\n  function getDisplay(elem) {\n    return elem.style && elem.style.display || jQuery.css(elem, \"display\");\n  }\n\n  function filterHidden(elem) {\n    while (elem && elem.nodeType === 1) {\n      if (getDisplay(elem) === \"none\" || elem.type === \"hidden\") {\n        return true;\n      }\n\n      elem = elem.parentNode;\n    }\n\n    return false;\n  }\n\n  jQuery.expr.filters.hidden = function (elem) {\n    // Support: Opera <= 12.12\n    // Opera reports offsetWidths and offsetHeights less than zero on some elements\n    return support.reliableHiddenOffsets() ? elem.offsetWidth <= 0 && elem.offsetHeight <= 0 && !elem.getClientRects().length : filterHidden(elem);\n  };\n\n  jQuery.expr.filters.visible = function (elem) {\n    return !jQuery.expr.filters.hidden(elem);\n  };\n\n  var r20 = /%20/g,\n      rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (jQuery.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && jQuery.type(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, value) {\n      // If value is a function, invoke it and return its value\n      value = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n    }; // Set traditional to true for jQuery <= 1.3.2 behavior.\n\n\n    if (traditional === undefined) {\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\").replace(r20, \"+\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is(\":disabled\") so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n          return {\n            name: elem.name,\n            value: val.replace(rCRLF, \"\\r\\n\")\n          };\n        }) : {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  }); // Create the request object\n  // (This is still attached to ajaxSettings for backward compatibility)\n\n  jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? // Support: IE6-IE8\n  function () {\n    // XHR cannot access local files, always use ActiveX for that case\n    if (this.isLocal) {\n      return createActiveXHR();\n    } // Support: IE 9-11\n    // IE seems to error on cross-domain PATCH requests when ActiveX XHR\n    // is used. In IE 9+ always use the native XHR.\n    // Note: this condition won't catch Edge as it doesn't define\n    // document.documentMode but it also doesn't support ActiveX so it won't\n    // reach this code.\n\n\n    if (document.documentMode > 8) {\n      return createStandardXHR();\n    } // Support: IE<9\n    // oldIE XHR does not support non-RFC2616 methods (#13240)\n    // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n    // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n    // Although this check for six methods instead of eight\n    // since IE also does not support \"trace\" and \"connect\"\n\n\n    return /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();\n  } : // For all other browsers, use the standard XMLHttpRequest object\n  createStandardXHR;\n  var xhrId = 0,\n      xhrCallbacks = {},\n      xhrSupported = jQuery.ajaxSettings.xhr(); // Support: IE<10\n  // Open requests must be manually aborted on unload (#5280)\n  // See https://support.microsoft.com/kb/2856746 for more info\n\n  if (window.attachEvent) {\n    window.attachEvent(\"onunload\", function () {\n      for (var key in xhrCallbacks) {\n        xhrCallbacks[key](undefined, true);\n      }\n    });\n  } // Determine support properties\n\n\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  xhrSupported = support.ajax = !!xhrSupported; // Create transport if the browser can provide an xhr\n\n  if (xhrSupported) {\n    jQuery.ajaxTransport(function (options) {\n      // Cross domain only allowed if supported through XMLHttpRequest\n      if (!options.crossDomain || support.cors) {\n        var _callback;\n\n        return {\n          send: function send(headers, complete) {\n            var i,\n                xhr = options.xhr(),\n                id = ++xhrId; // Open the socket\n\n            xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n            if (options.xhrFields) {\n              for (i in options.xhrFields) {\n                xhr[i] = options.xhrFields[i];\n              }\n            } // Override mime type if needed\n\n\n            if (options.mimeType && xhr.overrideMimeType) {\n              xhr.overrideMimeType(options.mimeType);\n            } // X-Requested-With header\n            // For cross-domain requests, seeing as conditions for a preflight are\n            // akin to a jigsaw puzzle, we simply never set it to be sure.\n            // (it can always be set on a per-request basis or even using ajaxSetup)\n            // For same-domain requests, won't change header if already provided.\n\n\n            if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n              headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n            } // Set headers\n\n\n            for (i in headers) {\n              // Support: IE<9\n              // IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n              // request header to a null-value.\n              //\n              // To keep consistent with other XHR implementations, cast the value\n              // to string and ignore `undefined`.\n              if (headers[i] !== undefined) {\n                xhr.setRequestHeader(i, headers[i] + \"\");\n              }\n            } // Do send the request\n            // This may raise an exception which is actually\n            // handled in jQuery.ajax (so no try/catch here)\n\n\n            xhr.send(options.hasContent && options.data || null); // Listener\n\n            _callback = function callback(_, isAbort) {\n              var status, statusText, responses; // Was never called and is aborted or complete\n\n              if (_callback && (isAbort || xhr.readyState === 4)) {\n                // Clean up\n                delete xhrCallbacks[id];\n                _callback = undefined;\n                xhr.onreadystatechange = jQuery.noop; // Abort manually if needed\n\n                if (isAbort) {\n                  if (xhr.readyState !== 4) {\n                    xhr.abort();\n                  }\n                } else {\n                  responses = {};\n                  status = xhr.status; // Support: IE<10\n                  // Accessing binary-data responseText throws an exception\n                  // (#11426)\n\n                  if (typeof xhr.responseText === \"string\") {\n                    responses.text = xhr.responseText;\n                  } // Firefox throws an exception when accessing\n                  // statusText for faulty cross-domain requests\n\n\n                  try {\n                    statusText = xhr.statusText;\n                  } catch (e) {\n                    // We normalize with Webkit giving an empty statusText\n                    statusText = \"\";\n                  } // Filter status for non standard behaviors\n                  // If the request is local and we have data: assume a success\n                  // (success with no data won't get notified, that's the best we\n                  // can do given current implementations)\n\n\n                  if (!status && options.isLocal && !options.crossDomain) {\n                    status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204\n                  } else if (status === 1223) {\n                    status = 204;\n                  }\n                }\n              } // Call complete if needed\n\n\n              if (responses) {\n                complete(status, statusText, responses, xhr.getAllResponseHeaders());\n              }\n            }; // Do send the request\n            // `xhr.send` may raise an exception, but it will be\n            // handled in jQuery.ajax (so no try/catch here)\n\n\n            if (!options.async) {\n              // If we're in sync mode we fire the callback\n              _callback();\n            } else if (xhr.readyState === 4) {\n              // (IE6 & IE7) if it's in cache and has been\n              // retrieved directly we need to fire the callback\n              window.setTimeout(_callback);\n            } else {\n              // Register the callback, but delay it in case `xhr.send` throws\n              // Add to the list of active xhr callbacks\n              xhr.onreadystatechange = xhrCallbacks[id] = _callback;\n            }\n          },\n          abort: function abort() {\n            if (_callback) {\n              _callback(undefined, true);\n            }\n          }\n        };\n      }\n    });\n  } // Functions to create xhrs\n\n\n  function createStandardXHR() {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  }\n\n  function createActiveXHR() {\n    try {\n      return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch (e) {}\n  } // Install script dataType\n\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and global\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n      s.global = false;\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script,\n          head = document.head || jQuery(\"head\")[0] || document.documentElement;\n      return {\n        send: function send(_, callback) {\n          script = document.createElement(\"script\");\n          script.async = true;\n\n          if (s.scriptCharset) {\n            script.charset = s.scriptCharset;\n          }\n\n          script.src = s.url; // Attach handlers for all browsers\n\n          script.onload = script.onreadystatechange = function (_, isAbort) {\n            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n              // Handle memory leak in IE\n              script.onload = script.onreadystatechange = null; // Remove the script\n\n              if (script.parentNode) {\n                script.parentNode.removeChild(script);\n              } // Dereference the script\n\n\n              script = null; // Callback if not abort\n\n              if (!isAbort) {\n                callback(200, \"success\");\n              }\n            }\n          }; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n\n          head.insertBefore(script, head.firstChild);\n        },\n        abort: function abort() {\n          if (script) {\n            script.onload(undefined, true);\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && jQuery.isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // data: string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (!data || typeof data !== \"string\") {\n      return null;\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    context = context || document;\n    var parsed = rsingleTag.exec(data),\n        scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  }; // Keep a copy of the old load method\n\n\n  var _load = jQuery.fn.load;\n  /**\n   * Load a url into a page\n   */\n\n  jQuery.fn.load = function (url, params, callback) {\n    if (typeof url !== \"string\" && _load) {\n      return _load.apply(this, arguments);\n    }\n\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = jQuery.trim(url.slice(off, url.length));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (jQuery.isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n\n  jQuery.expr.filters.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n  /**\n   * Gets a window from an element\n   */\n\n\n  function getWindow(elem) {\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\n  }\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1; // need to be able to calculate position if either top or left\n      // is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (jQuery.isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    offset: function offset(options) {\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var docElem,\n          win,\n          box = {\n        top: 0,\n        left: 0\n      },\n          elem = this[0],\n          doc = elem && elem.ownerDocument;\n\n      if (!doc) {\n        return;\n      }\n\n      docElem = doc.documentElement; // Make sure it's not a disconnected DOM node\n\n      if (!jQuery.contains(docElem, elem)) {\n        return box;\n      } // If we don't have gBCR, just use 0,0 rather than error\n      // BlackBerry 5, iOS 3 (original iPhone)\n\n\n      if (typeof elem.getBoundingClientRect !== \"undefined\") {\n        box = elem.getBoundingClientRect();\n      }\n\n      win = getWindow(doc);\n      return {\n        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n      };\n    },\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          parentOffset = {\n        top: 0,\n        left: 0\n      },\n          elem = this[0]; // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n      // because it is its only offset parent\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // we assume that getBoundingClientRect is available when computed position is fixed\n        offset = elem.getBoundingClientRect();\n      } else {\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(); // Get correct offsets\n\n        offset = this.offset();\n\n        if (!jQuery.nodeName(offsetParent[0], \"html\")) {\n          parentOffset = offsetParent.offset();\n        } // Add offsetParent borders\n\n\n        parentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n        parentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n      } // Subtract parent offsets and element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = /Y/.test(prop);\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        var win = getWindow(elem);\n\n        if (val === undefined) {\n          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length, null);\n    };\n  }); // Support: Safari<7-8+, Chrome<37-44+\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // getComputedStyle returns percent when specified for top/left/bottom/right\n  // rather than make the css module depend on the offset module, we just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // if curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (jQuery.isWindow(elem)) {\n            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n            // isn't a whole lot we can do. See pull request at this URL for discussion:\n            // https://github.com/jquery/jquery/pull/764\n            return elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n            // unfortunately, this causes bug #3838 in IE6/8 only,\n            // but there is currently no good, small way to fix it.\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable, null);\n      };\n    });\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    }\n  }); // The number of elements contained in the matched element set\n\n  jQuery.fn.size = function () {\n    return this.length;\n  };\n\n  jQuery.fn.andSelf = jQuery.fn.addBack; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in\n  // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (!noGlobal) {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvanF1ZXJ5LTEuMTIuMy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTRCO0VBRTVCLElBQUssc0JBQU9DLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsUUFBT0EsTUFBTSxDQUFDQyxPQUFkLE1BQTBCLFFBQTdELEVBQXdFO0lBQ3ZFO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0FELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsTUFBTSxDQUFDSSxRQUFQLEdBQ2hCSCxPQUFPLENBQUVELE1BQUYsRUFBVSxJQUFWLENBRFMsR0FFaEIsVUFBVUssQ0FBVixFQUFjO01BQ2IsSUFBSyxDQUFDQSxDQUFDLENBQUNELFFBQVIsRUFBbUI7UUFDbEIsTUFBTSxJQUFJRSxLQUFKLENBQVcsMENBQVgsQ0FBTjtNQUNBOztNQUNELE9BQU9MLE9BQU8sQ0FBRUksQ0FBRixDQUFkO0lBQ0EsQ0FQRjtFQVFBLENBaEJELE1BZ0JPO0lBQ05KLE9BQU8sQ0FBRUQsTUFBRixDQUFQO0VBQ0EsQ0FwQjJCLENBc0I3Qjs7QUFDQyxDQXZCQSxFQXVCQyxPQUFPTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxJQXZCMUMsRUF1QmdELFVBQVVBLE1BQVYsRUFBa0JDLFFBQWxCLEVBQTZCO0VBRTlFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJQyxVQUFVLEdBQUcsRUFBakI7RUFFQSxJQUFJTCxRQUFRLEdBQUdHLE1BQU0sQ0FBQ0gsUUFBdEI7RUFFQSxJQUFJTSxNQUFLLEdBQUdELFVBQVUsQ0FBQ0MsS0FBdkI7RUFFQSxJQUFJQyxNQUFNLEdBQUdGLFVBQVUsQ0FBQ0UsTUFBeEI7RUFFQSxJQUFJQyxJQUFJLEdBQUdILFVBQVUsQ0FBQ0csSUFBdEI7RUFFQSxJQUFJQyxPQUFPLEdBQUdKLFVBQVUsQ0FBQ0ksT0FBekI7RUFFQSxJQUFJQyxVQUFVLEdBQUcsRUFBakI7RUFFQSxJQUFJQyxRQUFRLEdBQUdELFVBQVUsQ0FBQ0MsUUFBMUI7RUFFQSxJQUFJQyxNQUFNLEdBQUdGLFVBQVUsQ0FBQ0csY0FBeEI7RUFFQSxJQUFJQyxPQUFPLEdBQUcsRUFBZDs7RUFJQSxJQUNDQyxPQUFPLEdBQUcsUUFEWDtFQUFBLElBR0M7RUFDQUMsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBVUMsUUFBVixFQUFvQkMsT0FBcEIsRUFBOEI7SUFFdEM7SUFDQTtJQUNBLE9BQU8sSUFBSUYsTUFBTSxDQUFDRyxFQUFQLENBQVVDLElBQWQsQ0FBb0JILFFBQXBCLEVBQThCQyxPQUE5QixDQUFQO0VBQ0EsQ0FURjtFQUFBLElBV0M7RUFDQTtFQUNBRyxLQUFLLEdBQUcsb0NBYlQ7RUFBQSxJQWVDO0VBQ0FDLFNBQVMsR0FBRyxPQWhCYjtFQUFBLElBaUJDQyxVQUFVLEdBQUcsY0FqQmQ7RUFBQSxJQW1CQztFQUNBQyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFVQyxHQUFWLEVBQWVDLE1BQWYsRUFBd0I7SUFDcEMsT0FBT0EsTUFBTSxDQUFDQyxXQUFQLEVBQVA7RUFDQSxDQXRCRjs7RUF3QkFYLE1BQU0sQ0FBQ0csRUFBUCxHQUFZSCxNQUFNLENBQUNZLFNBQVAsR0FBbUI7SUFFOUI7SUFDQUMsTUFBTSxFQUFFZCxPQUhzQjtJQUs5QmUsV0FBVyxFQUFFZCxNQUxpQjtJQU85QjtJQUNBQyxRQUFRLEVBQUUsRUFSb0I7SUFVOUI7SUFDQWMsTUFBTSxFQUFFLENBWHNCO0lBYTlCQyxPQUFPLEVBQUUsbUJBQVc7TUFDbkIsT0FBTzFCLE1BQUssQ0FBQzJCLElBQU4sQ0FBWSxJQUFaLENBQVA7SUFDQSxDQWY2QjtJQWlCOUI7SUFDQTtJQUNBQyxHQUFHLEVBQUUsYUFBVUMsR0FBVixFQUFnQjtNQUNwQixPQUFPQSxHQUFHLElBQUksSUFBUCxHQUVOO01BQ0VBLEdBQUcsR0FBRyxDQUFOLEdBQVUsS0FBTUEsR0FBRyxHQUFHLEtBQUtKLE1BQWpCLENBQVYsR0FBc0MsS0FBTUksR0FBTixDQUhsQyxHQUtOO01BQ0E3QixNQUFLLENBQUMyQixJQUFOLENBQVksSUFBWixDQU5EO0lBT0EsQ0EzQjZCO0lBNkI5QjtJQUNBO0lBQ0FHLFNBQVMsRUFBRSxtQkFBVUMsS0FBVixFQUFrQjtNQUU1QjtNQUNBLElBQUlDLEdBQUcsR0FBR3RCLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBYyxLQUFLVCxXQUFMLEVBQWQsRUFBa0NPLEtBQWxDLENBQVYsQ0FINEIsQ0FLNUI7O01BQ0FDLEdBQUcsQ0FBQ0UsVUFBSixHQUFpQixJQUFqQjtNQUNBRixHQUFHLENBQUNwQixPQUFKLEdBQWMsS0FBS0EsT0FBbkIsQ0FQNEIsQ0FTNUI7O01BQ0EsT0FBT29CLEdBQVA7SUFDQSxDQTFDNkI7SUE0QzlCO0lBQ0FHLElBQUksRUFBRSxjQUFVQyxRQUFWLEVBQXFCO01BQzFCLE9BQU8xQixNQUFNLENBQUN5QixJQUFQLENBQWEsSUFBYixFQUFtQkMsUUFBbkIsQ0FBUDtJQUNBLENBL0M2QjtJQWlEOUJDLEdBQUcsRUFBRSxhQUFVRCxRQUFWLEVBQXFCO01BQ3pCLE9BQU8sS0FBS04sU0FBTCxDQUFnQnBCLE1BQU0sQ0FBQzJCLEdBQVAsQ0FBWSxJQUFaLEVBQWtCLFVBQVVDLElBQVYsRUFBZ0JDLENBQWhCLEVBQW9CO1FBQzVELE9BQU9ILFFBQVEsQ0FBQ1QsSUFBVCxDQUFlVyxJQUFmLEVBQXFCQyxDQUFyQixFQUF3QkQsSUFBeEIsQ0FBUDtNQUNBLENBRnNCLENBQWhCLENBQVA7SUFHQSxDQXJENkI7SUF1RDlCdEMsS0FBSyxFQUFFLGlCQUFXO01BQ2pCLE9BQU8sS0FBSzhCLFNBQUwsQ0FBZ0I5QixNQUFLLENBQUN3QyxLQUFOLENBQWEsSUFBYixFQUFtQkMsU0FBbkIsQ0FBaEIsQ0FBUDtJQUNBLENBekQ2QjtJQTJEOUJDLEtBQUssRUFBRSxpQkFBVztNQUNqQixPQUFPLEtBQUtDLEVBQUwsQ0FBUyxDQUFULENBQVA7SUFDQSxDQTdENkI7SUErRDlCQyxJQUFJLEVBQUUsZ0JBQVc7TUFDaEIsT0FBTyxLQUFLRCxFQUFMLENBQVMsQ0FBQyxDQUFWLENBQVA7SUFDQSxDQWpFNkI7SUFtRTlCQSxFQUFFLEVBQUUsWUFBVUosQ0FBVixFQUFjO01BQ2pCLElBQUlNLEdBQUcsR0FBRyxLQUFLcEIsTUFBZjtNQUFBLElBQ0NxQixDQUFDLEdBQUcsQ0FBQ1AsQ0FBRCxJQUFPQSxDQUFDLEdBQUcsQ0FBSixHQUFRTSxHQUFSLEdBQWMsQ0FBckIsQ0FETDtNQUVBLE9BQU8sS0FBS2YsU0FBTCxDQUFnQmdCLENBQUMsSUFBSSxDQUFMLElBQVVBLENBQUMsR0FBR0QsR0FBZCxHQUFvQixDQUFFLEtBQU1DLENBQU4sQ0FBRixDQUFwQixHQUFvQyxFQUFwRCxDQUFQO0lBQ0EsQ0F2RTZCO0lBeUU5QkMsR0FBRyxFQUFFLGVBQVc7TUFDZixPQUFPLEtBQUtiLFVBQUwsSUFBbUIsS0FBS1YsV0FBTCxFQUExQjtJQUNBLENBM0U2QjtJQTZFOUI7SUFDQTtJQUNBdEIsSUFBSSxFQUFFQSxJQS9Fd0I7SUFnRjlCOEMsSUFBSSxFQUFFakQsVUFBVSxDQUFDaUQsSUFoRmE7SUFpRjlCQyxNQUFNLEVBQUVsRCxVQUFVLENBQUNrRDtFQWpGVyxDQUEvQjs7RUFvRkF2QyxNQUFNLENBQUN3QyxNQUFQLEdBQWdCeEMsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLEdBQW1CLFlBQVc7SUFDN0MsSUFBSUMsR0FBSjtJQUFBLElBQVNDLFdBQVQ7SUFBQSxJQUFzQkMsSUFBdEI7SUFBQSxJQUE0QkMsSUFBNUI7SUFBQSxJQUFrQ0MsT0FBbEM7SUFBQSxJQUEyQ0MsS0FBM0M7SUFBQSxJQUNDQyxNQUFNLEdBQUdoQixTQUFTLENBQUUsQ0FBRixDQUFULElBQWtCLEVBRDVCO0lBQUEsSUFFQ0YsQ0FBQyxHQUFHLENBRkw7SUFBQSxJQUdDZCxNQUFNLEdBQUdnQixTQUFTLENBQUNoQixNQUhwQjtJQUFBLElBSUNpQyxJQUFJLEdBQUcsS0FKUixDQUQ2QyxDQU83Qzs7SUFDQSxJQUFLLE9BQU9ELE1BQVAsS0FBa0IsU0FBdkIsRUFBbUM7TUFDbENDLElBQUksR0FBR0QsTUFBUCxDQURrQyxDQUdsQzs7TUFDQUEsTUFBTSxHQUFHaEIsU0FBUyxDQUFFRixDQUFGLENBQVQsSUFBa0IsRUFBM0I7TUFDQUEsQ0FBQztJQUNELENBZDRDLENBZ0I3Qzs7O0lBQ0EsSUFBSyxRQUFPa0IsTUFBUCxNQUFrQixRQUFsQixJQUE4QixDQUFDL0MsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQkYsTUFBbkIsQ0FBcEMsRUFBa0U7TUFDakVBLE1BQU0sR0FBRyxFQUFUO0lBQ0EsQ0FuQjRDLENBcUI3Qzs7O0lBQ0EsSUFBS2xCLENBQUMsS0FBS2QsTUFBWCxFQUFvQjtNQUNuQmdDLE1BQU0sR0FBRyxJQUFUO01BQ0FsQixDQUFDO0lBQ0Q7O0lBRUQsT0FBUUEsQ0FBQyxHQUFHZCxNQUFaLEVBQW9CYyxDQUFDLEVBQXJCLEVBQTBCO01BRXpCO01BQ0EsSUFBSyxDQUFFZ0IsT0FBTyxHQUFHZCxTQUFTLENBQUVGLENBQUYsQ0FBckIsS0FBZ0MsSUFBckMsRUFBNEM7UUFFM0M7UUFDQSxLQUFNZSxJQUFOLElBQWNDLE9BQWQsRUFBd0I7VUFDdkJKLEdBQUcsR0FBR00sTUFBTSxDQUFFSCxJQUFGLENBQVo7VUFDQUQsSUFBSSxHQUFHRSxPQUFPLENBQUVELElBQUYsQ0FBZCxDQUZ1QixDQUl2Qjs7VUFDQSxJQUFLRyxNQUFNLEtBQUtKLElBQWhCLEVBQXVCO1lBQ3RCO1VBQ0EsQ0FQc0IsQ0FTdkI7OztVQUNBLElBQUtLLElBQUksSUFBSUwsSUFBUixLQUFrQjNDLE1BQU0sQ0FBQ2tELGFBQVAsQ0FBc0JQLElBQXRCLE1BQ3BCRCxXQUFXLEdBQUcxQyxNQUFNLENBQUNtRCxPQUFQLENBQWdCUixJQUFoQixDQURNLENBQWxCLENBQUwsRUFDOEM7WUFFN0MsSUFBS0QsV0FBTCxFQUFtQjtjQUNsQkEsV0FBVyxHQUFHLEtBQWQ7Y0FDQUksS0FBSyxHQUFHTCxHQUFHLElBQUl6QyxNQUFNLENBQUNtRCxPQUFQLENBQWdCVixHQUFoQixDQUFQLEdBQStCQSxHQUEvQixHQUFxQyxFQUE3QztZQUVBLENBSkQsTUFJTztjQUNOSyxLQUFLLEdBQUdMLEdBQUcsSUFBSXpDLE1BQU0sQ0FBQ2tELGFBQVAsQ0FBc0JULEdBQXRCLENBQVAsR0FBcUNBLEdBQXJDLEdBQTJDLEVBQW5EO1lBQ0EsQ0FSNEMsQ0FVN0M7OztZQUNBTSxNQUFNLENBQUVILElBQUYsQ0FBTixHQUFpQjVDLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZVEsSUFBZixFQUFxQkYsS0FBckIsRUFBNEJILElBQTVCLENBQWpCLENBWDZDLENBYTlDO1VBQ0MsQ0FmRCxNQWVPLElBQUtBLElBQUksS0FBS1MsU0FBZCxFQUEwQjtZQUNoQ0wsTUFBTSxDQUFFSCxJQUFGLENBQU4sR0FBaUJELElBQWpCO1VBQ0E7UUFDRDtNQUNEO0lBQ0QsQ0EvRDRDLENBaUU3Qzs7O0lBQ0EsT0FBT0ksTUFBUDtFQUNBLENBbkVEOztFQXFFQS9DLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZTtJQUVkO0lBQ0FhLE9BQU8sRUFBRSxXQUFXLENBQUV0RCxPQUFPLEdBQUd1RCxJQUFJLENBQUNDLE1BQUwsRUFBWixFQUE0QkMsT0FBNUIsQ0FBcUMsS0FBckMsRUFBNEMsRUFBNUMsQ0FITjtJQUtkO0lBQ0FDLE9BQU8sRUFBRSxJQU5LO0lBUWRDLEtBQUssRUFBRSxlQUFVQyxHQUFWLEVBQWdCO01BQ3RCLE1BQU0sSUFBSXpFLEtBQUosQ0FBV3lFLEdBQVgsQ0FBTjtJQUNBLENBVmE7SUFZZEMsSUFBSSxFQUFFLGdCQUFXLENBQUUsQ0FaTDtJQWNkO0lBQ0E7SUFDQTtJQUNBWCxVQUFVLEVBQUUsb0JBQVVZLEdBQVYsRUFBZ0I7TUFDM0IsT0FBTzdELE1BQU0sQ0FBQzhELElBQVAsQ0FBYUQsR0FBYixNQUF1QixVQUE5QjtJQUNBLENBbkJhO0lBcUJkVixPQUFPLEVBQUVZLEtBQUssQ0FBQ1osT0FBTixJQUFpQixVQUFVVSxHQUFWLEVBQWdCO01BQ3pDLE9BQU83RCxNQUFNLENBQUM4RCxJQUFQLENBQWFELEdBQWIsTUFBdUIsT0FBOUI7SUFDQSxDQXZCYTtJQXlCZEcsUUFBUSxFQUFFLGtCQUFVSCxHQUFWLEVBQWdCO01BQ3pCO01BQ0EsT0FBT0EsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxJQUFJQSxHQUFHLENBQUMxRSxNQUFqQztJQUNBLENBNUJhO0lBOEJkOEUsU0FBUyxFQUFFLG1CQUFVSixHQUFWLEVBQWdCO01BRTFCO01BQ0E7TUFDQTtNQUNBO01BQ0EsSUFBSUssYUFBYSxHQUFHTCxHQUFHLElBQUlBLEdBQUcsQ0FBQ2xFLFFBQUosRUFBM0I7TUFDQSxPQUFPLENBQUNLLE1BQU0sQ0FBQ21ELE9BQVAsQ0FBZ0JVLEdBQWhCLENBQUQsSUFBNEJLLGFBQWEsR0FBR0MsVUFBVSxDQUFFRCxhQUFGLENBQTFCLEdBQThDLENBQWhELElBQXVELENBQXhGO0lBQ0EsQ0F0Q2E7SUF3Q2RFLGFBQWEsRUFBRSx1QkFBVVAsR0FBVixFQUFnQjtNQUM5QixJQUFJakIsSUFBSjs7TUFDQSxLQUFNQSxJQUFOLElBQWNpQixHQUFkLEVBQW9CO1FBQ25CLE9BQU8sS0FBUDtNQUNBOztNQUNELE9BQU8sSUFBUDtJQUNBLENBOUNhO0lBZ0RkWCxhQUFhLEVBQUUsdUJBQVVXLEdBQVYsRUFBZ0I7TUFDOUIsSUFBSVEsR0FBSixDQUQ4QixDQUc5QjtNQUNBO01BQ0E7O01BQ0EsSUFBSyxDQUFDUixHQUFELElBQVE3RCxNQUFNLENBQUM4RCxJQUFQLENBQWFELEdBQWIsTUFBdUIsUUFBL0IsSUFBMkNBLEdBQUcsQ0FBQ1MsUUFBL0MsSUFBMkR0RSxNQUFNLENBQUNnRSxRQUFQLENBQWlCSCxHQUFqQixDQUFoRSxFQUF5RjtRQUN4RixPQUFPLEtBQVA7TUFDQTs7TUFFRCxJQUFJO1FBRUg7UUFDQSxJQUFLQSxHQUFHLENBQUMvQyxXQUFKLElBQ0osQ0FBQ2xCLE1BQU0sQ0FBQ3FCLElBQVAsQ0FBYTRDLEdBQWIsRUFBa0IsYUFBbEIsQ0FERyxJQUVKLENBQUNqRSxNQUFNLENBQUNxQixJQUFQLENBQWE0QyxHQUFHLENBQUMvQyxXQUFKLENBQWdCRixTQUE3QixFQUF3QyxlQUF4QyxDQUZGLEVBRThEO1VBQzdELE9BQU8sS0FBUDtRQUNBO01BQ0QsQ0FSRCxDQVFFLE9BQVEyRCxDQUFSLEVBQVk7UUFFYjtRQUNBLE9BQU8sS0FBUDtNQUNBLENBdEI2QixDQXdCOUI7TUFDQTs7O01BQ0EsSUFBSyxDQUFDekUsT0FBTyxDQUFDMEUsUUFBZCxFQUF5QjtRQUN4QixLQUFNSCxHQUFOLElBQWFSLEdBQWIsRUFBbUI7VUFDbEIsT0FBT2pFLE1BQU0sQ0FBQ3FCLElBQVAsQ0FBYTRDLEdBQWIsRUFBa0JRLEdBQWxCLENBQVA7UUFDQTtNQUNELENBOUI2QixDQWdDOUI7TUFDQTs7O01BQ0EsS0FBTUEsR0FBTixJQUFhUixHQUFiLEVBQW1CLENBQUU7O01BRXJCLE9BQU9RLEdBQUcsS0FBS2pCLFNBQVIsSUFBcUJ4RCxNQUFNLENBQUNxQixJQUFQLENBQWE0QyxHQUFiLEVBQWtCUSxHQUFsQixDQUE1QjtJQUNBLENBckZhO0lBdUZkUCxJQUFJLEVBQUUsY0FBVUQsR0FBVixFQUFnQjtNQUNyQixJQUFLQSxHQUFHLElBQUksSUFBWixFQUFtQjtRQUNsQixPQUFPQSxHQUFHLEdBQUcsRUFBYjtNQUNBOztNQUNELE9BQU8sUUFBT0EsR0FBUCxNQUFlLFFBQWYsSUFBMkIsT0FBT0EsR0FBUCxLQUFlLFVBQTFDLEdBQ05uRSxVQUFVLENBQUVDLFFBQVEsQ0FBQ3NCLElBQVQsQ0FBZTRDLEdBQWYsQ0FBRixDQUFWLElBQXNDLFFBRGhDLFdBRUNBLEdBRkQsQ0FBUDtJQUdBLENBOUZhO0lBZ0dkO0lBQ0E7SUFDQVksVUFBVSxFQUFFLG9CQUFVQyxJQUFWLEVBQWlCO01BQzVCLElBQUtBLElBQUksSUFBSTFFLE1BQU0sQ0FBQzJFLElBQVAsQ0FBYUQsSUFBYixDQUFiLEVBQW1DO1FBRWxDO1FBQ0E7UUFDQTtRQUNBLENBQUV2RixNQUFNLENBQUN5RixVQUFQLElBQXFCLFVBQVVGLElBQVYsRUFBaUI7VUFDdkN2RixNQUFNLENBQUUsTUFBRixDQUFOLENBQWlCOEIsSUFBakIsQ0FBdUI5QixNQUF2QixFQUErQnVGLElBQS9CLEVBRHVDLENBQ0E7UUFDdkMsQ0FGRCxFQUVLQSxJQUZMO01BR0E7SUFDRCxDQTVHYTtJQThHZDtJQUNBO0lBQ0FHLFNBQVMsRUFBRSxtQkFBVUMsTUFBVixFQUFtQjtNQUM3QixPQUFPQSxNQUFNLENBQUN0QixPQUFQLENBQWdCbEQsU0FBaEIsRUFBMkIsS0FBM0IsRUFBbUNrRCxPQUFuQyxDQUE0Q2pELFVBQTVDLEVBQXdEQyxVQUF4RCxDQUFQO0lBQ0EsQ0FsSGE7SUFvSGR1RSxRQUFRLEVBQUUsa0JBQVVuRCxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBdUI7TUFDaEMsT0FBT2hCLElBQUksQ0FBQ21ELFFBQUwsSUFBaUJuRCxJQUFJLENBQUNtRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0NwQyxJQUFJLENBQUNvQyxXQUFMLEVBQXhEO0lBQ0EsQ0F0SGE7SUF3SGR2RCxJQUFJLEVBQUUsY0FBVW9DLEdBQVYsRUFBZW5DLFFBQWYsRUFBMEI7TUFDL0IsSUFBSVgsTUFBSjtNQUFBLElBQVljLENBQUMsR0FBRyxDQUFoQjs7TUFFQSxJQUFLb0QsV0FBVyxDQUFFcEIsR0FBRixDQUFoQixFQUEwQjtRQUN6QjlDLE1BQU0sR0FBRzhDLEdBQUcsQ0FBQzlDLE1BQWI7O1FBQ0EsT0FBUWMsQ0FBQyxHQUFHZCxNQUFaLEVBQW9CYyxDQUFDLEVBQXJCLEVBQTBCO1VBQ3pCLElBQUtILFFBQVEsQ0FBQ1QsSUFBVCxDQUFlNEMsR0FBRyxDQUFFaEMsQ0FBRixDQUFsQixFQUF5QkEsQ0FBekIsRUFBNEJnQyxHQUFHLENBQUVoQyxDQUFGLENBQS9CLE1BQTJDLEtBQWhELEVBQXdEO1lBQ3ZEO1VBQ0E7UUFDRDtNQUNELENBUEQsTUFPTztRQUNOLEtBQU1BLENBQU4sSUFBV2dDLEdBQVgsRUFBaUI7VUFDaEIsSUFBS25DLFFBQVEsQ0FBQ1QsSUFBVCxDQUFlNEMsR0FBRyxDQUFFaEMsQ0FBRixDQUFsQixFQUF5QkEsQ0FBekIsRUFBNEJnQyxHQUFHLENBQUVoQyxDQUFGLENBQS9CLE1BQTJDLEtBQWhELEVBQXdEO1lBQ3ZEO1VBQ0E7UUFDRDtNQUNEOztNQUVELE9BQU9nQyxHQUFQO0lBQ0EsQ0EzSWE7SUE2SWQ7SUFDQWMsSUFBSSxFQUFFLGNBQVVPLElBQVYsRUFBaUI7TUFDdEIsT0FBT0EsSUFBSSxJQUFJLElBQVIsR0FDTixFQURNLEdBRU4sQ0FBRUEsSUFBSSxHQUFHLEVBQVQsRUFBYzFCLE9BQWQsQ0FBdUJuRCxLQUF2QixFQUE4QixFQUE5QixDQUZEO0lBR0EsQ0FsSmE7SUFvSmQ7SUFDQThFLFNBQVMsRUFBRSxtQkFBVUMsR0FBVixFQUFlQyxPQUFmLEVBQXlCO01BQ25DLElBQUkvRCxHQUFHLEdBQUcrRCxPQUFPLElBQUksRUFBckI7O01BRUEsSUFBS0QsR0FBRyxJQUFJLElBQVosRUFBbUI7UUFDbEIsSUFBS0gsV0FBVyxDQUFFSyxNQUFNLENBQUVGLEdBQUYsQ0FBUixDQUFoQixFQUFvQztVQUNuQ3BGLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBY0QsR0FBZCxFQUNDLE9BQU84RCxHQUFQLEtBQWUsUUFBZixHQUNBLENBQUVBLEdBQUYsQ0FEQSxHQUNVQSxHQUZYO1FBSUEsQ0FMRCxNQUtPO1VBQ041RixJQUFJLENBQUN5QixJQUFMLENBQVdLLEdBQVgsRUFBZ0I4RCxHQUFoQjtRQUNBO01BQ0Q7O01BRUQsT0FBTzlELEdBQVA7SUFDQSxDQXBLYTtJQXNLZGlFLE9BQU8sRUFBRSxpQkFBVTNELElBQVYsRUFBZ0J3RCxHQUFoQixFQUFxQnZELENBQXJCLEVBQXlCO01BQ2pDLElBQUlNLEdBQUo7O01BRUEsSUFBS2lELEdBQUwsRUFBVztRQUNWLElBQUszRixPQUFMLEVBQWU7VUFDZCxPQUFPQSxPQUFPLENBQUN3QixJQUFSLENBQWNtRSxHQUFkLEVBQW1CeEQsSUFBbkIsRUFBeUJDLENBQXpCLENBQVA7UUFDQTs7UUFFRE0sR0FBRyxHQUFHaUQsR0FBRyxDQUFDckUsTUFBVjtRQUNBYyxDQUFDLEdBQUdBLENBQUMsR0FBR0EsQ0FBQyxHQUFHLENBQUosR0FBUXlCLElBQUksQ0FBQ2tDLEdBQUwsQ0FBVSxDQUFWLEVBQWFyRCxHQUFHLEdBQUdOLENBQW5CLENBQVIsR0FBaUNBLENBQXBDLEdBQXdDLENBQTdDOztRQUVBLE9BQVFBLENBQUMsR0FBR00sR0FBWixFQUFpQk4sQ0FBQyxFQUFsQixFQUF1QjtVQUV0QjtVQUNBLElBQUtBLENBQUMsSUFBSXVELEdBQUwsSUFBWUEsR0FBRyxDQUFFdkQsQ0FBRixDQUFILEtBQWFELElBQTlCLEVBQXFDO1lBQ3BDLE9BQU9DLENBQVA7VUFDQTtRQUNEO01BQ0Q7O01BRUQsT0FBTyxDQUFDLENBQVI7SUFDQSxDQTNMYTtJQTZMZE4sS0FBSyxFQUFFLGVBQVVTLEtBQVYsRUFBaUJ5RCxNQUFqQixFQUEwQjtNQUNoQyxJQUFJdEQsR0FBRyxHQUFHLENBQUNzRCxNQUFNLENBQUMxRSxNQUFsQjtNQUFBLElBQ0NxQixDQUFDLEdBQUcsQ0FETDtNQUFBLElBRUNQLENBQUMsR0FBR0csS0FBSyxDQUFDakIsTUFGWDs7TUFJQSxPQUFRcUIsQ0FBQyxHQUFHRCxHQUFaLEVBQWtCO1FBQ2pCSCxLQUFLLENBQUVILENBQUMsRUFBSCxDQUFMLEdBQWU0RCxNQUFNLENBQUVyRCxDQUFDLEVBQUgsQ0FBckI7TUFDQSxDQVArQixDQVNoQztNQUNBOzs7TUFDQSxJQUFLRCxHQUFHLEtBQUtBLEdBQWIsRUFBbUI7UUFDbEIsT0FBUXNELE1BQU0sQ0FBRXJELENBQUYsQ0FBTixLQUFnQmdCLFNBQXhCLEVBQW9DO1VBQ25DcEIsS0FBSyxDQUFFSCxDQUFDLEVBQUgsQ0FBTCxHQUFlNEQsTUFBTSxDQUFFckQsQ0FBQyxFQUFILENBQXJCO1FBQ0E7TUFDRDs7TUFFREosS0FBSyxDQUFDakIsTUFBTixHQUFlYyxDQUFmO01BRUEsT0FBT0csS0FBUDtJQUNBLENBak5hO0lBbU5kMEQsSUFBSSxFQUFFLGNBQVVyRSxLQUFWLEVBQWlCSyxRQUFqQixFQUEyQmlFLE1BQTNCLEVBQW9DO01BQ3pDLElBQUlDLGVBQUo7TUFBQSxJQUNDQyxPQUFPLEdBQUcsRUFEWDtNQUFBLElBRUNoRSxDQUFDLEdBQUcsQ0FGTDtNQUFBLElBR0NkLE1BQU0sR0FBR00sS0FBSyxDQUFDTixNQUhoQjtNQUFBLElBSUMrRSxjQUFjLEdBQUcsQ0FBQ0gsTUFKbkIsQ0FEeUMsQ0FPekM7TUFDQTs7TUFDQSxPQUFROUQsQ0FBQyxHQUFHZCxNQUFaLEVBQW9CYyxDQUFDLEVBQXJCLEVBQTBCO1FBQ3pCK0QsZUFBZSxHQUFHLENBQUNsRSxRQUFRLENBQUVMLEtBQUssQ0FBRVEsQ0FBRixDQUFQLEVBQWNBLENBQWQsQ0FBM0I7O1FBQ0EsSUFBSytELGVBQWUsS0FBS0UsY0FBekIsRUFBMEM7VUFDekNELE9BQU8sQ0FBQ3JHLElBQVIsQ0FBYzZCLEtBQUssQ0FBRVEsQ0FBRixDQUFuQjtRQUNBO01BQ0Q7O01BRUQsT0FBT2dFLE9BQVA7SUFDQSxDQXBPYTtJQXNPZDtJQUNBbEUsR0FBRyxFQUFFLGFBQVVOLEtBQVYsRUFBaUJLLFFBQWpCLEVBQTJCcUUsR0FBM0IsRUFBaUM7TUFDckMsSUFBSWhGLE1BQUo7TUFBQSxJQUFZaUYsS0FBWjtNQUFBLElBQ0NuRSxDQUFDLEdBQUcsQ0FETDtNQUFBLElBRUNQLEdBQUcsR0FBRyxFQUZQLENBRHFDLENBS3JDOztNQUNBLElBQUsyRCxXQUFXLENBQUU1RCxLQUFGLENBQWhCLEVBQTRCO1FBQzNCTixNQUFNLEdBQUdNLEtBQUssQ0FBQ04sTUFBZjs7UUFDQSxPQUFRYyxDQUFDLEdBQUdkLE1BQVosRUFBb0JjLENBQUMsRUFBckIsRUFBMEI7VUFDekJtRSxLQUFLLEdBQUd0RSxRQUFRLENBQUVMLEtBQUssQ0FBRVEsQ0FBRixDQUFQLEVBQWNBLENBQWQsRUFBaUJrRSxHQUFqQixDQUFoQjs7VUFFQSxJQUFLQyxLQUFLLElBQUksSUFBZCxFQUFxQjtZQUNwQjFFLEdBQUcsQ0FBQzlCLElBQUosQ0FBVXdHLEtBQVY7VUFDQTtRQUNELENBUjBCLENBVTVCOztNQUNDLENBWEQsTUFXTztRQUNOLEtBQU1uRSxDQUFOLElBQVdSLEtBQVgsRUFBbUI7VUFDbEIyRSxLQUFLLEdBQUd0RSxRQUFRLENBQUVMLEtBQUssQ0FBRVEsQ0FBRixDQUFQLEVBQWNBLENBQWQsRUFBaUJrRSxHQUFqQixDQUFoQjs7VUFFQSxJQUFLQyxLQUFLLElBQUksSUFBZCxFQUFxQjtZQUNwQjFFLEdBQUcsQ0FBQzlCLElBQUosQ0FBVXdHLEtBQVY7VUFDQTtRQUNEO01BQ0QsQ0F6Qm9DLENBMkJyQzs7O01BQ0EsT0FBT3pHLE1BQU0sQ0FBQ3VDLEtBQVAsQ0FBYyxFQUFkLEVBQWtCUixHQUFsQixDQUFQO0lBQ0EsQ0FwUWE7SUFzUWQ7SUFDQTJFLElBQUksRUFBRSxDQXZRUTtJQXlRZDtJQUNBO0lBQ0FDLEtBQUssRUFBRSxlQUFVL0YsRUFBVixFQUFjRCxPQUFkLEVBQXdCO01BQzlCLElBQUlpRyxJQUFKLEVBQVVELEtBQVYsRUFBaUJFLEdBQWpCOztNQUVBLElBQUssT0FBT2xHLE9BQVAsS0FBbUIsUUFBeEIsRUFBbUM7UUFDbENrRyxHQUFHLEdBQUdqRyxFQUFFLENBQUVELE9BQUYsQ0FBUjtRQUNBQSxPQUFPLEdBQUdDLEVBQVY7UUFDQUEsRUFBRSxHQUFHaUcsR0FBTDtNQUNBLENBUDZCLENBUzlCO01BQ0E7OztNQUNBLElBQUssQ0FBQ3BHLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUI5QyxFQUFuQixDQUFOLEVBQWdDO1FBQy9CLE9BQU9pRCxTQUFQO01BQ0EsQ0FiNkIsQ0FlOUI7OztNQUNBK0MsSUFBSSxHQUFHN0csTUFBSyxDQUFDMkIsSUFBTixDQUFZYyxTQUFaLEVBQXVCLENBQXZCLENBQVA7O01BQ0FtRSxLQUFLLEdBQUcsaUJBQVc7UUFDbEIsT0FBTy9GLEVBQUUsQ0FBQzJCLEtBQUgsQ0FBVTVCLE9BQU8sSUFBSSxJQUFyQixFQUEyQmlHLElBQUksQ0FBQzVHLE1BQUwsQ0FBYUQsTUFBSyxDQUFDMkIsSUFBTixDQUFZYyxTQUFaLENBQWIsQ0FBM0IsQ0FBUDtNQUNBLENBRkQsQ0FqQjhCLENBcUI5Qjs7O01BQ0FtRSxLQUFLLENBQUNELElBQU4sR0FBYTlGLEVBQUUsQ0FBQzhGLElBQUgsR0FBVTlGLEVBQUUsQ0FBQzhGLElBQUgsSUFBV2pHLE1BQU0sQ0FBQ2lHLElBQVAsRUFBbEM7TUFFQSxPQUFPQyxLQUFQO0lBQ0EsQ0FwU2E7SUFzU2RHLEdBQUcsRUFBRSxlQUFXO01BQ2YsT0FBTyxDQUFHLElBQUlDLElBQUosRUFBVjtJQUNBLENBeFNhO0lBMFNkO0lBQ0E7SUFDQXhHLE9BQU8sRUFBRUE7RUE1U0ssQ0FBZixFQTlNOEUsQ0E2ZjlFO0VBQ0E7RUFDQTtFQUNBOztFQUNBOztFQUNBLElBQUssT0FBT3lHLE1BQVAsS0FBa0IsVUFBdkIsRUFBb0M7SUFDbkN2RyxNQUFNLENBQUNHLEVBQVAsQ0FBV29HLE1BQU0sQ0FBQ0MsUUFBbEIsSUFBK0JuSCxVQUFVLENBQUVrSCxNQUFNLENBQUNDLFFBQVQsQ0FBekM7RUFDQTtFQUNEO0VBRUE7OztFQUNBeEcsTUFBTSxDQUFDeUIsSUFBUCxDQUFhLHVFQUF1RWdGLEtBQXZFLENBQThFLEdBQTlFLENBQWIsRUFDQSxVQUFVNUUsQ0FBVixFQUFhZSxJQUFiLEVBQW9CO0lBQ25CbEQsVUFBVSxDQUFFLGFBQWFrRCxJQUFiLEdBQW9CLEdBQXRCLENBQVYsR0FBd0NBLElBQUksQ0FBQ29DLFdBQUwsRUFBeEM7RUFDQSxDQUhEOztFQUtBLFNBQVNDLFdBQVQsQ0FBc0JwQixHQUF0QixFQUE0QjtJQUUzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUk5QyxNQUFNLEdBQUcsQ0FBQyxDQUFDOEMsR0FBRixJQUFTLFlBQVlBLEdBQXJCLElBQTRCQSxHQUFHLENBQUM5QyxNQUE3QztJQUFBLElBQ0MrQyxJQUFJLEdBQUc5RCxNQUFNLENBQUM4RCxJQUFQLENBQWFELEdBQWIsQ0FEUjs7SUFHQSxJQUFLQyxJQUFJLEtBQUssVUFBVCxJQUF1QjlELE1BQU0sQ0FBQ2dFLFFBQVAsQ0FBaUJILEdBQWpCLENBQTVCLEVBQXFEO01BQ3BELE9BQU8sS0FBUDtJQUNBOztJQUVELE9BQU9DLElBQUksS0FBSyxPQUFULElBQW9CL0MsTUFBTSxLQUFLLENBQS9CLElBQ04sT0FBT0EsTUFBUCxLQUFrQixRQUFsQixJQUE4QkEsTUFBTSxHQUFHLENBQXZDLElBQThDQSxNQUFNLEdBQUcsQ0FBWCxJQUFrQjhDLEdBRC9EO0VBRUE7O0VBQ0QsSUFBSTZDLE1BQU07RUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNDLFVBQVV2SCxNQUFWLEVBQW1CO0lBRXBCLElBQUkwQyxDQUFKO0lBQUEsSUFDQy9CLE9BREQ7SUFBQSxJQUVDNkcsSUFGRDtJQUFBLElBR0NDLE9BSEQ7SUFBQSxJQUlDQyxLQUpEO0lBQUEsSUFLQ0MsUUFMRDtJQUFBLElBTUNDLE9BTkQ7SUFBQSxJQU9DQyxNQVBEO0lBQUEsSUFRQ0MsZ0JBUkQ7SUFBQSxJQVNDQyxTQVREO0lBQUEsSUFVQ0MsWUFWRDtJQUFBLElBWUM7SUFDQUMsV0FiRDtJQUFBLElBY0NwSSxRQWREO0lBQUEsSUFlQ3FJLE9BZkQ7SUFBQSxJQWdCQ0MsY0FoQkQ7SUFBQSxJQWlCQ0MsU0FqQkQ7SUFBQSxJQWtCQ0MsYUFsQkQ7SUFBQSxJQW1CQzNCLE9BbkJEO0lBQUEsSUFvQkM0QixRQXBCRDtJQUFBLElBc0JDO0lBQ0FwRSxPQUFPLEdBQUcsV0FBVyxJQUFJLElBQUlpRCxJQUFKLEVBdkIxQjtJQUFBLElBd0JDb0IsWUFBWSxHQUFHdkksTUFBTSxDQUFDSCxRQXhCdkI7SUFBQSxJQXlCQzJJLE9BQU8sR0FBRyxDQXpCWDtJQUFBLElBMEJDQyxJQUFJLEdBQUcsQ0ExQlI7SUFBQSxJQTJCQ0MsVUFBVSxHQUFHQyxXQUFXLEVBM0J6QjtJQUFBLElBNEJDQyxVQUFVLEdBQUdELFdBQVcsRUE1QnpCO0lBQUEsSUE2QkNFLGFBQWEsR0FBR0YsV0FBVyxFQTdCNUI7SUFBQSxJQThCQ0csU0FBUyxHQUFHLG1CQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBaUI7TUFDNUIsSUFBS0QsQ0FBQyxLQUFLQyxDQUFYLEVBQWU7UUFDZGhCLFlBQVksR0FBRyxJQUFmO01BQ0E7O01BQ0QsT0FBTyxDQUFQO0lBQ0EsQ0FuQ0Y7SUFBQSxJQXFDQztJQUNBaUIsWUFBWSxHQUFHLEtBQUssRUF0Q3JCO0lBQUEsSUF3Q0M7SUFDQXhJLE1BQU0sR0FBSSxFQUFELENBQUtDLGNBekNmO0lBQUEsSUEwQ0N1RixHQUFHLEdBQUcsRUExQ1A7SUFBQSxJQTJDQ2lELEdBQUcsR0FBR2pELEdBQUcsQ0FBQ2lELEdBM0NYO0lBQUEsSUE0Q0NDLFdBQVcsR0FBR2xELEdBQUcsQ0FBQzVGLElBNUNuQjtJQUFBLElBNkNDQSxJQUFJLEdBQUc0RixHQUFHLENBQUM1RixJQTdDWjtJQUFBLElBOENDRixLQUFLLEdBQUc4RixHQUFHLENBQUM5RixLQTlDYjtJQUFBLElBK0NDO0lBQ0E7SUFDQUcsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVThJLElBQVYsRUFBZ0IzRyxJQUFoQixFQUF1QjtNQUNoQyxJQUFJQyxDQUFDLEdBQUcsQ0FBUjtNQUFBLElBQ0NNLEdBQUcsR0FBR29HLElBQUksQ0FBQ3hILE1BRFo7O01BRUEsT0FBUWMsQ0FBQyxHQUFHTSxHQUFaLEVBQWlCTixDQUFDLEVBQWxCLEVBQXVCO1FBQ3RCLElBQUswRyxJQUFJLENBQUMxRyxDQUFELENBQUosS0FBWUQsSUFBakIsRUFBd0I7VUFDdkIsT0FBT0MsQ0FBUDtRQUNBO01BQ0Q7O01BQ0QsT0FBTyxDQUFDLENBQVI7SUFDQSxDQTFERjtJQUFBLElBNERDMkcsUUFBUSxHQUFHLDRIQTVEWjtJQUFBLElBOERDO0lBRUE7SUFDQUMsVUFBVSxHQUFHLHFCQWpFZDtJQUFBLElBbUVDO0lBQ0FDLFVBQVUsR0FBRyxrQ0FwRWQ7SUFBQSxJQXNFQztJQUNBQyxVQUFVLEdBQUcsUUFBUUYsVUFBUixHQUFxQixJQUFyQixHQUE0QkMsVUFBNUIsR0FBeUMsTUFBekMsR0FBa0RELFVBQWxELEdBQ1o7SUFDQSxlQUZZLEdBRU1BLFVBRk4sR0FHWjtJQUNBLDBEQUpZLEdBSWlEQyxVQUpqRCxHQUk4RCxNQUo5RCxHQUl1RUQsVUFKdkUsR0FLWixNQTVFRjtJQUFBLElBOEVDRyxPQUFPLEdBQUcsT0FBT0YsVUFBUCxHQUFvQixVQUFwQixHQUNUO0lBQ0E7SUFDQSx1REFIUyxHQUlUO0lBQ0EsMEJBTFMsR0FLb0JDLFVBTHBCLEdBS2lDLE1BTGpDLEdBTVQ7SUFDQSxJQVBTLEdBUVQsUUF0RkY7SUFBQSxJQXdGQztJQUNBRSxXQUFXLEdBQUcsSUFBSUMsTUFBSixDQUFZTCxVQUFVLEdBQUcsR0FBekIsRUFBOEIsR0FBOUIsQ0F6RmY7SUFBQSxJQTBGQ3BJLEtBQUssR0FBRyxJQUFJeUksTUFBSixDQUFZLE1BQU1MLFVBQU4sR0FBbUIsNkJBQW5CLEdBQW1EQSxVQUFuRCxHQUFnRSxJQUE1RSxFQUFrRixHQUFsRixDQTFGVDtJQUFBLElBNEZDTSxNQUFNLEdBQUcsSUFBSUQsTUFBSixDQUFZLE1BQU1MLFVBQU4sR0FBbUIsSUFBbkIsR0FBMEJBLFVBQTFCLEdBQXVDLEdBQW5ELENBNUZWO0lBQUEsSUE2RkNPLFlBQVksR0FBRyxJQUFJRixNQUFKLENBQVksTUFBTUwsVUFBTixHQUFtQixVQUFuQixHQUFnQ0EsVUFBaEMsR0FBNkMsR0FBN0MsR0FBbURBLFVBQW5ELEdBQWdFLEdBQTVFLENBN0ZoQjtJQUFBLElBK0ZDUSxnQkFBZ0IsR0FBRyxJQUFJSCxNQUFKLENBQVksTUFBTUwsVUFBTixHQUFtQixnQkFBbkIsR0FBc0NBLFVBQXRDLEdBQW1ELE1BQS9ELEVBQXVFLEdBQXZFLENBL0ZwQjtJQUFBLElBaUdDUyxPQUFPLEdBQUcsSUFBSUosTUFBSixDQUFZRixPQUFaLENBakdYO0lBQUEsSUFrR0NPLFdBQVcsR0FBRyxJQUFJTCxNQUFKLENBQVksTUFBTUosVUFBTixHQUFtQixHQUEvQixDQWxHZjtJQUFBLElBb0dDVSxTQUFTLEdBQUc7TUFDWCxNQUFNLElBQUlOLE1BQUosQ0FBWSxRQUFRSixVQUFSLEdBQXFCLEdBQWpDLENBREs7TUFFWCxTQUFTLElBQUlJLE1BQUosQ0FBWSxVQUFVSixVQUFWLEdBQXVCLEdBQW5DLENBRkU7TUFHWCxPQUFPLElBQUlJLE1BQUosQ0FBWSxPQUFPSixVQUFQLEdBQW9CLE9BQWhDLENBSEk7TUFJWCxRQUFRLElBQUlJLE1BQUosQ0FBWSxNQUFNSCxVQUFsQixDQUpHO01BS1gsVUFBVSxJQUFJRyxNQUFKLENBQVksTUFBTUYsT0FBbEIsQ0FMQztNQU1YLFNBQVMsSUFBSUUsTUFBSixDQUFZLDJEQUEyREwsVUFBM0QsR0FDcEIsOEJBRG9CLEdBQ2FBLFVBRGIsR0FDMEIsYUFEMUIsR0FDMENBLFVBRDFDLEdBRXBCLFlBRm9CLEdBRUxBLFVBRkssR0FFUSxRQUZwQixFQUU4QixHQUY5QixDQU5FO01BU1gsUUFBUSxJQUFJSyxNQUFKLENBQVksU0FBU04sUUFBVCxHQUFvQixJQUFoQyxFQUFzQyxHQUF0QyxDQVRHO01BVVg7TUFDQTtNQUNBLGdCQUFnQixJQUFJTSxNQUFKLENBQVksTUFBTUwsVUFBTixHQUFtQixrREFBbkIsR0FDM0JBLFVBRDJCLEdBQ2Qsa0JBRGMsR0FDT0EsVUFEUCxHQUNvQixrQkFEaEMsRUFDb0QsR0FEcEQ7SUFaTCxDQXBHYjtJQUFBLElBb0hDWSxPQUFPLEdBQUcscUNBcEhYO0lBQUEsSUFxSENDLE9BQU8sR0FBRyxRQXJIWDtJQUFBLElBdUhDQyxPQUFPLEdBQUcsd0JBdkhYO0lBQUEsSUF5SEM7SUFDQUMsVUFBVSxHQUFHLGtDQTFIZDtJQUFBLElBNEhDQyxRQUFRLEdBQUcsTUE1SFo7SUFBQSxJQTZIQ0MsT0FBTyxHQUFHLE9BN0hYO0lBQUEsSUErSEM7SUFDQUMsU0FBUyxHQUFHLElBQUliLE1BQUosQ0FBWSx1QkFBdUJMLFVBQXZCLEdBQW9DLEtBQXBDLEdBQTRDQSxVQUE1QyxHQUF5RCxNQUFyRSxFQUE2RSxJQUE3RSxDQWhJYjtJQUFBLElBaUlDbUIsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBVUMsQ0FBVixFQUFhQyxPQUFiLEVBQXNCQyxpQkFBdEIsRUFBMEM7TUFDckQsSUFBSUMsSUFBSSxHQUFHLE9BQU9GLE9BQVAsR0FBaUIsT0FBNUIsQ0FEcUQsQ0FFckQ7TUFDQTtNQUNBOztNQUNBLE9BQU9FLElBQUksS0FBS0EsSUFBVCxJQUFpQkQsaUJBQWpCLEdBQ05ELE9BRE0sR0FFTkUsSUFBSSxHQUFHLENBQVAsR0FDQztNQUNBQyxNQUFNLENBQUNDLFlBQVAsQ0FBcUJGLElBQUksR0FBRyxPQUE1QixDQUZELEdBR0M7TUFDQUMsTUFBTSxDQUFDQyxZQUFQLENBQXFCRixJQUFJLElBQUksRUFBUixHQUFhLE1BQWxDLEVBQTBDQSxJQUFJLEdBQUcsS0FBUCxHQUFlLE1BQXpELENBTkY7SUFPQSxDQTdJRjtJQUFBLElBK0lDO0lBQ0E7SUFDQTtJQUNBO0lBQ0FHLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsR0FBVztNQUMxQi9DLFdBQVc7SUFDWCxDQXJKRixDQUZvQixDQXlKcEI7OztJQUNBLElBQUk7TUFDSDVILElBQUksQ0FBQ3NDLEtBQUwsQ0FDRXNELEdBQUcsR0FBRzlGLEtBQUssQ0FBQzJCLElBQU4sQ0FBWXlHLFlBQVksQ0FBQzBDLFVBQXpCLENBRFIsRUFFQzFDLFlBQVksQ0FBQzBDLFVBRmQsRUFERyxDQUtIO01BQ0E7O01BQ0FoRixHQUFHLENBQUVzQyxZQUFZLENBQUMwQyxVQUFiLENBQXdCckosTUFBMUIsQ0FBSCxDQUFzQ3VELFFBQXRDO0lBQ0EsQ0FSRCxDQVFFLE9BQVFDLENBQVIsRUFBWTtNQUNiL0UsSUFBSSxHQUFHO1FBQUVzQyxLQUFLLEVBQUVzRCxHQUFHLENBQUNyRSxNQUFKLEdBRWY7UUFDQSxVQUFVZ0MsTUFBVixFQUFrQnNILEdBQWxCLEVBQXdCO1VBQ3ZCL0IsV0FBVyxDQUFDeEcsS0FBWixDQUFtQmlCLE1BQW5CLEVBQTJCekQsS0FBSyxDQUFDMkIsSUFBTixDQUFXb0osR0FBWCxDQUEzQjtRQUNBLENBTGMsR0FPZjtRQUNBO1FBQ0EsVUFBVXRILE1BQVYsRUFBa0JzSCxHQUFsQixFQUF3QjtVQUN2QixJQUFJakksQ0FBQyxHQUFHVyxNQUFNLENBQUNoQyxNQUFmO1VBQUEsSUFDQ2MsQ0FBQyxHQUFHLENBREwsQ0FEdUIsQ0FHdkI7O1VBQ0EsT0FBU2tCLE1BQU0sQ0FBQ1gsQ0FBQyxFQUFGLENBQU4sR0FBY2lJLEdBQUcsQ0FBQ3hJLENBQUMsRUFBRixDQUExQixFQUFtQyxDQUFFOztVQUNyQ2tCLE1BQU0sQ0FBQ2hDLE1BQVAsR0FBZ0JxQixDQUFDLEdBQUcsQ0FBcEI7UUFDQTtNQWZLLENBQVA7SUFpQkE7O0lBRUQsU0FBU3NFLE1BQVQsQ0FBaUJ6RyxRQUFqQixFQUEyQkMsT0FBM0IsRUFBb0NtRixPQUFwQyxFQUE2Q2lGLElBQTdDLEVBQW9EO01BQ25ELElBQUlDLENBQUo7TUFBQSxJQUFPMUksQ0FBUDtNQUFBLElBQVVELElBQVY7TUFBQSxJQUFnQjRJLEdBQWhCO01BQUEsSUFBcUJDLFNBQXJCO01BQUEsSUFBZ0NDLEtBQWhDO01BQUEsSUFBdUNDLE1BQXZDO01BQUEsSUFBK0NDLFdBQS9DO01BQUEsSUFDQ0MsVUFBVSxHQUFHM0ssT0FBTyxJQUFJQSxPQUFPLENBQUM0SyxhQURqQztNQUFBLElBR0M7TUFDQXhHLFFBQVEsR0FBR3BFLE9BQU8sR0FBR0EsT0FBTyxDQUFDb0UsUUFBWCxHQUFzQixDQUp6QztNQU1BZSxPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQixDQVBtRCxDQVNuRDs7TUFDQSxJQUFLLE9BQU9wRixRQUFQLEtBQW9CLFFBQXBCLElBQWdDLENBQUNBLFFBQWpDLElBQ0pxRSxRQUFRLEtBQUssQ0FBYixJQUFrQkEsUUFBUSxLQUFLLENBQS9CLElBQW9DQSxRQUFRLEtBQUssRUFEbEQsRUFDdUQ7UUFFdEQsT0FBT2UsT0FBUDtNQUNBLENBZGtELENBZ0JuRDs7O01BQ0EsSUFBSyxDQUFDaUYsSUFBTixFQUFhO1FBRVosSUFBSyxDQUFFcEssT0FBTyxHQUFHQSxPQUFPLENBQUM0SyxhQUFSLElBQXlCNUssT0FBNUIsR0FBc0N3SCxZQUEvQyxNQUFrRTFJLFFBQXZFLEVBQWtGO1VBQ2pGb0ksV0FBVyxDQUFFbEgsT0FBRixDQUFYO1FBQ0E7O1FBQ0RBLE9BQU8sR0FBR0EsT0FBTyxJQUFJbEIsUUFBckI7O1FBRUEsSUFBS3NJLGNBQUwsRUFBc0I7VUFFckI7VUFDQTtVQUNBLElBQUtoRCxRQUFRLEtBQUssRUFBYixLQUFvQm9HLEtBQUssR0FBR2xCLFVBQVUsQ0FBQ3VCLElBQVgsQ0FBaUI5SyxRQUFqQixDQUE1QixDQUFMLEVBQWdFO1lBRS9EO1lBQ0EsSUFBTXNLLENBQUMsR0FBR0csS0FBSyxDQUFDLENBQUQsQ0FBZixFQUFzQjtjQUVyQjtjQUNBLElBQUtwRyxRQUFRLEtBQUssQ0FBbEIsRUFBc0I7Z0JBQ3JCLElBQU0xQyxJQUFJLEdBQUcxQixPQUFPLENBQUM4SyxjQUFSLENBQXdCVCxDQUF4QixDQUFiLEVBQTRDO2tCQUUzQztrQkFDQTtrQkFDQTtrQkFDQSxJQUFLM0ksSUFBSSxDQUFDcUosRUFBTCxLQUFZVixDQUFqQixFQUFxQjtvQkFDcEJsRixPQUFPLENBQUM3RixJQUFSLENBQWNvQyxJQUFkO29CQUNBLE9BQU95RCxPQUFQO2tCQUNBO2dCQUNELENBVEQsTUFTTztrQkFDTixPQUFPQSxPQUFQO2dCQUNBLENBWm9CLENBY3RCOztjQUNDLENBZkQsTUFlTztnQkFFTjtnQkFDQTtnQkFDQTtnQkFDQSxJQUFLd0YsVUFBVSxLQUFLakosSUFBSSxHQUFHaUosVUFBVSxDQUFDRyxjQUFYLENBQTJCVCxDQUEzQixDQUFaLENBQVYsSUFDSjlDLFFBQVEsQ0FBRXZILE9BQUYsRUFBVzBCLElBQVgsQ0FESixJQUVKQSxJQUFJLENBQUNxSixFQUFMLEtBQVlWLENBRmIsRUFFaUI7a0JBRWhCbEYsT0FBTyxDQUFDN0YsSUFBUixDQUFjb0MsSUFBZDtrQkFDQSxPQUFPeUQsT0FBUDtnQkFDQTtjQUNELENBOUJvQixDQWdDdEI7O1lBQ0MsQ0FqQ0QsTUFpQ08sSUFBS3FGLEtBQUssQ0FBQyxDQUFELENBQVYsRUFBZ0I7Y0FDdEJsTCxJQUFJLENBQUNzQyxLQUFMLENBQVl1RCxPQUFaLEVBQXFCbkYsT0FBTyxDQUFDZ0wsb0JBQVIsQ0FBOEJqTCxRQUE5QixDQUFyQjtjQUNBLE9BQU9vRixPQUFQLENBRnNCLENBSXZCO1lBQ0MsQ0FMTSxNQUtBLElBQUssQ0FBQ2tGLENBQUMsR0FBR0csS0FBSyxDQUFDLENBQUQsQ0FBVixLQUFrQjVLLE9BQU8sQ0FBQ3FMLHNCQUExQixJQUNYakwsT0FBTyxDQUFDaUwsc0JBREYsRUFDMkI7Y0FFakMzTCxJQUFJLENBQUNzQyxLQUFMLENBQVl1RCxPQUFaLEVBQXFCbkYsT0FBTyxDQUFDaUwsc0JBQVIsQ0FBZ0NaLENBQWhDLENBQXJCO2NBQ0EsT0FBT2xGLE9BQVA7WUFDQTtVQUNELENBbkRvQixDQXFEckI7OztVQUNBLElBQUt2RixPQUFPLENBQUNzTCxHQUFSLElBQ0osQ0FBQ3BELGFBQWEsQ0FBRS9ILFFBQVEsR0FBRyxHQUFiLENBRFYsS0FFSCxDQUFDc0gsU0FBRCxJQUFjLENBQUNBLFNBQVMsQ0FBQzhELElBQVYsQ0FBZ0JwTCxRQUFoQixDQUZaLENBQUwsRUFFK0M7WUFFOUMsSUFBS3FFLFFBQVEsS0FBSyxDQUFsQixFQUFzQjtjQUNyQnVHLFVBQVUsR0FBRzNLLE9BQWI7Y0FDQTBLLFdBQVcsR0FBRzNLLFFBQWQsQ0FGcUIsQ0FJdEI7Y0FDQTtjQUNBO2NBQ0E7WUFDQyxDQVJELE1BUU8sSUFBS0MsT0FBTyxDQUFDNkUsUUFBUixDQUFpQkMsV0FBakIsT0FBbUMsUUFBeEMsRUFBbUQ7Y0FFekQ7Y0FDQSxJQUFNd0YsR0FBRyxHQUFHdEssT0FBTyxDQUFDb0wsWUFBUixDQUFzQixJQUF0QixDQUFaLEVBQTRDO2dCQUMzQ2QsR0FBRyxHQUFHQSxHQUFHLENBQUNoSCxPQUFKLENBQWFrRyxPQUFiLEVBQXNCLE1BQXRCLENBQU47Y0FDQSxDQUZELE1BRU87Z0JBQ054SixPQUFPLENBQUNxTCxZQUFSLENBQXNCLElBQXRCLEVBQTZCZixHQUFHLEdBQUduSCxPQUFuQztjQUNBLENBUHdELENBU3pEOzs7Y0FDQXNILE1BQU0sR0FBRzdELFFBQVEsQ0FBRTdHLFFBQUYsQ0FBakI7Y0FDQTRCLENBQUMsR0FBRzhJLE1BQU0sQ0FBQzVKLE1BQVg7Y0FDQTBKLFNBQVMsR0FBR3RCLFdBQVcsQ0FBQ2tDLElBQVosQ0FBa0JiLEdBQWxCLElBQTBCLE1BQU1BLEdBQWhDLEdBQXNDLFVBQVVBLEdBQVYsR0FBZ0IsSUFBbEU7O2NBQ0EsT0FBUTNJLENBQUMsRUFBVCxFQUFjO2dCQUNiOEksTUFBTSxDQUFDOUksQ0FBRCxDQUFOLEdBQVk0SSxTQUFTLEdBQUcsR0FBWixHQUFrQmUsVUFBVSxDQUFFYixNQUFNLENBQUM5SSxDQUFELENBQVIsQ0FBeEM7Y0FDQTs7Y0FDRCtJLFdBQVcsR0FBR0QsTUFBTSxDQUFDYyxJQUFQLENBQWEsR0FBYixDQUFkLENBaEJ5RCxDQWtCekQ7O2NBQ0FaLFVBQVUsR0FBR3BCLFFBQVEsQ0FBQzRCLElBQVQsQ0FBZXBMLFFBQWYsS0FBNkJ5TCxXQUFXLENBQUV4TCxPQUFPLENBQUN5TCxVQUFWLENBQXhDLElBQ1p6TCxPQUREO1lBRUE7O1lBRUQsSUFBSzBLLFdBQUwsRUFBbUI7Y0FDbEIsSUFBSTtnQkFDSHBMLElBQUksQ0FBQ3NDLEtBQUwsQ0FBWXVELE9BQVosRUFDQ3dGLFVBQVUsQ0FBQ2UsZ0JBQVgsQ0FBNkJoQixXQUE3QixDQUREO2dCQUdBLE9BQU92RixPQUFQO2NBQ0EsQ0FMRCxDQUtFLE9BQVF3RyxRQUFSLEVBQW1CLENBQ3BCLENBTkQsU0FNVTtnQkFDVCxJQUFLckIsR0FBRyxLQUFLbkgsT0FBYixFQUF1QjtrQkFDdEJuRCxPQUFPLENBQUM0TCxlQUFSLENBQXlCLElBQXpCO2dCQUNBO2NBQ0Q7WUFDRDtVQUNEO1FBQ0Q7TUFDRCxDQWhJa0QsQ0FrSW5EOzs7TUFDQSxPQUFPOUUsTUFBTSxDQUFFL0csUUFBUSxDQUFDdUQsT0FBVCxDQUFrQm5ELEtBQWxCLEVBQXlCLElBQXpCLENBQUYsRUFBbUNILE9BQW5DLEVBQTRDbUYsT0FBNUMsRUFBcURpRixJQUFyRCxDQUFiO0lBQ0E7SUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUNBLFNBQVN4QyxXQUFULEdBQXVCO01BQ3RCLElBQUlpRSxJQUFJLEdBQUcsRUFBWDs7TUFFQSxTQUFTQyxLQUFULENBQWdCM0gsR0FBaEIsRUFBcUIyQixLQUFyQixFQUE2QjtRQUM1QjtRQUNBLElBQUsrRixJQUFJLENBQUN2TSxJQUFMLENBQVc2RSxHQUFHLEdBQUcsR0FBakIsSUFBeUJzQyxJQUFJLENBQUNzRixXQUFuQyxFQUFpRDtVQUNoRDtVQUNBLE9BQU9ELEtBQUssQ0FBRUQsSUFBSSxDQUFDRyxLQUFMLEVBQUYsQ0FBWjtRQUNBOztRQUNELE9BQVFGLEtBQUssQ0FBRTNILEdBQUcsR0FBRyxHQUFSLENBQUwsR0FBcUIyQixLQUE3QjtNQUNBOztNQUNELE9BQU9nRyxLQUFQO0lBQ0E7SUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0EsU0FBU0csWUFBVCxDQUF1QmhNLEVBQXZCLEVBQTRCO01BQzNCQSxFQUFFLENBQUVrRCxPQUFGLENBQUYsR0FBZ0IsSUFBaEI7TUFDQSxPQUFPbEQsRUFBUDtJQUNBO0lBRUQ7QUFDQTtBQUNBO0FBQ0E7OztJQUNBLFNBQVNpTSxNQUFULENBQWlCak0sRUFBakIsRUFBc0I7TUFDckIsSUFBSWtNLEdBQUcsR0FBR3JOLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjs7TUFFQSxJQUFJO1FBQ0gsT0FBTyxDQUFDLENBQUNuTSxFQUFFLENBQUVrTSxHQUFGLENBQVg7TUFDQSxDQUZELENBRUUsT0FBTzlILENBQVAsRUFBVTtRQUNYLE9BQU8sS0FBUDtNQUNBLENBSkQsU0FJVTtRQUNUO1FBQ0EsSUFBSzhILEdBQUcsQ0FBQ1YsVUFBVCxFQUFzQjtVQUNyQlUsR0FBRyxDQUFDVixVQUFKLENBQWVZLFdBQWYsQ0FBNEJGLEdBQTVCO1FBQ0EsQ0FKUSxDQUtUOzs7UUFDQUEsR0FBRyxHQUFHLElBQU47TUFDQTtJQUNEO0lBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0EsU0FBU0csU0FBVCxDQUFvQkMsS0FBcEIsRUFBMkJDLE9BQTNCLEVBQXFDO01BQ3BDLElBQUl0SCxHQUFHLEdBQUdxSCxLQUFLLENBQUNoRyxLQUFOLENBQVksR0FBWixDQUFWO01BQUEsSUFDQzVFLENBQUMsR0FBR3VELEdBQUcsQ0FBQ3JFLE1BRFQ7O01BR0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7UUFDYjhFLElBQUksQ0FBQ2dHLFVBQUwsQ0FBaUJ2SCxHQUFHLENBQUN2RCxDQUFELENBQXBCLElBQTRCNkssT0FBNUI7TUFDQTtJQUNEO0lBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFDQSxTQUFTRSxZQUFULENBQXVCMUUsQ0FBdkIsRUFBMEJDLENBQTFCLEVBQThCO01BQzdCLElBQUkwRSxHQUFHLEdBQUcxRSxDQUFDLElBQUlELENBQWY7TUFBQSxJQUNDNEUsSUFBSSxHQUFHRCxHQUFHLElBQUkzRSxDQUFDLENBQUM1RCxRQUFGLEtBQWUsQ0FBdEIsSUFBMkI2RCxDQUFDLENBQUM3RCxRQUFGLEtBQWUsQ0FBMUMsSUFDTixDQUFFLENBQUM2RCxDQUFDLENBQUM0RSxXQUFILElBQWtCM0UsWUFBcEIsS0FDRSxDQUFDRixDQUFDLENBQUM2RSxXQUFILElBQWtCM0UsWUFEcEIsQ0FGRixDQUQ2QixDQU03Qjs7TUFDQSxJQUFLMEUsSUFBTCxFQUFZO1FBQ1gsT0FBT0EsSUFBUDtNQUNBLENBVDRCLENBVzdCOzs7TUFDQSxJQUFLRCxHQUFMLEVBQVc7UUFDVixPQUFTQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0csV0FBbkIsRUFBa0M7VUFDakMsSUFBS0gsR0FBRyxLQUFLMUUsQ0FBYixFQUFpQjtZQUNoQixPQUFPLENBQUMsQ0FBUjtVQUNBO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPRCxDQUFDLEdBQUcsQ0FBSCxHQUFPLENBQUMsQ0FBaEI7SUFDQTtJQUVEO0FBQ0E7QUFDQTtBQUNBOzs7SUFDQSxTQUFTK0UsaUJBQVQsQ0FBNEJuSixJQUE1QixFQUFtQztNQUNsQyxPQUFPLFVBQVVsQyxJQUFWLEVBQWlCO1FBQ3ZCLElBQUlnQixJQUFJLEdBQUdoQixJQUFJLENBQUNtRCxRQUFMLENBQWNDLFdBQWQsRUFBWDtRQUNBLE9BQU9wQyxJQUFJLEtBQUssT0FBVCxJQUFvQmhCLElBQUksQ0FBQ2tDLElBQUwsS0FBY0EsSUFBekM7TUFDQSxDQUhEO0lBSUE7SUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0EsU0FBU29KLGtCQUFULENBQTZCcEosSUFBN0IsRUFBb0M7TUFDbkMsT0FBTyxVQUFVbEMsSUFBVixFQUFpQjtRQUN2QixJQUFJZ0IsSUFBSSxHQUFHaEIsSUFBSSxDQUFDbUQsUUFBTCxDQUFjQyxXQUFkLEVBQVg7UUFDQSxPQUFPLENBQUNwQyxJQUFJLEtBQUssT0FBVCxJQUFvQkEsSUFBSSxLQUFLLFFBQTlCLEtBQTJDaEIsSUFBSSxDQUFDa0MsSUFBTCxLQUFjQSxJQUFoRTtNQUNBLENBSEQ7SUFJQTtJQUVEO0FBQ0E7QUFDQTtBQUNBOzs7SUFDQSxTQUFTcUosc0JBQVQsQ0FBaUNoTixFQUFqQyxFQUFzQztNQUNyQyxPQUFPZ00sWUFBWSxDQUFDLFVBQVVpQixRQUFWLEVBQXFCO1FBQ3hDQSxRQUFRLEdBQUcsQ0FBQ0EsUUFBWjtRQUNBLE9BQU9qQixZQUFZLENBQUMsVUFBVTdCLElBQVYsRUFBZ0J6RSxPQUFoQixFQUEwQjtVQUM3QyxJQUFJekQsQ0FBSjtVQUFBLElBQ0NpTCxZQUFZLEdBQUdsTixFQUFFLENBQUUsRUFBRixFQUFNbUssSUFBSSxDQUFDdkosTUFBWCxFQUFtQnFNLFFBQW5CLENBRGxCO1VBQUEsSUFFQ3ZMLENBQUMsR0FBR3dMLFlBQVksQ0FBQ3RNLE1BRmxCLENBRDZDLENBSzdDOztVQUNBLE9BQVFjLENBQUMsRUFBVCxFQUFjO1lBQ2IsSUFBS3lJLElBQUksQ0FBR2xJLENBQUMsR0FBR2lMLFlBQVksQ0FBQ3hMLENBQUQsQ0FBbkIsQ0FBVCxFQUFxQztjQUNwQ3lJLElBQUksQ0FBQ2xJLENBQUQsQ0FBSixHQUFVLEVBQUV5RCxPQUFPLENBQUN6RCxDQUFELENBQVAsR0FBYWtJLElBQUksQ0FBQ2xJLENBQUQsQ0FBbkIsQ0FBVjtZQUNBO1VBQ0Q7UUFDRCxDQVhrQixDQUFuQjtNQVlBLENBZGtCLENBQW5CO0lBZUE7SUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFDQSxTQUFTc0osV0FBVCxDQUFzQnhMLE9BQXRCLEVBQWdDO01BQy9CLE9BQU9BLE9BQU8sSUFBSSxPQUFPQSxPQUFPLENBQUNnTCxvQkFBZixLQUF3QyxXQUFuRCxJQUFrRWhMLE9BQXpFO0lBQ0EsQ0E1Y21CLENBOGNwQjs7O0lBQ0FKLE9BQU8sR0FBRzRHLE1BQU0sQ0FBQzVHLE9BQVAsR0FBaUIsRUFBM0I7SUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNBK0csS0FBSyxHQUFHSCxNQUFNLENBQUNHLEtBQVAsR0FBZSxVQUFVakYsSUFBVixFQUFpQjtNQUN2QztNQUNBO01BQ0EsSUFBSTBMLGVBQWUsR0FBRzFMLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNrSixhQUFMLElBQXNCbEosSUFBdkIsRUFBNkIwTCxlQUEzRDtNQUNBLE9BQU9BLGVBQWUsR0FBR0EsZUFBZSxDQUFDdkksUUFBaEIsS0FBNkIsTUFBaEMsR0FBeUMsS0FBL0Q7SUFDQSxDQUxEO0lBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0FxQyxXQUFXLEdBQUdWLE1BQU0sQ0FBQ1UsV0FBUCxHQUFxQixVQUFVbUcsSUFBVixFQUFpQjtNQUNuRCxJQUFJQyxVQUFKO01BQUEsSUFBZ0JDLE1BQWhCO01BQUEsSUFDQ0MsR0FBRyxHQUFHSCxJQUFJLEdBQUdBLElBQUksQ0FBQ3pDLGFBQUwsSUFBc0J5QyxJQUF6QixHQUFnQzdGLFlBRDNDLENBRG1ELENBSW5EOztNQUNBLElBQUtnRyxHQUFHLEtBQUsxTyxRQUFSLElBQW9CME8sR0FBRyxDQUFDcEosUUFBSixLQUFpQixDQUFyQyxJQUEwQyxDQUFDb0osR0FBRyxDQUFDSixlQUFwRCxFQUFzRTtRQUNyRSxPQUFPdE8sUUFBUDtNQUNBLENBUGtELENBU25EOzs7TUFDQUEsUUFBUSxHQUFHME8sR0FBWDtNQUNBckcsT0FBTyxHQUFHckksUUFBUSxDQUFDc08sZUFBbkI7TUFDQWhHLGNBQWMsR0FBRyxDQUFDVCxLQUFLLENBQUU3SCxRQUFGLENBQXZCLENBWm1ELENBY25EO01BQ0E7O01BQ0EsSUFBSyxDQUFDeU8sTUFBTSxHQUFHek8sUUFBUSxDQUFDMk8sV0FBbkIsS0FBbUNGLE1BQU0sQ0FBQ0csR0FBUCxLQUFlSCxNQUF2RCxFQUFnRTtRQUMvRDtRQUNBLElBQUtBLE1BQU0sQ0FBQ0ksZ0JBQVosRUFBK0I7VUFDOUJKLE1BQU0sQ0FBQ0ksZ0JBQVAsQ0FBeUIsUUFBekIsRUFBbUMxRCxhQUFuQyxFQUFrRCxLQUFsRCxFQUQ4QixDQUcvQjtRQUNDLENBSkQsTUFJTyxJQUFLc0QsTUFBTSxDQUFDSyxXQUFaLEVBQTBCO1VBQ2hDTCxNQUFNLENBQUNLLFdBQVAsQ0FBb0IsVUFBcEIsRUFBZ0MzRCxhQUFoQztRQUNBO01BQ0Q7TUFFRDtBQUNEO01BRUM7TUFDQTtNQUNBOzs7TUFDQXJLLE9BQU8sQ0FBQzZJLFVBQVIsR0FBcUJ5RCxNQUFNLENBQUMsVUFBVUMsR0FBVixFQUFnQjtRQUMzQ0EsR0FBRyxDQUFDMEIsU0FBSixHQUFnQixHQUFoQjtRQUNBLE9BQU8sQ0FBQzFCLEdBQUcsQ0FBQ2YsWUFBSixDQUFpQixXQUFqQixDQUFSO01BQ0EsQ0FIMEIsQ0FBM0I7TUFLQTtBQUNEO01BRUM7O01BQ0F4TCxPQUFPLENBQUNvTCxvQkFBUixHQUErQmtCLE1BQU0sQ0FBQyxVQUFVQyxHQUFWLEVBQWdCO1FBQ3JEQSxHQUFHLENBQUMyQixXQUFKLENBQWlCaFAsUUFBUSxDQUFDaVAsYUFBVCxDQUF1QixFQUF2QixDQUFqQjtRQUNBLE9BQU8sQ0FBQzVCLEdBQUcsQ0FBQ25CLG9CQUFKLENBQXlCLEdBQXpCLEVBQThCbkssTUFBdEM7TUFDQSxDQUhvQyxDQUFyQyxDQTFDbUQsQ0ErQ25EOztNQUNBakIsT0FBTyxDQUFDcUwsc0JBQVIsR0FBaUM1QixPQUFPLENBQUM4QixJQUFSLENBQWNyTSxRQUFRLENBQUNtTSxzQkFBdkIsQ0FBakMsQ0FoRG1ELENBa0RuRDtNQUNBO01BQ0E7TUFDQTs7TUFDQXJMLE9BQU8sQ0FBQ29PLE9BQVIsR0FBa0I5QixNQUFNLENBQUMsVUFBVUMsR0FBVixFQUFnQjtRQUN4Q2hGLE9BQU8sQ0FBQzJHLFdBQVIsQ0FBcUIzQixHQUFyQixFQUEyQnBCLEVBQTNCLEdBQWdDNUgsT0FBaEM7UUFDQSxPQUFPLENBQUNyRSxRQUFRLENBQUNtUCxpQkFBVixJQUErQixDQUFDblAsUUFBUSxDQUFDbVAsaUJBQVQsQ0FBNEI5SyxPQUE1QixFQUFzQ3RDLE1BQTdFO01BQ0EsQ0FIdUIsQ0FBeEIsQ0F0RG1ELENBMkRuRDs7TUFDQSxJQUFLakIsT0FBTyxDQUFDb08sT0FBYixFQUF1QjtRQUN0QnZILElBQUksQ0FBQ3lILElBQUwsQ0FBVSxJQUFWLElBQWtCLFVBQVVuRCxFQUFWLEVBQWMvSyxPQUFkLEVBQXdCO1VBQ3pDLElBQUssT0FBT0EsT0FBTyxDQUFDOEssY0FBZixLQUFrQyxXQUFsQyxJQUFpRDFELGNBQXRELEVBQXVFO1lBQ3RFLElBQUlpRCxDQUFDLEdBQUdySyxPQUFPLENBQUM4SyxjQUFSLENBQXdCQyxFQUF4QixDQUFSO1lBQ0EsT0FBT1YsQ0FBQyxHQUFHLENBQUVBLENBQUYsQ0FBSCxHQUFXLEVBQW5CO1VBQ0E7UUFDRCxDQUxEOztRQU1BNUQsSUFBSSxDQUFDMEgsTUFBTCxDQUFZLElBQVosSUFBb0IsVUFBVXBELEVBQVYsRUFBZTtVQUNsQyxJQUFJcUQsTUFBTSxHQUFHckQsRUFBRSxDQUFDekgsT0FBSCxDQUFZbUcsU0FBWixFQUF1QkMsU0FBdkIsQ0FBYjtVQUNBLE9BQU8sVUFBVWhJLElBQVYsRUFBaUI7WUFDdkIsT0FBT0EsSUFBSSxDQUFDMEosWUFBTCxDQUFrQixJQUFsQixNQUE0QmdELE1BQW5DO1VBQ0EsQ0FGRDtRQUdBLENBTEQ7TUFNQSxDQWJELE1BYU87UUFDTjtRQUNBO1FBQ0EsT0FBTzNILElBQUksQ0FBQ3lILElBQUwsQ0FBVSxJQUFWLENBQVA7O1FBRUF6SCxJQUFJLENBQUMwSCxNQUFMLENBQVksSUFBWixJQUFxQixVQUFVcEQsRUFBVixFQUFlO1VBQ25DLElBQUlxRCxNQUFNLEdBQUdyRCxFQUFFLENBQUN6SCxPQUFILENBQVltRyxTQUFaLEVBQXVCQyxTQUF2QixDQUFiO1VBQ0EsT0FBTyxVQUFVaEksSUFBVixFQUFpQjtZQUN2QixJQUFJMkwsSUFBSSxHQUFHLE9BQU8zTCxJQUFJLENBQUMyTSxnQkFBWixLQUFpQyxXQUFqQyxJQUNWM00sSUFBSSxDQUFDMk0sZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FERDtZQUVBLE9BQU9oQixJQUFJLElBQUlBLElBQUksQ0FBQ3ZILEtBQUwsS0FBZXNJLE1BQTlCO1VBQ0EsQ0FKRDtRQUtBLENBUEQ7TUFRQSxDQXRGa0QsQ0F3Rm5EOzs7TUFDQTNILElBQUksQ0FBQ3lILElBQUwsQ0FBVSxLQUFWLElBQW1CdE8sT0FBTyxDQUFDb0wsb0JBQVIsR0FDbEIsVUFBVXNELEdBQVYsRUFBZXRPLE9BQWYsRUFBeUI7UUFDeEIsSUFBSyxPQUFPQSxPQUFPLENBQUNnTCxvQkFBZixLQUF3QyxXQUE3QyxFQUEyRDtVQUMxRCxPQUFPaEwsT0FBTyxDQUFDZ0wsb0JBQVIsQ0FBOEJzRCxHQUE5QixDQUFQLENBRDBELENBRzNEO1FBQ0MsQ0FKRCxNQUlPLElBQUsxTyxPQUFPLENBQUNzTCxHQUFiLEVBQW1CO1VBQ3pCLE9BQU9sTCxPQUFPLENBQUMwTCxnQkFBUixDQUEwQjRDLEdBQTFCLENBQVA7UUFDQTtNQUNELENBVGlCLEdBV2xCLFVBQVVBLEdBQVYsRUFBZXRPLE9BQWYsRUFBeUI7UUFDeEIsSUFBSTBCLElBQUo7UUFBQSxJQUNDd0UsR0FBRyxHQUFHLEVBRFA7UUFBQSxJQUVDdkUsQ0FBQyxHQUFHLENBRkw7UUFBQSxJQUdDO1FBQ0F3RCxPQUFPLEdBQUduRixPQUFPLENBQUNnTCxvQkFBUixDQUE4QnNELEdBQTlCLENBSlgsQ0FEd0IsQ0FPeEI7O1FBQ0EsSUFBS0EsR0FBRyxLQUFLLEdBQWIsRUFBbUI7VUFDbEIsT0FBUzVNLElBQUksR0FBR3lELE9BQU8sQ0FBQ3hELENBQUMsRUFBRixDQUF2QixFQUFnQztZQUMvQixJQUFLRCxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO2NBQzFCOEIsR0FBRyxDQUFDNUcsSUFBSixDQUFVb0MsSUFBVjtZQUNBO1VBQ0Q7O1VBRUQsT0FBT3dFLEdBQVA7UUFDQTs7UUFDRCxPQUFPZixPQUFQO01BQ0EsQ0E3QkYsQ0F6Rm1ELENBd0huRDs7TUFDQXNCLElBQUksQ0FBQ3lILElBQUwsQ0FBVSxPQUFWLElBQXFCdE8sT0FBTyxDQUFDcUwsc0JBQVIsSUFBa0MsVUFBVTRDLFNBQVYsRUFBcUI3TixPQUFyQixFQUErQjtRQUNyRixJQUFLLE9BQU9BLE9BQU8sQ0FBQ2lMLHNCQUFmLEtBQTBDLFdBQTFDLElBQXlEN0QsY0FBOUQsRUFBK0U7VUFDOUUsT0FBT3BILE9BQU8sQ0FBQ2lMLHNCQUFSLENBQWdDNEMsU0FBaEMsQ0FBUDtRQUNBO01BQ0QsQ0FKRDtNQU1BO0FBQ0Q7TUFFQztNQUVBOzs7TUFDQXZHLGFBQWEsR0FBRyxFQUFoQixDQXJJbUQsQ0F1SW5EO01BQ0E7TUFDQTtNQUNBO01BQ0E7O01BQ0FELFNBQVMsR0FBRyxFQUFaOztNQUVBLElBQU16SCxPQUFPLENBQUNzTCxHQUFSLEdBQWM3QixPQUFPLENBQUM4QixJQUFSLENBQWNyTSxRQUFRLENBQUM0TSxnQkFBdkIsQ0FBcEIsRUFBaUU7UUFDaEU7UUFDQTtRQUNBUSxNQUFNLENBQUMsVUFBVUMsR0FBVixFQUFnQjtVQUN0QjtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0FoRixPQUFPLENBQUMyRyxXQUFSLENBQXFCM0IsR0FBckIsRUFBMkJvQyxTQUEzQixHQUF1QyxZQUFZcEwsT0FBWixHQUFzQixRQUF0QixHQUN0QyxjQURzQyxHQUNyQkEsT0FEcUIsR0FDWCwyQkFEVyxHQUV0Qyx3Q0FGRCxDQU5zQixDQVV0QjtVQUNBO1VBQ0E7VUFDQTs7VUFDQSxJQUFLZ0osR0FBRyxDQUFDVCxnQkFBSixDQUFxQixzQkFBckIsRUFBNkM3SyxNQUFsRCxFQUEyRDtZQUMxRHdHLFNBQVMsQ0FBQy9ILElBQVYsQ0FBZ0IsV0FBV2lKLFVBQVgsR0FBd0IsY0FBeEM7VUFDQSxDQWhCcUIsQ0FrQnRCO1VBQ0E7OztVQUNBLElBQUssQ0FBQzRELEdBQUcsQ0FBQ1QsZ0JBQUosQ0FBcUIsWUFBckIsRUFBbUM3SyxNQUF6QyxFQUFrRDtZQUNqRHdHLFNBQVMsQ0FBQy9ILElBQVYsQ0FBZ0IsUUFBUWlKLFVBQVIsR0FBcUIsWUFBckIsR0FBb0NELFFBQXBDLEdBQStDLEdBQS9EO1VBQ0EsQ0F0QnFCLENBd0J0Qjs7O1VBQ0EsSUFBSyxDQUFDNkQsR0FBRyxDQUFDVCxnQkFBSixDQUFzQixVQUFVdkksT0FBVixHQUFvQixJQUExQyxFQUFpRHRDLE1BQXZELEVBQWdFO1lBQy9Ed0csU0FBUyxDQUFDL0gsSUFBVixDQUFlLElBQWY7VUFDQSxDQTNCcUIsQ0E2QnRCO1VBQ0E7VUFDQTs7O1VBQ0EsSUFBSyxDQUFDNk0sR0FBRyxDQUFDVCxnQkFBSixDQUFxQixVQUFyQixFQUFpQzdLLE1BQXZDLEVBQWdEO1lBQy9Dd0csU0FBUyxDQUFDL0gsSUFBVixDQUFlLFVBQWY7VUFDQSxDQWxDcUIsQ0FvQ3RCO1VBQ0E7VUFDQTs7O1VBQ0EsSUFBSyxDQUFDNk0sR0FBRyxDQUFDVCxnQkFBSixDQUFzQixPQUFPdkksT0FBUCxHQUFpQixJQUF2QyxFQUE4Q3RDLE1BQXBELEVBQTZEO1lBQzVEd0csU0FBUyxDQUFDL0gsSUFBVixDQUFlLFVBQWY7VUFDQTtRQUNELENBMUNLLENBQU47UUE0Q0E0TSxNQUFNLENBQUMsVUFBVUMsR0FBVixFQUFnQjtVQUN0QjtVQUNBO1VBQ0EsSUFBSXFDLEtBQUssR0FBRzFQLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWjtVQUNBb0MsS0FBSyxDQUFDbkQsWUFBTixDQUFvQixNQUFwQixFQUE0QixRQUE1QjtVQUNBYyxHQUFHLENBQUMyQixXQUFKLENBQWlCVSxLQUFqQixFQUF5Qm5ELFlBQXpCLENBQXVDLE1BQXZDLEVBQStDLEdBQS9DLEVBTHNCLENBT3RCO1VBQ0E7O1VBQ0EsSUFBS2MsR0FBRyxDQUFDVCxnQkFBSixDQUFxQixVQUFyQixFQUFpQzdLLE1BQXRDLEVBQStDO1lBQzlDd0csU0FBUyxDQUFDL0gsSUFBVixDQUFnQixTQUFTaUosVUFBVCxHQUFzQixhQUF0QztVQUNBLENBWHFCLENBYXRCO1VBQ0E7OztVQUNBLElBQUssQ0FBQzRELEdBQUcsQ0FBQ1QsZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUM3SyxNQUF2QyxFQUFnRDtZQUMvQ3dHLFNBQVMsQ0FBQy9ILElBQVYsQ0FBZ0IsVUFBaEIsRUFBNEIsV0FBNUI7VUFDQSxDQWpCcUIsQ0FtQnRCOzs7VUFDQTZNLEdBQUcsQ0FBQ1QsZ0JBQUosQ0FBcUIsTUFBckI7VUFDQXJFLFNBQVMsQ0FBQy9ILElBQVYsQ0FBZSxNQUFmO1FBQ0EsQ0F0QkssQ0FBTjtNQXVCQTs7TUFFRCxJQUFNTSxPQUFPLENBQUM2TyxlQUFSLEdBQTBCcEYsT0FBTyxDQUFDOEIsSUFBUixDQUFleEYsT0FBTyxHQUFHd0IsT0FBTyxDQUFDeEIsT0FBUixJQUN4RHdCLE9BQU8sQ0FBQ3VILHFCQURnRCxJQUV4RHZILE9BQU8sQ0FBQ3dILGtCQUZnRCxJQUd4RHhILE9BQU8sQ0FBQ3lILGdCQUhnRCxJQUl4RHpILE9BQU8sQ0FBQzBILGlCQUp1QixDQUFoQyxFQUlpQztRQUVoQzNDLE1BQU0sQ0FBQyxVQUFVQyxHQUFWLEVBQWdCO1VBQ3RCO1VBQ0E7VUFDQXZNLE9BQU8sQ0FBQ2tQLGlCQUFSLEdBQTRCbkosT0FBTyxDQUFDNUUsSUFBUixDQUFjb0wsR0FBZCxFQUFtQixLQUFuQixDQUE1QixDQUhzQixDQUt0QjtVQUNBOztVQUNBeEcsT0FBTyxDQUFDNUUsSUFBUixDQUFjb0wsR0FBZCxFQUFtQixXQUFuQjtVQUNBN0UsYUFBYSxDQUFDaEksSUFBZCxDQUFvQixJQUFwQixFQUEwQm9KLE9BQTFCO1FBQ0EsQ0FUSyxDQUFOO01BVUE7O01BRURyQixTQUFTLEdBQUdBLFNBQVMsQ0FBQ3hHLE1BQVYsSUFBb0IsSUFBSStILE1BQUosQ0FBWXZCLFNBQVMsQ0FBQ2tFLElBQVYsQ0FBZSxHQUFmLENBQVosQ0FBaEM7TUFDQWpFLGFBQWEsR0FBR0EsYUFBYSxDQUFDekcsTUFBZCxJQUF3QixJQUFJK0gsTUFBSixDQUFZdEIsYUFBYSxDQUFDaUUsSUFBZCxDQUFtQixHQUFuQixDQUFaLENBQXhDO01BRUE7QUFDRDs7TUFDQytCLFVBQVUsR0FBR2pFLE9BQU8sQ0FBQzhCLElBQVIsQ0FBY2hFLE9BQU8sQ0FBQzRILHVCQUF0QixDQUFiLENBN09tRCxDQStPbkQ7TUFDQTtNQUNBOztNQUNBeEgsUUFBUSxHQUFHK0YsVUFBVSxJQUFJakUsT0FBTyxDQUFDOEIsSUFBUixDQUFjaEUsT0FBTyxDQUFDSSxRQUF0QixDQUFkLEdBQ1YsVUFBVVMsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO1FBQ2hCLElBQUkrRyxLQUFLLEdBQUdoSCxDQUFDLENBQUM1RCxRQUFGLEtBQWUsQ0FBZixHQUFtQjRELENBQUMsQ0FBQ29GLGVBQXJCLEdBQXVDcEYsQ0FBbkQ7UUFBQSxJQUNDaUgsR0FBRyxHQUFHaEgsQ0FBQyxJQUFJQSxDQUFDLENBQUN3RCxVQURkO1FBRUEsT0FBT3pELENBQUMsS0FBS2lILEdBQU4sSUFBYSxDQUFDLEVBQUdBLEdBQUcsSUFBSUEsR0FBRyxDQUFDN0ssUUFBSixLQUFpQixDQUF4QixLQUN2QjRLLEtBQUssQ0FBQ3pILFFBQU4sR0FDQ3lILEtBQUssQ0FBQ3pILFFBQU4sQ0FBZ0IwSCxHQUFoQixDQURELEdBRUNqSCxDQUFDLENBQUMrRyx1QkFBRixJQUE2Qi9HLENBQUMsQ0FBQytHLHVCQUFGLENBQTJCRSxHQUEzQixJQUFtQyxFQUgxQyxDQUFILENBQXJCO01BS0EsQ0FUUyxHQVVWLFVBQVVqSCxDQUFWLEVBQWFDLENBQWIsRUFBaUI7UUFDaEIsSUFBS0EsQ0FBTCxFQUFTO1VBQ1IsT0FBU0EsQ0FBQyxHQUFHQSxDQUFDLENBQUN3RCxVQUFmLEVBQTZCO1lBQzVCLElBQUt4RCxDQUFDLEtBQUtELENBQVgsRUFBZTtjQUNkLE9BQU8sSUFBUDtZQUNBO1VBQ0Q7UUFDRDs7UUFDRCxPQUFPLEtBQVA7TUFDQSxDQW5CRjtNQXFCQTtBQUNEO01BRUM7O01BQ0FELFNBQVMsR0FBR3VGLFVBQVUsR0FDdEIsVUFBVXRGLENBQVYsRUFBYUMsQ0FBYixFQUFpQjtRQUVoQjtRQUNBLElBQUtELENBQUMsS0FBS0MsQ0FBWCxFQUFlO1VBQ2RoQixZQUFZLEdBQUcsSUFBZjtVQUNBLE9BQU8sQ0FBUDtRQUNBLENBTmUsQ0FRaEI7OztRQUNBLElBQUlpSSxPQUFPLEdBQUcsQ0FBQ2xILENBQUMsQ0FBQytHLHVCQUFILEdBQTZCLENBQUM5RyxDQUFDLENBQUM4Ryx1QkFBOUM7O1FBQ0EsSUFBS0csT0FBTCxFQUFlO1VBQ2QsT0FBT0EsT0FBUDtRQUNBLENBWmUsQ0FjaEI7OztRQUNBQSxPQUFPLEdBQUcsQ0FBRWxILENBQUMsQ0FBQzRDLGFBQUYsSUFBbUI1QyxDQUFyQixPQUErQkMsQ0FBQyxDQUFDMkMsYUFBRixJQUFtQjNDLENBQWxELElBQ1RELENBQUMsQ0FBQytHLHVCQUFGLENBQTJCOUcsQ0FBM0IsQ0FEUyxHQUdUO1FBQ0EsQ0FKRCxDQWZnQixDQXFCaEI7O1FBQ0EsSUFBS2lILE9BQU8sR0FBRyxDQUFWLElBQ0gsQ0FBQ3RQLE9BQU8sQ0FBQ3VQLFlBQVQsSUFBeUJsSCxDQUFDLENBQUM4Ryx1QkFBRixDQUEyQi9HLENBQTNCLE1BQW1Da0gsT0FEOUQsRUFDeUU7VUFFeEU7VUFDQSxJQUFLbEgsQ0FBQyxLQUFLbEosUUFBTixJQUFrQmtKLENBQUMsQ0FBQzRDLGFBQUYsS0FBb0JwRCxZQUFwQixJQUFvQ0QsUUFBUSxDQUFDQyxZQUFELEVBQWVRLENBQWYsQ0FBbkUsRUFBdUY7WUFDdEYsT0FBTyxDQUFDLENBQVI7VUFDQTs7VUFDRCxJQUFLQyxDQUFDLEtBQUtuSixRQUFOLElBQWtCbUosQ0FBQyxDQUFDMkMsYUFBRixLQUFvQnBELFlBQXBCLElBQW9DRCxRQUFRLENBQUNDLFlBQUQsRUFBZVMsQ0FBZixDQUFuRSxFQUF1RjtZQUN0RixPQUFPLENBQVA7VUFDQSxDQVJ1RSxDQVV4RTs7O1VBQ0EsT0FBT2pCLFNBQVMsR0FDYnpILE9BQU8sQ0FBRXlILFNBQUYsRUFBYWdCLENBQWIsQ0FBUCxHQUEwQnpJLE9BQU8sQ0FBRXlILFNBQUYsRUFBYWlCLENBQWIsQ0FEcEIsR0FFZixDQUZEO1FBR0E7O1FBRUQsT0FBT2lILE9BQU8sR0FBRyxDQUFWLEdBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQTFCO01BQ0EsQ0F6Q3FCLEdBMEN0QixVQUFVbEgsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO1FBQ2hCO1FBQ0EsSUFBS0QsQ0FBQyxLQUFLQyxDQUFYLEVBQWU7VUFDZGhCLFlBQVksR0FBRyxJQUFmO1VBQ0EsT0FBTyxDQUFQO1FBQ0E7O1FBRUQsSUFBSTBGLEdBQUo7UUFBQSxJQUNDaEwsQ0FBQyxHQUFHLENBREw7UUFBQSxJQUVDeU4sR0FBRyxHQUFHcEgsQ0FBQyxDQUFDeUQsVUFGVDtRQUFBLElBR0N3RCxHQUFHLEdBQUdoSCxDQUFDLENBQUN3RCxVQUhUO1FBQUEsSUFJQzRELEVBQUUsR0FBRyxDQUFFckgsQ0FBRixDQUpOO1FBQUEsSUFLQ3NILEVBQUUsR0FBRyxDQUFFckgsQ0FBRixDQUxOLENBUGdCLENBY2hCOztRQUNBLElBQUssQ0FBQ21ILEdBQUQsSUFBUSxDQUFDSCxHQUFkLEVBQW9CO1VBQ25CLE9BQU9qSCxDQUFDLEtBQUtsSixRQUFOLEdBQWlCLENBQUMsQ0FBbEIsR0FDTm1KLENBQUMsS0FBS25KLFFBQU4sR0FBaUIsQ0FBakIsR0FDQXNRLEdBQUcsR0FBRyxDQUFDLENBQUosR0FDSEgsR0FBRyxHQUFHLENBQUgsR0FDSGpJLFNBQVMsR0FDUHpILE9BQU8sQ0FBRXlILFNBQUYsRUFBYWdCLENBQWIsQ0FBUCxHQUEwQnpJLE9BQU8sQ0FBRXlILFNBQUYsRUFBYWlCLENBQWIsQ0FEMUIsR0FFVCxDQU5ELENBRG1CLENBU3BCO1FBQ0MsQ0FWRCxNQVVPLElBQUttSCxHQUFHLEtBQUtILEdBQWIsRUFBbUI7VUFDekIsT0FBT3ZDLFlBQVksQ0FBRTFFLENBQUYsRUFBS0MsQ0FBTCxDQUFuQjtRQUNBLENBM0JlLENBNkJoQjs7O1FBQ0EwRSxHQUFHLEdBQUczRSxDQUFOOztRQUNBLE9BQVMyRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ2xCLFVBQW5CLEVBQWlDO1VBQ2hDNEQsRUFBRSxDQUFDRSxPQUFILENBQVk1QyxHQUFaO1FBQ0E7O1FBQ0RBLEdBQUcsR0FBRzFFLENBQU47O1FBQ0EsT0FBUzBFLEdBQUcsR0FBR0EsR0FBRyxDQUFDbEIsVUFBbkIsRUFBaUM7VUFDaEM2RCxFQUFFLENBQUNDLE9BQUgsQ0FBWTVDLEdBQVo7UUFDQSxDQXJDZSxDQXVDaEI7OztRQUNBLE9BQVEwQyxFQUFFLENBQUMxTixDQUFELENBQUYsS0FBVTJOLEVBQUUsQ0FBQzNOLENBQUQsQ0FBcEIsRUFBMEI7VUFDekJBLENBQUM7UUFDRDs7UUFFRCxPQUFPQSxDQUFDLEdBQ1A7UUFDQStLLFlBQVksQ0FBRTJDLEVBQUUsQ0FBQzFOLENBQUQsQ0FBSixFQUFTMk4sRUFBRSxDQUFDM04sQ0FBRCxDQUFYLENBRkwsR0FJUDtRQUNBME4sRUFBRSxDQUFDMU4sQ0FBRCxDQUFGLEtBQVU2RixZQUFWLEdBQXlCLENBQUMsQ0FBMUIsR0FDQThILEVBQUUsQ0FBQzNOLENBQUQsQ0FBRixLQUFVNkYsWUFBVixHQUF5QixDQUF6QixHQUNBLENBUEQ7TUFRQSxDQTlGRDtNQWdHQSxPQUFPMUksUUFBUDtJQUNBLENBNVdEOztJQThXQTBILE1BQU0sQ0FBQ2IsT0FBUCxHQUFpQixVQUFVNkosSUFBVixFQUFnQkMsUUFBaEIsRUFBMkI7TUFDM0MsT0FBT2pKLE1BQU0sQ0FBRWdKLElBQUYsRUFBUSxJQUFSLEVBQWMsSUFBZCxFQUFvQkMsUUFBcEIsQ0FBYjtJQUNBLENBRkQ7O0lBSUFqSixNQUFNLENBQUNpSSxlQUFQLEdBQXlCLFVBQVUvTSxJQUFWLEVBQWdCOE4sSUFBaEIsRUFBdUI7TUFDL0M7TUFDQSxJQUFLLENBQUU5TixJQUFJLENBQUNrSixhQUFMLElBQXNCbEosSUFBeEIsTUFBbUM1QyxRQUF4QyxFQUFtRDtRQUNsRG9JLFdBQVcsQ0FBRXhGLElBQUYsQ0FBWDtNQUNBLENBSjhDLENBTS9DOzs7TUFDQThOLElBQUksR0FBR0EsSUFBSSxDQUFDbE0sT0FBTCxDQUFjeUYsZ0JBQWQsRUFBZ0MsUUFBaEMsQ0FBUDs7TUFFQSxJQUFLbkosT0FBTyxDQUFDNk8sZUFBUixJQUEyQnJILGNBQTNCLElBQ0osQ0FBQ1UsYUFBYSxDQUFFMEgsSUFBSSxHQUFHLEdBQVQsQ0FEVixLQUVGLENBQUNsSSxhQUFELElBQWtCLENBQUNBLGFBQWEsQ0FBQzZELElBQWQsQ0FBb0JxRSxJQUFwQixDQUZqQixNQUdGLENBQUNuSSxTQUFELElBQWtCLENBQUNBLFNBQVMsQ0FBQzhELElBQVYsQ0FBZ0JxRSxJQUFoQixDQUhqQixDQUFMLEVBR2lEO1FBRWhELElBQUk7VUFDSCxJQUFJcE8sR0FBRyxHQUFHdUUsT0FBTyxDQUFDNUUsSUFBUixDQUFjVyxJQUFkLEVBQW9COE4sSUFBcEIsQ0FBVixDQURHLENBR0g7O1VBQ0EsSUFBS3BPLEdBQUcsSUFBSXhCLE9BQU8sQ0FBQ2tQLGlCQUFmLElBQ0g7VUFDQTtVQUNBcE4sSUFBSSxDQUFDNUMsUUFBTCxJQUFpQjRDLElBQUksQ0FBQzVDLFFBQUwsQ0FBY3NGLFFBQWQsS0FBMkIsRUFIOUMsRUFHbUQ7WUFDbEQsT0FBT2hELEdBQVA7VUFDQTtRQUNELENBVkQsQ0FVRSxPQUFPaUQsQ0FBUCxFQUFVLENBQUU7TUFDZDs7TUFFRCxPQUFPbUMsTUFBTSxDQUFFZ0osSUFBRixFQUFRMVEsUUFBUixFQUFrQixJQUFsQixFQUF3QixDQUFFNEMsSUFBRixDQUF4QixDQUFOLENBQXlDYixNQUF6QyxHQUFrRCxDQUF6RDtJQUNBLENBNUJEOztJQThCQTJGLE1BQU0sQ0FBQ2UsUUFBUCxHQUFrQixVQUFVdkgsT0FBVixFQUFtQjBCLElBQW5CLEVBQTBCO01BQzNDO01BQ0EsSUFBSyxDQUFFMUIsT0FBTyxDQUFDNEssYUFBUixJQUF5QjVLLE9BQTNCLE1BQXlDbEIsUUFBOUMsRUFBeUQ7UUFDeERvSSxXQUFXLENBQUVsSCxPQUFGLENBQVg7TUFDQTs7TUFDRCxPQUFPdUgsUUFBUSxDQUFFdkgsT0FBRixFQUFXMEIsSUFBWCxDQUFmO0lBQ0EsQ0FORDs7SUFRQThFLE1BQU0sQ0FBQ2tKLElBQVAsR0FBYyxVQUFVaE8sSUFBVixFQUFnQmdCLElBQWhCLEVBQXVCO01BQ3BDO01BQ0EsSUFBSyxDQUFFaEIsSUFBSSxDQUFDa0osYUFBTCxJQUFzQmxKLElBQXhCLE1BQW1DNUMsUUFBeEMsRUFBbUQ7UUFDbERvSSxXQUFXLENBQUV4RixJQUFGLENBQVg7TUFDQTs7TUFFRCxJQUFJekIsRUFBRSxHQUFHd0csSUFBSSxDQUFDZ0csVUFBTCxDQUFpQi9KLElBQUksQ0FBQ29DLFdBQUwsRUFBakIsQ0FBVDtNQUFBLElBQ0M7TUFDQTZLLEdBQUcsR0FBRzFQLEVBQUUsSUFBSVAsTUFBTSxDQUFDcUIsSUFBUCxDQUFhMEYsSUFBSSxDQUFDZ0csVUFBbEIsRUFBOEIvSixJQUFJLENBQUNvQyxXQUFMLEVBQTlCLENBQU4sR0FDTDdFLEVBQUUsQ0FBRXlCLElBQUYsRUFBUWdCLElBQVIsRUFBYyxDQUFDMEUsY0FBZixDQURHLEdBRUxsRSxTQUpGO01BTUEsT0FBT3lNLEdBQUcsS0FBS3pNLFNBQVIsR0FDTnlNLEdBRE0sR0FFTi9QLE9BQU8sQ0FBQzZJLFVBQVIsSUFBc0IsQ0FBQ3JCLGNBQXZCLEdBQ0MxRixJQUFJLENBQUMwSixZQUFMLENBQW1CMUksSUFBbkIsQ0FERCxHQUVDLENBQUNpTixHQUFHLEdBQUdqTyxJQUFJLENBQUMyTSxnQkFBTCxDQUFzQjNMLElBQXRCLENBQVAsS0FBdUNpTixHQUFHLENBQUNDLFNBQTNDLEdBQ0NELEdBQUcsQ0FBQzdKLEtBREwsR0FFQyxJQU5IO0lBT0EsQ0FuQkQ7O0lBcUJBVSxNQUFNLENBQUNoRCxLQUFQLEdBQWUsVUFBVUMsR0FBVixFQUFnQjtNQUM5QixNQUFNLElBQUl6RSxLQUFKLENBQVcsNENBQTRDeUUsR0FBdkQsQ0FBTjtJQUNBLENBRkQ7SUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0ErQyxNQUFNLENBQUNxSixVQUFQLEdBQW9CLFVBQVUxSyxPQUFWLEVBQW9CO01BQ3ZDLElBQUl6RCxJQUFKO01BQUEsSUFDQ29PLFVBQVUsR0FBRyxFQURkO01BQUEsSUFFQzVOLENBQUMsR0FBRyxDQUZMO01BQUEsSUFHQ1AsQ0FBQyxHQUFHLENBSEwsQ0FEdUMsQ0FNdkM7O01BQ0FzRixZQUFZLEdBQUcsQ0FBQ3JILE9BQU8sQ0FBQ21RLGdCQUF4QjtNQUNBL0ksU0FBUyxHQUFHLENBQUNwSCxPQUFPLENBQUNvUSxVQUFULElBQXVCN0ssT0FBTyxDQUFDL0YsS0FBUixDQUFlLENBQWYsQ0FBbkM7TUFDQStGLE9BQU8sQ0FBQy9DLElBQVIsQ0FBYzJGLFNBQWQ7O01BRUEsSUFBS2QsWUFBTCxFQUFvQjtRQUNuQixPQUFTdkYsSUFBSSxHQUFHeUQsT0FBTyxDQUFDeEQsQ0FBQyxFQUFGLENBQXZCLEVBQWdDO1VBQy9CLElBQUtELElBQUksS0FBS3lELE9BQU8sQ0FBRXhELENBQUYsQ0FBckIsRUFBNkI7WUFDNUJPLENBQUMsR0FBRzROLFVBQVUsQ0FBQ3hRLElBQVgsQ0FBaUJxQyxDQUFqQixDQUFKO1VBQ0E7UUFDRDs7UUFDRCxPQUFRTyxDQUFDLEVBQVQsRUFBYztVQUNiaUQsT0FBTyxDQUFDOUMsTUFBUixDQUFnQnlOLFVBQVUsQ0FBRTVOLENBQUYsQ0FBMUIsRUFBaUMsQ0FBakM7UUFDQTtNQUNELENBcEJzQyxDQXNCdkM7TUFDQTs7O01BQ0E4RSxTQUFTLEdBQUcsSUFBWjtNQUVBLE9BQU83QixPQUFQO0lBQ0EsQ0EzQkQ7SUE2QkE7QUFDQTtBQUNBO0FBQ0E7OztJQUNBdUIsT0FBTyxHQUFHRixNQUFNLENBQUNFLE9BQVAsR0FBaUIsVUFBVWhGLElBQVYsRUFBaUI7TUFDM0MsSUFBSTJMLElBQUo7TUFBQSxJQUNDak0sR0FBRyxHQUFHLEVBRFA7TUFBQSxJQUVDTyxDQUFDLEdBQUcsQ0FGTDtNQUFBLElBR0N5QyxRQUFRLEdBQUcxQyxJQUFJLENBQUMwQyxRQUhqQjs7TUFLQSxJQUFLLENBQUNBLFFBQU4sRUFBaUI7UUFDaEI7UUFDQSxPQUFTaUosSUFBSSxHQUFHM0wsSUFBSSxDQUFDQyxDQUFDLEVBQUYsQ0FBcEIsRUFBNkI7VUFDNUI7VUFDQVAsR0FBRyxJQUFJc0YsT0FBTyxDQUFFMkcsSUFBRixDQUFkO1FBQ0E7TUFDRCxDQU5ELE1BTU8sSUFBS2pKLFFBQVEsS0FBSyxDQUFiLElBQWtCQSxRQUFRLEtBQUssQ0FBL0IsSUFBb0NBLFFBQVEsS0FBSyxFQUF0RCxFQUEyRDtRQUNqRTtRQUNBO1FBQ0EsSUFBSyxPQUFPMUMsSUFBSSxDQUFDdU8sV0FBWixLQUE0QixRQUFqQyxFQUE0QztVQUMzQyxPQUFPdk8sSUFBSSxDQUFDdU8sV0FBWjtRQUNBLENBRkQsTUFFTztVQUNOO1VBQ0EsS0FBTXZPLElBQUksR0FBR0EsSUFBSSxDQUFDd08sVUFBbEIsRUFBOEJ4TyxJQUE5QixFQUFvQ0EsSUFBSSxHQUFHQSxJQUFJLENBQUNvTCxXQUFoRCxFQUE4RDtZQUM3RDFMLEdBQUcsSUFBSXNGLE9BQU8sQ0FBRWhGLElBQUYsQ0FBZDtVQUNBO1FBQ0Q7TUFDRCxDQVhNLE1BV0EsSUFBSzBDLFFBQVEsS0FBSyxDQUFiLElBQWtCQSxRQUFRLEtBQUssQ0FBcEMsRUFBd0M7UUFDOUMsT0FBTzFDLElBQUksQ0FBQ3lPLFNBQVo7TUFDQSxDQXpCMEMsQ0EwQjNDOzs7TUFFQSxPQUFPL08sR0FBUDtJQUNBLENBN0JEOztJQStCQXFGLElBQUksR0FBR0QsTUFBTSxDQUFDNEosU0FBUCxHQUFtQjtNQUV6QjtNQUNBckUsV0FBVyxFQUFFLEVBSFk7TUFLekJzRSxZQUFZLEVBQUVwRSxZQUxXO01BT3pCekIsS0FBSyxFQUFFdEIsU0FQa0I7TUFTekJ1RCxVQUFVLEVBQUUsRUFUYTtNQVd6QnlCLElBQUksRUFBRSxFQVhtQjtNQWF6Qm9DLFFBQVEsRUFBRTtRQUNULEtBQUs7VUFBRUMsR0FBRyxFQUFFLFlBQVA7VUFBcUJ6TyxLQUFLLEVBQUU7UUFBNUIsQ0FESTtRQUVULEtBQUs7VUFBRXlPLEdBQUcsRUFBRTtRQUFQLENBRkk7UUFHVCxLQUFLO1VBQUVBLEdBQUcsRUFBRSxpQkFBUDtVQUEwQnpPLEtBQUssRUFBRTtRQUFqQyxDQUhJO1FBSVQsS0FBSztVQUFFeU8sR0FBRyxFQUFFO1FBQVA7TUFKSSxDQWJlO01Bb0J6QkMsU0FBUyxFQUFFO1FBQ1YsUUFBUSxjQUFVaEcsS0FBVixFQUFrQjtVQUN6QkEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsSCxPQUFULENBQWtCbUcsU0FBbEIsRUFBNkJDLFNBQTdCLENBQVgsQ0FEeUIsQ0FHekI7O1VBQ0FjLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxDQUFFQSxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVlBLEtBQUssQ0FBQyxDQUFELENBQWpCLElBQXdCQSxLQUFLLENBQUMsQ0FBRCxDQUE3QixJQUFvQyxFQUF0QyxFQUEyQ2xILE9BQTNDLENBQW9EbUcsU0FBcEQsRUFBK0RDLFNBQS9ELENBQVg7O1VBRUEsSUFBS2MsS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhLElBQWxCLEVBQXlCO1lBQ3hCQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsTUFBTUEsS0FBSyxDQUFDLENBQUQsQ0FBWCxHQUFpQixHQUE1QjtVQUNBOztVQUVELE9BQU9BLEtBQUssQ0FBQ3BMLEtBQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBQVA7UUFDQSxDQVpTO1FBY1YsU0FBUyxlQUFVb0wsS0FBVixFQUFrQjtVQUMxQjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtVQUNHQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzFGLFdBQVQsRUFBWDs7VUFFQSxJQUFLMEYsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTcEwsS0FBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixNQUEyQixLQUFoQyxFQUF3QztZQUN2QztZQUNBLElBQUssQ0FBQ29MLEtBQUssQ0FBQyxDQUFELENBQVgsRUFBaUI7Y0FDaEJoRSxNQUFNLENBQUNoRCxLQUFQLENBQWNnSCxLQUFLLENBQUMsQ0FBRCxDQUFuQjtZQUNBLENBSnNDLENBTXZDO1lBQ0E7OztZQUNBQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsRUFBR0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVlBLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxDQUF4QixDQUFYLEdBQXdDLEtBQU1BLEtBQUssQ0FBQyxDQUFELENBQUwsS0FBYSxNQUFiLElBQXVCQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsS0FBMUMsQ0FBM0MsQ0FBWDtZQUNBQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsRUFBS0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFsQixJQUEyQkEsS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhLEtBQTNDLENBQVgsQ0FUdUMsQ0FXeEM7VUFDQyxDQVpELE1BWU8sSUFBS0EsS0FBSyxDQUFDLENBQUQsQ0FBVixFQUFnQjtZQUN0QmhFLE1BQU0sQ0FBQ2hELEtBQVAsQ0FBY2dILEtBQUssQ0FBQyxDQUFELENBQW5CO1VBQ0E7O1VBRUQsT0FBT0EsS0FBUDtRQUNBLENBNUNTO1FBOENWLFVBQVUsZ0JBQVVBLEtBQVYsRUFBa0I7VUFDM0IsSUFBSWlHLE1BQUo7VUFBQSxJQUNDQyxRQUFRLEdBQUcsQ0FBQ2xHLEtBQUssQ0FBQyxDQUFELENBQU4sSUFBYUEsS0FBSyxDQUFDLENBQUQsQ0FEOUI7O1VBR0EsSUFBS3RCLFNBQVMsQ0FBQyxPQUFELENBQVQsQ0FBbUJpQyxJQUFuQixDQUF5QlgsS0FBSyxDQUFDLENBQUQsQ0FBOUIsQ0FBTCxFQUEyQztZQUMxQyxPQUFPLElBQVA7VUFDQSxDQU4wQixDQVEzQjs7O1VBQ0EsSUFBS0EsS0FBSyxDQUFDLENBQUQsQ0FBVixFQUFnQjtZQUNmQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWUEsS0FBSyxDQUFDLENBQUQsQ0FBakIsSUFBd0IsRUFBbkMsQ0FEZSxDQUdoQjtVQUNDLENBSkQsTUFJTyxJQUFLa0csUUFBUSxJQUFJMUgsT0FBTyxDQUFDbUMsSUFBUixDQUFjdUYsUUFBZCxDQUFaLE1BQ1g7VUFDQ0QsTUFBTSxHQUFHN0osUUFBUSxDQUFFOEosUUFBRixFQUFZLElBQVosQ0FGUCxPQUdYO1VBQ0NELE1BQU0sR0FBR0MsUUFBUSxDQUFDblIsT0FBVCxDQUFrQixHQUFsQixFQUF1Qm1SLFFBQVEsQ0FBQzdQLE1BQVQsR0FBa0I0UCxNQUF6QyxJQUFvREMsUUFBUSxDQUFDN1AsTUFKNUQsQ0FBTCxFQUkyRTtZQUVqRjtZQUNBMkosS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNwTCxLQUFULENBQWdCLENBQWhCLEVBQW1CcVIsTUFBbkIsQ0FBWDtZQUNBakcsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXa0csUUFBUSxDQUFDdFIsS0FBVCxDQUFnQixDQUFoQixFQUFtQnFSLE1BQW5CLENBQVg7VUFDQSxDQXRCMEIsQ0F3QjNCOzs7VUFDQSxPQUFPakcsS0FBSyxDQUFDcEwsS0FBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBUDtRQUNBO01BeEVTLENBcEJjO01BK0Z6QitPLE1BQU0sRUFBRTtRQUVQLE9BQU8sYUFBVXdDLGdCQUFWLEVBQTZCO1VBQ25DLElBQUk5TCxRQUFRLEdBQUc4TCxnQkFBZ0IsQ0FBQ3JOLE9BQWpCLENBQTBCbUcsU0FBMUIsRUFBcUNDLFNBQXJDLEVBQWlENUUsV0FBakQsRUFBZjtVQUNBLE9BQU82TCxnQkFBZ0IsS0FBSyxHQUFyQixHQUNOLFlBQVc7WUFBRSxPQUFPLElBQVA7VUFBYyxDQURyQixHQUVOLFVBQVVqUCxJQUFWLEVBQWlCO1lBQ2hCLE9BQU9BLElBQUksQ0FBQ21ELFFBQUwsSUFBaUJuRCxJQUFJLENBQUNtRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0NELFFBQXhEO1VBQ0EsQ0FKRjtRQUtBLENBVE07UUFXUCxTQUFTLGVBQVVnSixTQUFWLEVBQXNCO1VBQzlCLElBQUkrQyxPQUFPLEdBQUdqSixVQUFVLENBQUVrRyxTQUFTLEdBQUcsR0FBZCxDQUF4QjtVQUVBLE9BQU8rQyxPQUFPLElBQ2IsQ0FBQ0EsT0FBTyxHQUFHLElBQUloSSxNQUFKLENBQVksUUFBUUwsVUFBUixHQUFxQixHQUFyQixHQUEyQnNGLFNBQTNCLEdBQXVDLEdBQXZDLEdBQTZDdEYsVUFBN0MsR0FBMEQsS0FBdEUsQ0FBWCxLQUNBWixVQUFVLENBQUVrRyxTQUFGLEVBQWEsVUFBVW5NLElBQVYsRUFBaUI7WUFDdkMsT0FBT2tQLE9BQU8sQ0FBQ3pGLElBQVIsQ0FBYyxPQUFPekosSUFBSSxDQUFDbU0sU0FBWixLQUEwQixRQUExQixJQUFzQ25NLElBQUksQ0FBQ21NLFNBQTNDLElBQXdELE9BQU9uTSxJQUFJLENBQUMwSixZQUFaLEtBQTZCLFdBQTdCLElBQTRDMUosSUFBSSxDQUFDMEosWUFBTCxDQUFrQixPQUFsQixDQUFwRyxJQUFrSSxFQUFoSixDQUFQO1VBQ0EsQ0FGUyxDQUZYO1FBS0EsQ0FuQk07UUFxQlAsUUFBUSxjQUFVMUksSUFBVixFQUFnQm1PLFFBQWhCLEVBQTBCQyxLQUExQixFQUFrQztVQUN6QyxPQUFPLFVBQVVwUCxJQUFWLEVBQWlCO1lBQ3ZCLElBQUlxUCxNQUFNLEdBQUd2SyxNQUFNLENBQUNrSixJQUFQLENBQWFoTyxJQUFiLEVBQW1CZ0IsSUFBbkIsQ0FBYjs7WUFFQSxJQUFLcU8sTUFBTSxJQUFJLElBQWYsRUFBc0I7Y0FDckIsT0FBT0YsUUFBUSxLQUFLLElBQXBCO1lBQ0E7O1lBQ0QsSUFBSyxDQUFDQSxRQUFOLEVBQWlCO2NBQ2hCLE9BQU8sSUFBUDtZQUNBOztZQUVERSxNQUFNLElBQUksRUFBVjtZQUVBLE9BQU9GLFFBQVEsS0FBSyxHQUFiLEdBQW1CRSxNQUFNLEtBQUtELEtBQTlCLEdBQ05ELFFBQVEsS0FBSyxJQUFiLEdBQW9CRSxNQUFNLEtBQUtELEtBQS9CLEdBQ0FELFFBQVEsS0FBSyxJQUFiLEdBQW9CQyxLQUFLLElBQUlDLE1BQU0sQ0FBQ3hSLE9BQVAsQ0FBZ0J1UixLQUFoQixNQUE0QixDQUF6RCxHQUNBRCxRQUFRLEtBQUssSUFBYixHQUFvQkMsS0FBSyxJQUFJQyxNQUFNLENBQUN4UixPQUFQLENBQWdCdVIsS0FBaEIsSUFBMEIsQ0FBQyxDQUF4RCxHQUNBRCxRQUFRLEtBQUssSUFBYixHQUFvQkMsS0FBSyxJQUFJQyxNQUFNLENBQUMzUixLQUFQLENBQWMsQ0FBQzBSLEtBQUssQ0FBQ2pRLE1BQXJCLE1BQWtDaVEsS0FBL0QsR0FDQUQsUUFBUSxLQUFLLElBQWIsR0FBb0IsQ0FBRSxNQUFNRSxNQUFNLENBQUN6TixPQUFQLENBQWdCcUYsV0FBaEIsRUFBNkIsR0FBN0IsQ0FBTixHQUEyQyxHQUE3QyxFQUFtRHBKLE9BQW5ELENBQTREdVIsS0FBNUQsSUFBc0UsQ0FBQyxDQUEzRixHQUNBRCxRQUFRLEtBQUssSUFBYixHQUFvQkUsTUFBTSxLQUFLRCxLQUFYLElBQW9CQyxNQUFNLENBQUMzUixLQUFQLENBQWMsQ0FBZCxFQUFpQjBSLEtBQUssQ0FBQ2pRLE1BQU4sR0FBZSxDQUFoQyxNQUF3Q2lRLEtBQUssR0FBRyxHQUF4RixHQUNBLEtBUEQ7VUFRQSxDQXBCRDtRQXFCQSxDQTNDTTtRQTZDUCxTQUFTLGVBQVVsTixJQUFWLEVBQWdCb04sSUFBaEIsRUFBc0I5RCxRQUF0QixFQUFnQ3BMLEtBQWhDLEVBQXVDRSxJQUF2QyxFQUE4QztVQUN0RCxJQUFJaVAsTUFBTSxHQUFHck4sSUFBSSxDQUFDeEUsS0FBTCxDQUFZLENBQVosRUFBZSxDQUFmLE1BQXVCLEtBQXBDO1VBQUEsSUFDQzhSLE9BQU8sR0FBR3ROLElBQUksQ0FBQ3hFLEtBQUwsQ0FBWSxDQUFDLENBQWIsTUFBcUIsTUFEaEM7VUFBQSxJQUVDK1IsTUFBTSxHQUFHSCxJQUFJLEtBQUssU0FGbkI7VUFJQSxPQUFPbFAsS0FBSyxLQUFLLENBQVYsSUFBZUUsSUFBSSxLQUFLLENBQXhCLEdBRU47VUFDQSxVQUFVTixJQUFWLEVBQWlCO1lBQ2hCLE9BQU8sQ0FBQyxDQUFDQSxJQUFJLENBQUMrSixVQUFkO1VBQ0EsQ0FMSyxHQU9OLFVBQVUvSixJQUFWLEVBQWdCMUIsT0FBaEIsRUFBeUJvUixHQUF6QixFQUErQjtZQUM5QixJQUFJdEYsS0FBSjtZQUFBLElBQVd1RixXQUFYO1lBQUEsSUFBd0JDLFVBQXhCO1lBQUEsSUFBb0NqRSxJQUFwQztZQUFBLElBQTBDa0UsU0FBMUM7WUFBQSxJQUFxREMsS0FBckQ7WUFBQSxJQUNDakIsR0FBRyxHQUFHVSxNQUFNLEtBQUtDLE9BQVgsR0FBcUIsYUFBckIsR0FBcUMsaUJBRDVDO1lBQUEsSUFFQzNELE1BQU0sR0FBRzdMLElBQUksQ0FBQytKLFVBRmY7WUFBQSxJQUdDL0ksSUFBSSxHQUFHeU8sTUFBTSxJQUFJelAsSUFBSSxDQUFDbUQsUUFBTCxDQUFjQyxXQUFkLEVBSGxCO1lBQUEsSUFJQzJNLFFBQVEsR0FBRyxDQUFDTCxHQUFELElBQVEsQ0FBQ0QsTUFKckI7WUFBQSxJQUtDdkUsSUFBSSxHQUFHLEtBTFI7O1lBT0EsSUFBS1csTUFBTCxFQUFjO2NBRWI7Y0FDQSxJQUFLMEQsTUFBTCxFQUFjO2dCQUNiLE9BQVFWLEdBQVIsRUFBYztrQkFDYmxELElBQUksR0FBRzNMLElBQVA7O2tCQUNBLE9BQVMyTCxJQUFJLEdBQUdBLElBQUksQ0FBRWtELEdBQUYsQ0FBcEIsRUFBK0I7b0JBQzlCLElBQUtZLE1BQU0sR0FDVjlELElBQUksQ0FBQ3hJLFFBQUwsQ0FBY0MsV0FBZCxPQUFnQ3BDLElBRHRCLEdBRVYySyxJQUFJLENBQUNqSixRQUFMLEtBQWtCLENBRm5CLEVBRXVCO3NCQUV0QixPQUFPLEtBQVA7b0JBQ0E7a0JBQ0QsQ0FUWSxDQVViOzs7a0JBQ0FvTixLQUFLLEdBQUdqQixHQUFHLEdBQUczTSxJQUFJLEtBQUssTUFBVCxJQUFtQixDQUFDNE4sS0FBcEIsSUFBNkIsYUFBM0M7Z0JBQ0E7O2dCQUNELE9BQU8sSUFBUDtjQUNBOztjQUVEQSxLQUFLLEdBQUcsQ0FBRU4sT0FBTyxHQUFHM0QsTUFBTSxDQUFDMkMsVUFBVixHQUF1QjNDLE1BQU0sQ0FBQ21FLFNBQXZDLENBQVIsQ0FwQmEsQ0FzQmI7O2NBQ0EsSUFBS1IsT0FBTyxJQUFJTyxRQUFoQixFQUEyQjtnQkFFMUI7Z0JBRUE7Z0JBQ0FwRSxJQUFJLEdBQUdFLE1BQVA7Z0JBQ0ErRCxVQUFVLEdBQUdqRSxJQUFJLENBQUVsSyxPQUFGLENBQUosS0FBb0JrSyxJQUFJLENBQUVsSyxPQUFGLENBQUosR0FBa0IsRUFBdEMsQ0FBYixDQU4wQixDQVExQjtnQkFDQTs7Z0JBQ0FrTyxXQUFXLEdBQUdDLFVBQVUsQ0FBRWpFLElBQUksQ0FBQ3NFLFFBQVAsQ0FBVixLQUNaTCxVQUFVLENBQUVqRSxJQUFJLENBQUNzRSxRQUFQLENBQVYsR0FBOEIsRUFEbEIsQ0FBZDtnQkFHQTdGLEtBQUssR0FBR3VGLFdBQVcsQ0FBRXpOLElBQUYsQ0FBWCxJQUF1QixFQUEvQjtnQkFDQTJOLFNBQVMsR0FBR3pGLEtBQUssQ0FBRSxDQUFGLENBQUwsS0FBZXJFLE9BQWYsSUFBMEJxRSxLQUFLLENBQUUsQ0FBRixDQUEzQztnQkFDQWMsSUFBSSxHQUFHMkUsU0FBUyxJQUFJekYsS0FBSyxDQUFFLENBQUYsQ0FBekI7Z0JBQ0F1QixJQUFJLEdBQUdrRSxTQUFTLElBQUloRSxNQUFNLENBQUNyRCxVQUFQLENBQW1CcUgsU0FBbkIsQ0FBcEI7O2dCQUVBLE9BQVNsRSxJQUFJLEdBQUcsRUFBRWtFLFNBQUYsSUFBZWxFLElBQWYsSUFBdUJBLElBQUksQ0FBRWtELEdBQUYsQ0FBM0IsTUFFZjtnQkFDQzNELElBQUksR0FBRzJFLFNBQVMsR0FBRyxDQUhMLEtBR1dDLEtBQUssQ0FBQ3JKLEdBQU4sRUFIM0IsRUFHMEM7a0JBRXpDO2tCQUNBLElBQUtrRixJQUFJLENBQUNqSixRQUFMLEtBQWtCLENBQWxCLElBQXVCLEVBQUV3SSxJQUF6QixJQUFpQ1MsSUFBSSxLQUFLM0wsSUFBL0MsRUFBc0Q7b0JBQ3JEMlAsV0FBVyxDQUFFek4sSUFBRixDQUFYLEdBQXNCLENBQUU2RCxPQUFGLEVBQVc4SixTQUFYLEVBQXNCM0UsSUFBdEIsQ0FBdEI7b0JBQ0E7a0JBQ0E7Z0JBQ0Q7Y0FFRCxDQTlCRCxNQThCTztnQkFDTjtnQkFDQSxJQUFLNkUsUUFBTCxFQUFnQjtrQkFDZjtrQkFDQXBFLElBQUksR0FBRzNMLElBQVA7a0JBQ0E0UCxVQUFVLEdBQUdqRSxJQUFJLENBQUVsSyxPQUFGLENBQUosS0FBb0JrSyxJQUFJLENBQUVsSyxPQUFGLENBQUosR0FBa0IsRUFBdEMsQ0FBYixDQUhlLENBS2Y7a0JBQ0E7O2tCQUNBa08sV0FBVyxHQUFHQyxVQUFVLENBQUVqRSxJQUFJLENBQUNzRSxRQUFQLENBQVYsS0FDWkwsVUFBVSxDQUFFakUsSUFBSSxDQUFDc0UsUUFBUCxDQUFWLEdBQThCLEVBRGxCLENBQWQ7a0JBR0E3RixLQUFLLEdBQUd1RixXQUFXLENBQUV6TixJQUFGLENBQVgsSUFBdUIsRUFBL0I7a0JBQ0EyTixTQUFTLEdBQUd6RixLQUFLLENBQUUsQ0FBRixDQUFMLEtBQWVyRSxPQUFmLElBQTBCcUUsS0FBSyxDQUFFLENBQUYsQ0FBM0M7a0JBQ0FjLElBQUksR0FBRzJFLFNBQVA7Z0JBQ0EsQ0FmSyxDQWlCTjtnQkFDQTs7O2dCQUNBLElBQUszRSxJQUFJLEtBQUssS0FBZCxFQUFzQjtrQkFDckI7a0JBQ0EsT0FBU1MsSUFBSSxHQUFHLEVBQUVrRSxTQUFGLElBQWVsRSxJQUFmLElBQXVCQSxJQUFJLENBQUVrRCxHQUFGLENBQTNCLEtBQ2QzRCxJQUFJLEdBQUcyRSxTQUFTLEdBQUcsQ0FETCxLQUNXQyxLQUFLLENBQUNySixHQUFOLEVBRDNCLEVBQzBDO29CQUV6QyxJQUFLLENBQUVnSixNQUFNLEdBQ1o5RCxJQUFJLENBQUN4SSxRQUFMLENBQWNDLFdBQWQsT0FBZ0NwQyxJQURwQixHQUVaMkssSUFBSSxDQUFDakosUUFBTCxLQUFrQixDQUZkLEtBR0osRUFBRXdJLElBSEgsRUFHVTtzQkFFVDtzQkFDQSxJQUFLNkUsUUFBTCxFQUFnQjt3QkFDZkgsVUFBVSxHQUFHakUsSUFBSSxDQUFFbEssT0FBRixDQUFKLEtBQW9Ca0ssSUFBSSxDQUFFbEssT0FBRixDQUFKLEdBQWtCLEVBQXRDLENBQWIsQ0FEZSxDQUdmO3dCQUNBOzt3QkFDQWtPLFdBQVcsR0FBR0MsVUFBVSxDQUFFakUsSUFBSSxDQUFDc0UsUUFBUCxDQUFWLEtBQ1pMLFVBQVUsQ0FBRWpFLElBQUksQ0FBQ3NFLFFBQVAsQ0FBVixHQUE4QixFQURsQixDQUFkO3dCQUdBTixXQUFXLENBQUV6TixJQUFGLENBQVgsR0FBc0IsQ0FBRTZELE9BQUYsRUFBV21GLElBQVgsQ0FBdEI7c0JBQ0E7O3NCQUVELElBQUtTLElBQUksS0FBSzNMLElBQWQsRUFBcUI7d0JBQ3BCO3NCQUNBO29CQUNEO2tCQUNEO2dCQUNEO2NBQ0QsQ0FwR1ksQ0FzR2I7OztjQUNBa0wsSUFBSSxJQUFJNUssSUFBUjtjQUNBLE9BQU80SyxJQUFJLEtBQUs5SyxLQUFULElBQW9COEssSUFBSSxHQUFHOUssS0FBUCxLQUFpQixDQUFqQixJQUFzQjhLLElBQUksR0FBRzlLLEtBQVAsSUFBZ0IsQ0FBakU7WUFDQTtVQUNELENBekhGO1FBMEhBLENBNUtNO1FBOEtQLFVBQVUsZ0JBQVU4UCxNQUFWLEVBQWtCMUUsUUFBbEIsRUFBNkI7VUFDdEM7VUFDQTtVQUNBO1VBQ0E7VUFDQSxJQUFJakgsSUFBSjtVQUFBLElBQ0NoRyxFQUFFLEdBQUd3RyxJQUFJLENBQUNpQyxPQUFMLENBQWNrSixNQUFkLEtBQTBCbkwsSUFBSSxDQUFDb0wsVUFBTCxDQUFpQkQsTUFBTSxDQUFDOU0sV0FBUCxFQUFqQixDQUExQixJQUNKMEIsTUFBTSxDQUFDaEQsS0FBUCxDQUFjLHlCQUF5Qm9PLE1BQXZDLENBRkYsQ0FMc0MsQ0FTdEM7VUFDQTtVQUNBOztVQUNBLElBQUszUixFQUFFLENBQUVrRCxPQUFGLENBQVAsRUFBcUI7WUFDcEIsT0FBT2xELEVBQUUsQ0FBRWlOLFFBQUYsQ0FBVDtVQUNBLENBZHFDLENBZ0J0Qzs7O1VBQ0EsSUFBS2pOLEVBQUUsQ0FBQ1ksTUFBSCxHQUFZLENBQWpCLEVBQXFCO1lBQ3BCb0YsSUFBSSxHQUFHLENBQUUyTCxNQUFGLEVBQVVBLE1BQVYsRUFBa0IsRUFBbEIsRUFBc0IxRSxRQUF0QixDQUFQO1lBQ0EsT0FBT3pHLElBQUksQ0FBQ29MLFVBQUwsQ0FBZ0JsUyxjQUFoQixDQUFnQ2lTLE1BQU0sQ0FBQzlNLFdBQVAsRUFBaEMsSUFDTm1ILFlBQVksQ0FBQyxVQUFVN0IsSUFBVixFQUFnQnpFLE9BQWhCLEVBQTBCO2NBQ3RDLElBQUltTSxHQUFKO2NBQUEsSUFDQ0MsT0FBTyxHQUFHOVIsRUFBRSxDQUFFbUssSUFBRixFQUFROEMsUUFBUixDQURiO2NBQUEsSUFFQ3ZMLENBQUMsR0FBR29RLE9BQU8sQ0FBQ2xSLE1BRmI7O2NBR0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7Z0JBQ2JtUSxHQUFHLEdBQUd2UyxPQUFPLENBQUU2SyxJQUFGLEVBQVEySCxPQUFPLENBQUNwUSxDQUFELENBQWYsQ0FBYjtnQkFDQXlJLElBQUksQ0FBRTBILEdBQUYsQ0FBSixHQUFjLEVBQUduTSxPQUFPLENBQUVtTSxHQUFGLENBQVAsR0FBaUJDLE9BQU8sQ0FBQ3BRLENBQUQsQ0FBM0IsQ0FBZDtjQUNBO1lBQ0QsQ0FSVyxDQUROLEdBVU4sVUFBVUQsSUFBVixFQUFpQjtjQUNoQixPQUFPekIsRUFBRSxDQUFFeUIsSUFBRixFQUFRLENBQVIsRUFBV3VFLElBQVgsQ0FBVDtZQUNBLENBWkY7VUFhQTs7VUFFRCxPQUFPaEcsRUFBUDtRQUNBO01Bak5NLENBL0ZpQjtNQW1UekJ5SSxPQUFPLEVBQUU7UUFDUjtRQUNBLE9BQU91RCxZQUFZLENBQUMsVUFBVWxNLFFBQVYsRUFBcUI7VUFDeEM7VUFDQTtVQUNBO1VBQ0EsSUFBSXlPLEtBQUssR0FBRyxFQUFaO1VBQUEsSUFDQ3JKLE9BQU8sR0FBRyxFQURYO1VBQUEsSUFFQzZNLE9BQU8sR0FBR25MLE9BQU8sQ0FBRTlHLFFBQVEsQ0FBQ3VELE9BQVQsQ0FBa0JuRCxLQUFsQixFQUF5QixJQUF6QixDQUFGLENBRmxCO1VBSUEsT0FBTzZSLE9BQU8sQ0FBRTdPLE9BQUYsQ0FBUCxHQUNOOEksWUFBWSxDQUFDLFVBQVU3QixJQUFWLEVBQWdCekUsT0FBaEIsRUFBeUIzRixPQUF6QixFQUFrQ29SLEdBQWxDLEVBQXdDO1lBQ3BELElBQUkxUCxJQUFKO1lBQUEsSUFDQ3VRLFNBQVMsR0FBR0QsT0FBTyxDQUFFNUgsSUFBRixFQUFRLElBQVIsRUFBY2dILEdBQWQsRUFBbUIsRUFBbkIsQ0FEcEI7WUFBQSxJQUVDelAsQ0FBQyxHQUFHeUksSUFBSSxDQUFDdkosTUFGVixDQURvRCxDQUtwRDs7WUFDQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztjQUNiLElBQU1ELElBQUksR0FBR3VRLFNBQVMsQ0FBQ3RRLENBQUQsQ0FBdEIsRUFBNkI7Z0JBQzVCeUksSUFBSSxDQUFDekksQ0FBRCxDQUFKLEdBQVUsRUFBRWdFLE9BQU8sQ0FBQ2hFLENBQUQsQ0FBUCxHQUFhRCxJQUFmLENBQVY7Y0FDQTtZQUNEO1VBQ0QsQ0FYVyxDQUROLEdBYU4sVUFBVUEsSUFBVixFQUFnQjFCLE9BQWhCLEVBQXlCb1IsR0FBekIsRUFBK0I7WUFDOUI1QyxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVc5TSxJQUFYO1lBQ0FzUSxPQUFPLENBQUV4RCxLQUFGLEVBQVMsSUFBVCxFQUFlNEMsR0FBZixFQUFvQmpNLE9BQXBCLENBQVAsQ0FGOEIsQ0FHOUI7O1lBQ0FxSixLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsSUFBWDtZQUNBLE9BQU8sQ0FBQ3JKLE9BQU8sQ0FBQ2dELEdBQVIsRUFBUjtVQUNBLENBbkJGO1FBb0JBLENBNUJrQixDQUZYO1FBZ0NSLE9BQU84RCxZQUFZLENBQUMsVUFBVWxNLFFBQVYsRUFBcUI7VUFDeEMsT0FBTyxVQUFVMkIsSUFBVixFQUFpQjtZQUN2QixPQUFPOEUsTUFBTSxDQUFFekcsUUFBRixFQUFZMkIsSUFBWixDQUFOLENBQXlCYixNQUF6QixHQUFrQyxDQUF6QztVQUNBLENBRkQ7UUFHQSxDQUprQixDQWhDWDtRQXNDUixZQUFZb0wsWUFBWSxDQUFDLFVBQVVqSCxJQUFWLEVBQWlCO1VBQ3pDQSxJQUFJLEdBQUdBLElBQUksQ0FBQzFCLE9BQUwsQ0FBY21HLFNBQWQsRUFBeUJDLFNBQXpCLENBQVA7VUFDQSxPQUFPLFVBQVVoSSxJQUFWLEVBQWlCO1lBQ3ZCLE9BQU8sQ0FBRUEsSUFBSSxDQUFDdU8sV0FBTCxJQUFvQnZPLElBQUksQ0FBQ3dRLFNBQXpCLElBQXNDeEwsT0FBTyxDQUFFaEYsSUFBRixDQUEvQyxFQUEwRG5DLE9BQTFELENBQW1FeUYsSUFBbkUsSUFBNEUsQ0FBQyxDQUFwRjtVQUNBLENBRkQ7UUFHQSxDQUx1QixDQXRDaEI7UUE2Q1I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxRQUFRaUgsWUFBWSxDQUFFLFVBQVVrRyxJQUFWLEVBQWlCO1VBQ3RDO1VBQ0EsSUFBSyxDQUFDbEosV0FBVyxDQUFDa0MsSUFBWixDQUFpQmdILElBQUksSUFBSSxFQUF6QixDQUFOLEVBQXFDO1lBQ3BDM0wsTUFBTSxDQUFDaEQsS0FBUCxDQUFjLHVCQUF1QjJPLElBQXJDO1VBQ0E7O1VBQ0RBLElBQUksR0FBR0EsSUFBSSxDQUFDN08sT0FBTCxDQUFjbUcsU0FBZCxFQUF5QkMsU0FBekIsRUFBcUM1RSxXQUFyQyxFQUFQO1VBQ0EsT0FBTyxVQUFVcEQsSUFBVixFQUFpQjtZQUN2QixJQUFJMFEsUUFBSjs7WUFDQSxHQUFHO2NBQ0YsSUFBTUEsUUFBUSxHQUFHaEwsY0FBYyxHQUM5QjFGLElBQUksQ0FBQ3lRLElBRHlCLEdBRTlCelEsSUFBSSxDQUFDMEosWUFBTCxDQUFrQixVQUFsQixLQUFpQzFKLElBQUksQ0FBQzBKLFlBQUwsQ0FBa0IsTUFBbEIsQ0FGbEMsRUFFK0Q7Z0JBRTlEZ0gsUUFBUSxHQUFHQSxRQUFRLENBQUN0TixXQUFULEVBQVg7Z0JBQ0EsT0FBT3NOLFFBQVEsS0FBS0QsSUFBYixJQUFxQkMsUUFBUSxDQUFDN1MsT0FBVCxDQUFrQjRTLElBQUksR0FBRyxHQUF6QixNQUFtQyxDQUEvRDtjQUNBO1lBQ0QsQ0FSRCxRQVFVLENBQUN6USxJQUFJLEdBQUdBLElBQUksQ0FBQytKLFVBQWIsS0FBNEIvSixJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBUnhEOztZQVNBLE9BQU8sS0FBUDtVQUNBLENBWkQ7UUFhQSxDQW5CbUIsQ0FwRFo7UUF5RVI7UUFDQSxVQUFVLGdCQUFVMUMsSUFBVixFQUFpQjtVQUMxQixJQUFJMlEsSUFBSSxHQUFHcFQsTUFBTSxDQUFDcVQsUUFBUCxJQUFtQnJULE1BQU0sQ0FBQ3FULFFBQVAsQ0FBZ0JELElBQTlDO1VBQ0EsT0FBT0EsSUFBSSxJQUFJQSxJQUFJLENBQUNqVCxLQUFMLENBQVksQ0FBWixNQUFvQnNDLElBQUksQ0FBQ3FKLEVBQXhDO1FBQ0EsQ0E3RU87UUErRVIsUUFBUSxjQUFVckosSUFBVixFQUFpQjtVQUN4QixPQUFPQSxJQUFJLEtBQUt5RixPQUFoQjtRQUNBLENBakZPO1FBbUZSLFNBQVMsZUFBVXpGLElBQVYsRUFBaUI7VUFDekIsT0FBT0EsSUFBSSxLQUFLNUMsUUFBUSxDQUFDeVQsYUFBbEIsS0FBb0MsQ0FBQ3pULFFBQVEsQ0FBQzBULFFBQVYsSUFBc0IxVCxRQUFRLENBQUMwVCxRQUFULEVBQTFELEtBQWtGLENBQUMsRUFBRTlRLElBQUksQ0FBQ2tDLElBQUwsSUFBYWxDLElBQUksQ0FBQytRLElBQWxCLElBQTBCLENBQUMvUSxJQUFJLENBQUNnUixRQUFsQyxDQUExRjtRQUNBLENBckZPO1FBdUZSO1FBQ0EsV0FBVyxpQkFBVWhSLElBQVYsRUFBaUI7VUFDM0IsT0FBT0EsSUFBSSxDQUFDaVIsUUFBTCxLQUFrQixLQUF6QjtRQUNBLENBMUZPO1FBNEZSLFlBQVksa0JBQVVqUixJQUFWLEVBQWlCO1VBQzVCLE9BQU9BLElBQUksQ0FBQ2lSLFFBQUwsS0FBa0IsSUFBekI7UUFDQSxDQTlGTztRQWdHUixXQUFXLGlCQUFValIsSUFBVixFQUFpQjtVQUMzQjtVQUNBO1VBQ0EsSUFBSW1ELFFBQVEsR0FBR25ELElBQUksQ0FBQ21ELFFBQUwsQ0FBY0MsV0FBZCxFQUFmO1VBQ0EsT0FBUUQsUUFBUSxLQUFLLE9BQWIsSUFBd0IsQ0FBQyxDQUFDbkQsSUFBSSxDQUFDa1IsT0FBaEMsSUFBNkMvTixRQUFRLEtBQUssUUFBYixJQUF5QixDQUFDLENBQUNuRCxJQUFJLENBQUNtUixRQUFwRjtRQUNBLENBckdPO1FBdUdSLFlBQVksa0JBQVVuUixJQUFWLEVBQWlCO1VBQzVCO1VBQ0E7VUFDQSxJQUFLQSxJQUFJLENBQUMrSixVQUFWLEVBQXVCO1lBQ3RCL0osSUFBSSxDQUFDK0osVUFBTCxDQUFnQnFILGFBQWhCO1VBQ0E7O1VBRUQsT0FBT3BSLElBQUksQ0FBQ21SLFFBQUwsS0FBa0IsSUFBekI7UUFDQSxDQS9HTztRQWlIUjtRQUNBLFNBQVMsZUFBVW5SLElBQVYsRUFBaUI7VUFDekI7VUFDQTtVQUNBO1VBQ0E7VUFDQSxLQUFNQSxJQUFJLEdBQUdBLElBQUksQ0FBQ3dPLFVBQWxCLEVBQThCeE8sSUFBOUIsRUFBb0NBLElBQUksR0FBR0EsSUFBSSxDQUFDb0wsV0FBaEQsRUFBOEQ7WUFDN0QsSUFBS3BMLElBQUksQ0FBQzBDLFFBQUwsR0FBZ0IsQ0FBckIsRUFBeUI7Y0FDeEIsT0FBTyxLQUFQO1lBQ0E7VUFDRDs7VUFDRCxPQUFPLElBQVA7UUFDQSxDQTdITztRQStIUixVQUFVLGdCQUFVMUMsSUFBVixFQUFpQjtVQUMxQixPQUFPLENBQUMrRSxJQUFJLENBQUNpQyxPQUFMLENBQWEsT0FBYixFQUF1QmhILElBQXZCLENBQVI7UUFDQSxDQWpJTztRQW1JUjtRQUNBLFVBQVUsZ0JBQVVBLElBQVYsRUFBaUI7VUFDMUIsT0FBTzBILE9BQU8sQ0FBQytCLElBQVIsQ0FBY3pKLElBQUksQ0FBQ21ELFFBQW5CLENBQVA7UUFDQSxDQXRJTztRQXdJUixTQUFTLGVBQVVuRCxJQUFWLEVBQWlCO1VBQ3pCLE9BQU95SCxPQUFPLENBQUNnQyxJQUFSLENBQWN6SixJQUFJLENBQUNtRCxRQUFuQixDQUFQO1FBQ0EsQ0ExSU87UUE0SVIsVUFBVSxnQkFBVW5ELElBQVYsRUFBaUI7VUFDMUIsSUFBSWdCLElBQUksR0FBR2hCLElBQUksQ0FBQ21ELFFBQUwsQ0FBY0MsV0FBZCxFQUFYO1VBQ0EsT0FBT3BDLElBQUksS0FBSyxPQUFULElBQW9CaEIsSUFBSSxDQUFDa0MsSUFBTCxLQUFjLFFBQWxDLElBQThDbEIsSUFBSSxLQUFLLFFBQTlEO1FBQ0EsQ0EvSU87UUFpSlIsUUFBUSxjQUFVaEIsSUFBVixFQUFpQjtVQUN4QixJQUFJZ08sSUFBSjtVQUNBLE9BQU9oTyxJQUFJLENBQUNtRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0MsT0FBaEMsSUFDTnBELElBQUksQ0FBQ2tDLElBQUwsS0FBYyxNQURSLE1BR047VUFDQTtVQUNFLENBQUM4TCxJQUFJLEdBQUdoTyxJQUFJLENBQUMwSixZQUFMLENBQWtCLE1BQWxCLENBQVIsS0FBc0MsSUFBdEMsSUFBOENzRSxJQUFJLENBQUM1SyxXQUFMLE9BQXVCLE1BTGpFLENBQVA7UUFNQSxDQXpKTztRQTJKUjtRQUNBLFNBQVNtSSxzQkFBc0IsQ0FBQyxZQUFXO1VBQzFDLE9BQU8sQ0FBRSxDQUFGLENBQVA7UUFDQSxDQUY4QixDQTVKdkI7UUFnS1IsUUFBUUEsc0JBQXNCLENBQUMsVUFBVUUsWUFBVixFQUF3QnRNLE1BQXhCLEVBQWlDO1VBQy9ELE9BQU8sQ0FBRUEsTUFBTSxHQUFHLENBQVgsQ0FBUDtRQUNBLENBRjZCLENBaEt0QjtRQW9LUixNQUFNb00sc0JBQXNCLENBQUMsVUFBVUUsWUFBVixFQUF3QnRNLE1BQXhCLEVBQWdDcU0sUUFBaEMsRUFBMkM7VUFDdkUsT0FBTyxDQUFFQSxRQUFRLEdBQUcsQ0FBWCxHQUFlQSxRQUFRLEdBQUdyTSxNQUExQixHQUFtQ3FNLFFBQXJDLENBQVA7UUFDQSxDQUYyQixDQXBLcEI7UUF3S1IsUUFBUUQsc0JBQXNCLENBQUMsVUFBVUUsWUFBVixFQUF3QnRNLE1BQXhCLEVBQWlDO1VBQy9ELElBQUljLENBQUMsR0FBRyxDQUFSOztVQUNBLE9BQVFBLENBQUMsR0FBR2QsTUFBWixFQUFvQmMsQ0FBQyxJQUFJLENBQXpCLEVBQTZCO1lBQzVCd0wsWUFBWSxDQUFDN04sSUFBYixDQUFtQnFDLENBQW5CO1VBQ0E7O1VBQ0QsT0FBT3dMLFlBQVA7UUFDQSxDQU42QixDQXhLdEI7UUFnTFIsT0FBT0Ysc0JBQXNCLENBQUMsVUFBVUUsWUFBVixFQUF3QnRNLE1BQXhCLEVBQWlDO1VBQzlELElBQUljLENBQUMsR0FBRyxDQUFSOztVQUNBLE9BQVFBLENBQUMsR0FBR2QsTUFBWixFQUFvQmMsQ0FBQyxJQUFJLENBQXpCLEVBQTZCO1lBQzVCd0wsWUFBWSxDQUFDN04sSUFBYixDQUFtQnFDLENBQW5CO1VBQ0E7O1VBQ0QsT0FBT3dMLFlBQVA7UUFDQSxDQU40QixDQWhMckI7UUF3TFIsTUFBTUYsc0JBQXNCLENBQUMsVUFBVUUsWUFBVixFQUF3QnRNLE1BQXhCLEVBQWdDcU0sUUFBaEMsRUFBMkM7VUFDdkUsSUFBSXZMLENBQUMsR0FBR3VMLFFBQVEsR0FBRyxDQUFYLEdBQWVBLFFBQVEsR0FBR3JNLE1BQTFCLEdBQW1DcU0sUUFBM0M7O1VBQ0EsT0FBUSxFQUFFdkwsQ0FBRixJQUFPLENBQWYsR0FBb0I7WUFDbkJ3TCxZQUFZLENBQUM3TixJQUFiLENBQW1CcUMsQ0FBbkI7VUFDQTs7VUFDRCxPQUFPd0wsWUFBUDtRQUNBLENBTjJCLENBeExwQjtRQWdNUixNQUFNRixzQkFBc0IsQ0FBQyxVQUFVRSxZQUFWLEVBQXdCdE0sTUFBeEIsRUFBZ0NxTSxRQUFoQyxFQUEyQztVQUN2RSxJQUFJdkwsQ0FBQyxHQUFHdUwsUUFBUSxHQUFHLENBQVgsR0FBZUEsUUFBUSxHQUFHck0sTUFBMUIsR0FBbUNxTSxRQUEzQzs7VUFDQSxPQUFRLEVBQUV2TCxDQUFGLEdBQU1kLE1BQWQsR0FBd0I7WUFDdkJzTSxZQUFZLENBQUM3TixJQUFiLENBQW1CcUMsQ0FBbkI7VUFDQTs7VUFDRCxPQUFPd0wsWUFBUDtRQUNBLENBTjJCO01BaE1wQjtJQW5UZ0IsQ0FBMUI7SUE2ZkExRyxJQUFJLENBQUNpQyxPQUFMLENBQWEsS0FBYixJQUFzQmpDLElBQUksQ0FBQ2lDLE9BQUwsQ0FBYSxJQUFiLENBQXRCLENBcDlDb0IsQ0FzOUNwQjs7SUFDQSxLQUFNL0csQ0FBTixJQUFXO01BQUVvUixLQUFLLEVBQUUsSUFBVDtNQUFlQyxRQUFRLEVBQUUsSUFBekI7TUFBK0JDLElBQUksRUFBRSxJQUFyQztNQUEyQ0MsUUFBUSxFQUFFLElBQXJEO01BQTJEQyxLQUFLLEVBQUU7SUFBbEUsQ0FBWCxFQUFzRjtNQUNyRjFNLElBQUksQ0FBQ2lDLE9BQUwsQ0FBYy9HLENBQWQsSUFBb0JvTCxpQkFBaUIsQ0FBRXBMLENBQUYsQ0FBckM7SUFDQTs7SUFDRCxLQUFNQSxDQUFOLElBQVc7TUFBRXlSLE1BQU0sRUFBRSxJQUFWO01BQWdCQyxLQUFLLEVBQUU7SUFBdkIsQ0FBWCxFQUEyQztNQUMxQzVNLElBQUksQ0FBQ2lDLE9BQUwsQ0FBYy9HLENBQWQsSUFBb0JxTCxrQkFBa0IsQ0FBRXJMLENBQUYsQ0FBdEM7SUFDQSxDQTU5Q21CLENBODlDcEI7OztJQUNBLFNBQVNrUSxVQUFULEdBQXNCLENBQUU7O0lBQ3hCQSxVQUFVLENBQUNuUixTQUFYLEdBQXVCK0YsSUFBSSxDQUFDNk0sT0FBTCxHQUFlN00sSUFBSSxDQUFDaUMsT0FBM0M7SUFDQWpDLElBQUksQ0FBQ29MLFVBQUwsR0FBa0IsSUFBSUEsVUFBSixFQUFsQjs7SUFFQWpMLFFBQVEsR0FBR0osTUFBTSxDQUFDSSxRQUFQLEdBQWtCLFVBQVU3RyxRQUFWLEVBQW9Cd1QsU0FBcEIsRUFBZ0M7TUFDNUQsSUFBSXhCLE9BQUo7TUFBQSxJQUFhdkgsS0FBYjtNQUFBLElBQW9CZ0osTUFBcEI7TUFBQSxJQUE0QjVQLElBQTVCO01BQUEsSUFDQzZQLEtBREQ7TUFBQSxJQUNRaEosTUFEUjtNQUFBLElBQ2dCaUosVUFEaEI7TUFBQSxJQUVDQyxNQUFNLEdBQUc5TCxVQUFVLENBQUU5SCxRQUFRLEdBQUcsR0FBYixDQUZwQjs7TUFJQSxJQUFLNFQsTUFBTCxFQUFjO1FBQ2IsT0FBT0osU0FBUyxHQUFHLENBQUgsR0FBT0ksTUFBTSxDQUFDdlUsS0FBUCxDQUFjLENBQWQsQ0FBdkI7TUFDQTs7TUFFRHFVLEtBQUssR0FBRzFULFFBQVI7TUFDQTBLLE1BQU0sR0FBRyxFQUFUO01BQ0FpSixVQUFVLEdBQUdqTixJQUFJLENBQUMrSixTQUFsQjs7TUFFQSxPQUFRaUQsS0FBUixFQUFnQjtRQUVmO1FBQ0EsSUFBSyxDQUFDMUIsT0FBRCxLQUFhdkgsS0FBSyxHQUFHM0IsTUFBTSxDQUFDZ0MsSUFBUCxDQUFhNEksS0FBYixDQUFyQixDQUFMLEVBQWtEO1VBQ2pELElBQUtqSixLQUFMLEVBQWE7WUFDWjtZQUNBaUosS0FBSyxHQUFHQSxLQUFLLENBQUNyVSxLQUFOLENBQWFvTCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMzSixNQUF0QixLQUFrQzRTLEtBQTFDO1VBQ0E7O1VBQ0RoSixNQUFNLENBQUNuTCxJQUFQLENBQWNrVSxNQUFNLEdBQUcsRUFBdkI7UUFDQTs7UUFFRHpCLE9BQU8sR0FBRyxLQUFWLENBWGUsQ0FhZjs7UUFDQSxJQUFNdkgsS0FBSyxHQUFHMUIsWUFBWSxDQUFDK0IsSUFBYixDQUFtQjRJLEtBQW5CLENBQWQsRUFBNEM7VUFDM0MxQixPQUFPLEdBQUd2SCxLQUFLLENBQUN3QixLQUFOLEVBQVY7VUFDQXdILE1BQU0sQ0FBQ2xVLElBQVAsQ0FBWTtZQUNYd0csS0FBSyxFQUFFaU0sT0FESTtZQUVYO1lBQ0FuTyxJQUFJLEVBQUU0RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsSCxPQUFULENBQWtCbkQsS0FBbEIsRUFBeUIsR0FBekI7VUFISyxDQUFaO1VBS0FzVCxLQUFLLEdBQUdBLEtBQUssQ0FBQ3JVLEtBQU4sQ0FBYTJTLE9BQU8sQ0FBQ2xSLE1BQXJCLENBQVI7UUFDQSxDQXRCYyxDQXdCZjs7O1FBQ0EsS0FBTStDLElBQU4sSUFBYzZDLElBQUksQ0FBQzBILE1BQW5CLEVBQTRCO1VBQzNCLElBQUssQ0FBQzNELEtBQUssR0FBR3RCLFNBQVMsQ0FBRXRGLElBQUYsQ0FBVCxDQUFrQmlILElBQWxCLENBQXdCNEksS0FBeEIsQ0FBVCxNQUE4QyxDQUFDQyxVQUFVLENBQUU5UCxJQUFGLENBQVgsS0FDakQ0RyxLQUFLLEdBQUdrSixVQUFVLENBQUU5UCxJQUFGLENBQVYsQ0FBb0I0RyxLQUFwQixDQUR5QyxDQUE5QyxDQUFMLEVBQzBDO1lBQ3pDdUgsT0FBTyxHQUFHdkgsS0FBSyxDQUFDd0IsS0FBTixFQUFWO1lBQ0F3SCxNQUFNLENBQUNsVSxJQUFQLENBQVk7Y0FDWHdHLEtBQUssRUFBRWlNLE9BREk7Y0FFWG5PLElBQUksRUFBRUEsSUFGSztjQUdYK0IsT0FBTyxFQUFFNkU7WUFIRSxDQUFaO1lBS0FpSixLQUFLLEdBQUdBLEtBQUssQ0FBQ3JVLEtBQU4sQ0FBYTJTLE9BQU8sQ0FBQ2xSLE1BQXJCLENBQVI7VUFDQTtRQUNEOztRQUVELElBQUssQ0FBQ2tSLE9BQU4sRUFBZ0I7VUFDZjtRQUNBO01BQ0QsQ0F0RDJELENBd0Q1RDtNQUNBO01BQ0E7OztNQUNBLE9BQU93QixTQUFTLEdBQ2ZFLEtBQUssQ0FBQzVTLE1BRFMsR0FFZjRTLEtBQUssR0FDSmpOLE1BQU0sQ0FBQ2hELEtBQVAsQ0FBY3pELFFBQWQsQ0FESSxHQUVKO01BQ0E4SCxVQUFVLENBQUU5SCxRQUFGLEVBQVkwSyxNQUFaLENBQVYsQ0FBK0JyTCxLQUEvQixDQUFzQyxDQUF0QyxDQUxGO0lBTUEsQ0FqRUQ7O0lBbUVBLFNBQVNrTSxVQUFULENBQXFCa0ksTUFBckIsRUFBOEI7TUFDN0IsSUFBSTdSLENBQUMsR0FBRyxDQUFSO01BQUEsSUFDQ00sR0FBRyxHQUFHdVIsTUFBTSxDQUFDM1MsTUFEZDtNQUFBLElBRUNkLFFBQVEsR0FBRyxFQUZaOztNQUdBLE9BQVE0QixDQUFDLEdBQUdNLEdBQVosRUFBaUJOLENBQUMsRUFBbEIsRUFBdUI7UUFDdEI1QixRQUFRLElBQUl5VCxNQUFNLENBQUM3UixDQUFELENBQU4sQ0FBVW1FLEtBQXRCO01BQ0E7O01BQ0QsT0FBTy9GLFFBQVA7SUFDQTs7SUFFRCxTQUFTNlQsYUFBVCxDQUF3QjVCLE9BQXhCLEVBQWlDNkIsVUFBakMsRUFBNkNDLElBQTdDLEVBQW9EO01BQ25ELElBQUl2RCxHQUFHLEdBQUdzRCxVQUFVLENBQUN0RCxHQUFyQjtNQUFBLElBQ0N3RCxnQkFBZ0IsR0FBR0QsSUFBSSxJQUFJdkQsR0FBRyxLQUFLLFlBRHBDO01BQUEsSUFFQ3lELFFBQVEsR0FBR3RNLElBQUksRUFGaEI7TUFJQSxPQUFPbU0sVUFBVSxDQUFDL1IsS0FBWCxHQUNOO01BQ0EsVUFBVUosSUFBVixFQUFnQjFCLE9BQWhCLEVBQXlCb1IsR0FBekIsRUFBK0I7UUFDOUIsT0FBUzFQLElBQUksR0FBR0EsSUFBSSxDQUFFNk8sR0FBRixDQUFwQixFQUErQjtVQUM5QixJQUFLN08sSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUFsQixJQUF1QjJQLGdCQUE1QixFQUErQztZQUM5QyxPQUFPL0IsT0FBTyxDQUFFdFEsSUFBRixFQUFRMUIsT0FBUixFQUFpQm9SLEdBQWpCLENBQWQ7VUFDQTtRQUNEO01BQ0QsQ0FSSyxHQVVOO01BQ0EsVUFBVTFQLElBQVYsRUFBZ0IxQixPQUFoQixFQUF5Qm9SLEdBQXpCLEVBQStCO1FBQzlCLElBQUk2QyxRQUFKO1FBQUEsSUFBYzVDLFdBQWQ7UUFBQSxJQUEyQkMsVUFBM0I7UUFBQSxJQUNDNEMsUUFBUSxHQUFHLENBQUV6TSxPQUFGLEVBQVd1TSxRQUFYLENBRFosQ0FEOEIsQ0FJOUI7O1FBQ0EsSUFBSzVDLEdBQUwsRUFBVztVQUNWLE9BQVMxUCxJQUFJLEdBQUdBLElBQUksQ0FBRTZPLEdBQUYsQ0FBcEIsRUFBK0I7WUFDOUIsSUFBSzdPLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUIyUCxnQkFBNUIsRUFBK0M7Y0FDOUMsSUFBSy9CLE9BQU8sQ0FBRXRRLElBQUYsRUFBUTFCLE9BQVIsRUFBaUJvUixHQUFqQixDQUFaLEVBQXFDO2dCQUNwQyxPQUFPLElBQVA7Y0FDQTtZQUNEO1VBQ0Q7UUFDRCxDQVJELE1BUU87VUFDTixPQUFTMVAsSUFBSSxHQUFHQSxJQUFJLENBQUU2TyxHQUFGLENBQXBCLEVBQStCO1lBQzlCLElBQUs3TyxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxCLElBQXVCMlAsZ0JBQTVCLEVBQStDO2NBQzlDekMsVUFBVSxHQUFHNVAsSUFBSSxDQUFFeUIsT0FBRixDQUFKLEtBQW9CekIsSUFBSSxDQUFFeUIsT0FBRixDQUFKLEdBQWtCLEVBQXRDLENBQWIsQ0FEOEMsQ0FHOUM7Y0FDQTs7Y0FDQWtPLFdBQVcsR0FBR0MsVUFBVSxDQUFFNVAsSUFBSSxDQUFDaVEsUUFBUCxDQUFWLEtBQWdDTCxVQUFVLENBQUU1UCxJQUFJLENBQUNpUSxRQUFQLENBQVYsR0FBOEIsRUFBOUQsQ0FBZDs7Y0FFQSxJQUFLLENBQUNzQyxRQUFRLEdBQUc1QyxXQUFXLENBQUVkLEdBQUYsQ0FBdkIsS0FDSjBELFFBQVEsQ0FBRSxDQUFGLENBQVIsS0FBa0J4TSxPQURkLElBQ3lCd00sUUFBUSxDQUFFLENBQUYsQ0FBUixLQUFrQkQsUUFEaEQsRUFDMkQ7Z0JBRTFEO2dCQUNBLE9BQVFFLFFBQVEsQ0FBRSxDQUFGLENBQVIsR0FBZ0JELFFBQVEsQ0FBRSxDQUFGLENBQWhDO2NBQ0EsQ0FMRCxNQUtPO2dCQUNOO2dCQUNBNUMsV0FBVyxDQUFFZCxHQUFGLENBQVgsR0FBcUIyRCxRQUFyQixDQUZNLENBSU47O2dCQUNBLElBQU1BLFFBQVEsQ0FBRSxDQUFGLENBQVIsR0FBZ0JsQyxPQUFPLENBQUV0USxJQUFGLEVBQVExQixPQUFSLEVBQWlCb1IsR0FBakIsQ0FBN0IsRUFBdUQ7a0JBQ3RELE9BQU8sSUFBUDtnQkFDQTtjQUNEO1lBQ0Q7VUFDRDtRQUNEO01BQ0QsQ0FsREY7SUFtREE7O0lBRUQsU0FBUytDLGNBQVQsQ0FBeUJDLFFBQXpCLEVBQW9DO01BQ25DLE9BQU9BLFFBQVEsQ0FBQ3ZULE1BQVQsR0FBa0IsQ0FBbEIsR0FDTixVQUFVYSxJQUFWLEVBQWdCMUIsT0FBaEIsRUFBeUJvUixHQUF6QixFQUErQjtRQUM5QixJQUFJelAsQ0FBQyxHQUFHeVMsUUFBUSxDQUFDdlQsTUFBakI7O1FBQ0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7VUFDYixJQUFLLENBQUN5UyxRQUFRLENBQUN6UyxDQUFELENBQVIsQ0FBYUQsSUFBYixFQUFtQjFCLE9BQW5CLEVBQTRCb1IsR0FBNUIsQ0FBTixFQUEwQztZQUN6QyxPQUFPLEtBQVA7VUFDQTtRQUNEOztRQUNELE9BQU8sSUFBUDtNQUNBLENBVEssR0FVTmdELFFBQVEsQ0FBQyxDQUFELENBVlQ7SUFXQTs7SUFFRCxTQUFTQyxnQkFBVCxDQUEyQnRVLFFBQTNCLEVBQXFDdVUsUUFBckMsRUFBK0NuUCxPQUEvQyxFQUF5RDtNQUN4RCxJQUFJeEQsQ0FBQyxHQUFHLENBQVI7TUFBQSxJQUNDTSxHQUFHLEdBQUdxUyxRQUFRLENBQUN6VCxNQURoQjs7TUFFQSxPQUFRYyxDQUFDLEdBQUdNLEdBQVosRUFBaUJOLENBQUMsRUFBbEIsRUFBdUI7UUFDdEI2RSxNQUFNLENBQUV6RyxRQUFGLEVBQVl1VSxRQUFRLENBQUMzUyxDQUFELENBQXBCLEVBQXlCd0QsT0FBekIsQ0FBTjtNQUNBOztNQUNELE9BQU9BLE9BQVA7SUFDQTs7SUFFRCxTQUFTb1AsUUFBVCxDQUFtQnRDLFNBQW5CLEVBQThCeFEsR0FBOUIsRUFBbUMwTSxNQUFuQyxFQUEyQ25PLE9BQTNDLEVBQW9Eb1IsR0FBcEQsRUFBMEQ7TUFDekQsSUFBSTFQLElBQUo7TUFBQSxJQUNDOFMsWUFBWSxHQUFHLEVBRGhCO01BQUEsSUFFQzdTLENBQUMsR0FBRyxDQUZMO01BQUEsSUFHQ00sR0FBRyxHQUFHZ1EsU0FBUyxDQUFDcFIsTUFIakI7TUFBQSxJQUlDNFQsTUFBTSxHQUFHaFQsR0FBRyxJQUFJLElBSmpCOztNQU1BLE9BQVFFLENBQUMsR0FBR00sR0FBWixFQUFpQk4sQ0FBQyxFQUFsQixFQUF1QjtRQUN0QixJQUFNRCxJQUFJLEdBQUd1USxTQUFTLENBQUN0USxDQUFELENBQXRCLEVBQTZCO1VBQzVCLElBQUssQ0FBQ3dNLE1BQUQsSUFBV0EsTUFBTSxDQUFFek0sSUFBRixFQUFRMUIsT0FBUixFQUFpQm9SLEdBQWpCLENBQXRCLEVBQStDO1lBQzlDb0QsWUFBWSxDQUFDbFYsSUFBYixDQUFtQm9DLElBQW5COztZQUNBLElBQUsrUyxNQUFMLEVBQWM7Y0FDYmhULEdBQUcsQ0FBQ25DLElBQUosQ0FBVXFDLENBQVY7WUFDQTtVQUNEO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPNlMsWUFBUDtJQUNBOztJQUVELFNBQVNFLFVBQVQsQ0FBcUJsRSxTQUFyQixFQUFnQ3pRLFFBQWhDLEVBQTBDaVMsT0FBMUMsRUFBbUQyQyxVQUFuRCxFQUErREMsVUFBL0QsRUFBMkVDLFlBQTNFLEVBQTBGO01BQ3pGLElBQUtGLFVBQVUsSUFBSSxDQUFDQSxVQUFVLENBQUV4UixPQUFGLENBQTlCLEVBQTRDO1FBQzNDd1IsVUFBVSxHQUFHRCxVQUFVLENBQUVDLFVBQUYsQ0FBdkI7TUFDQTs7TUFDRCxJQUFLQyxVQUFVLElBQUksQ0FBQ0EsVUFBVSxDQUFFelIsT0FBRixDQUE5QixFQUE0QztRQUMzQ3lSLFVBQVUsR0FBR0YsVUFBVSxDQUFFRSxVQUFGLEVBQWNDLFlBQWQsQ0FBdkI7TUFDQTs7TUFDRCxPQUFPNUksWUFBWSxDQUFDLFVBQVU3QixJQUFWLEVBQWdCakYsT0FBaEIsRUFBeUJuRixPQUF6QixFQUFrQ29SLEdBQWxDLEVBQXdDO1FBQzNELElBQUkwRCxJQUFKO1FBQUEsSUFBVW5ULENBQVY7UUFBQSxJQUFhRCxJQUFiO1FBQUEsSUFDQ3FULE1BQU0sR0FBRyxFQURWO1FBQUEsSUFFQ0MsT0FBTyxHQUFHLEVBRlg7UUFBQSxJQUdDQyxXQUFXLEdBQUc5UCxPQUFPLENBQUN0RSxNQUh2QjtRQUFBLElBS0M7UUFDQU0sS0FBSyxHQUFHaUosSUFBSSxJQUFJaUssZ0JBQWdCLENBQUV0VSxRQUFRLElBQUksR0FBZCxFQUFtQkMsT0FBTyxDQUFDb0UsUUFBUixHQUFtQixDQUFFcEUsT0FBRixDQUFuQixHQUFpQ0EsT0FBcEQsRUFBNkQsRUFBN0QsQ0FOakM7UUFBQSxJQVFDO1FBQ0FrVixTQUFTLEdBQUcxRSxTQUFTLEtBQU1wRyxJQUFJLElBQUksQ0FBQ3JLLFFBQWYsQ0FBVCxHQUNYd1UsUUFBUSxDQUFFcFQsS0FBRixFQUFTNFQsTUFBVCxFQUFpQnZFLFNBQWpCLEVBQTRCeFEsT0FBNUIsRUFBcUNvUixHQUFyQyxDQURHLEdBRVhqUSxLQVhGO1FBQUEsSUFhQ2dVLFVBQVUsR0FBR25ELE9BQU8sR0FDbkI7UUFDQTRDLFVBQVUsS0FBTXhLLElBQUksR0FBR29HLFNBQUgsR0FBZXlFLFdBQVcsSUFBSU4sVUFBeEMsQ0FBVixHQUVDO1FBQ0EsRUFIRCxHQUtDO1FBQ0F4UCxPQVJrQixHQVNuQitQLFNBdEJGLENBRDJELENBeUIzRDs7UUFDQSxJQUFLbEQsT0FBTCxFQUFlO1VBQ2RBLE9BQU8sQ0FBRWtELFNBQUYsRUFBYUMsVUFBYixFQUF5Qm5WLE9BQXpCLEVBQWtDb1IsR0FBbEMsQ0FBUDtRQUNBLENBNUIwRCxDQThCM0Q7OztRQUNBLElBQUt1RCxVQUFMLEVBQWtCO1VBQ2pCRyxJQUFJLEdBQUdQLFFBQVEsQ0FBRVksVUFBRixFQUFjSCxPQUFkLENBQWY7VUFDQUwsVUFBVSxDQUFFRyxJQUFGLEVBQVEsRUFBUixFQUFZOVUsT0FBWixFQUFxQm9SLEdBQXJCLENBQVYsQ0FGaUIsQ0FJakI7O1VBQ0F6UCxDQUFDLEdBQUdtVCxJQUFJLENBQUNqVSxNQUFUOztVQUNBLE9BQVFjLENBQUMsRUFBVCxFQUFjO1lBQ2IsSUFBTUQsSUFBSSxHQUFHb1QsSUFBSSxDQUFDblQsQ0FBRCxDQUFqQixFQUF3QjtjQUN2QndULFVBQVUsQ0FBRUgsT0FBTyxDQUFDclQsQ0FBRCxDQUFULENBQVYsR0FBMkIsRUFBRXVULFNBQVMsQ0FBRUYsT0FBTyxDQUFDclQsQ0FBRCxDQUFULENBQVQsR0FBMEJELElBQTVCLENBQTNCO1lBQ0E7VUFDRDtRQUNEOztRQUVELElBQUswSSxJQUFMLEVBQVk7VUFDWCxJQUFLd0ssVUFBVSxJQUFJcEUsU0FBbkIsRUFBK0I7WUFDOUIsSUFBS29FLFVBQUwsRUFBa0I7Y0FDakI7Y0FDQUUsSUFBSSxHQUFHLEVBQVA7Y0FDQW5ULENBQUMsR0FBR3dULFVBQVUsQ0FBQ3RVLE1BQWY7O2NBQ0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7Z0JBQ2IsSUFBTUQsSUFBSSxHQUFHeVQsVUFBVSxDQUFDeFQsQ0FBRCxDQUF2QixFQUE4QjtrQkFDN0I7a0JBQ0FtVCxJQUFJLENBQUN4VixJQUFMLENBQVk0VixTQUFTLENBQUN2VCxDQUFELENBQVQsR0FBZUQsSUFBM0I7Z0JBQ0E7Y0FDRDs7Y0FDRGtULFVBQVUsQ0FBRSxJQUFGLEVBQVNPLFVBQVUsR0FBRyxFQUF0QixFQUEyQkwsSUFBM0IsRUFBaUMxRCxHQUFqQyxDQUFWO1lBQ0EsQ0FaNkIsQ0FjOUI7OztZQUNBelAsQ0FBQyxHQUFHd1QsVUFBVSxDQUFDdFUsTUFBZjs7WUFDQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztjQUNiLElBQUssQ0FBQ0QsSUFBSSxHQUFHeVQsVUFBVSxDQUFDeFQsQ0FBRCxDQUFsQixLQUNKLENBQUNtVCxJQUFJLEdBQUdGLFVBQVUsR0FBR3JWLE9BQU8sQ0FBRTZLLElBQUYsRUFBUTFJLElBQVIsQ0FBVixHQUEyQnFULE1BQU0sQ0FBQ3BULENBQUQsQ0FBbkQsSUFBMEQsQ0FBQyxDQUQ1RCxFQUNnRTtnQkFFL0R5SSxJQUFJLENBQUMwSyxJQUFELENBQUosR0FBYSxFQUFFM1AsT0FBTyxDQUFDMlAsSUFBRCxDQUFQLEdBQWdCcFQsSUFBbEIsQ0FBYjtjQUNBO1lBQ0Q7VUFDRCxDQXhCVSxDQTBCWjs7UUFDQyxDQTNCRCxNQTJCTztVQUNOeVQsVUFBVSxHQUFHWixRQUFRLENBQ3BCWSxVQUFVLEtBQUtoUSxPQUFmLEdBQ0NnUSxVQUFVLENBQUM5UyxNQUFYLENBQW1CNFMsV0FBbkIsRUFBZ0NFLFVBQVUsQ0FBQ3RVLE1BQTNDLENBREQsR0FFQ3NVLFVBSG1CLENBQXJCOztVQUtBLElBQUtQLFVBQUwsRUFBa0I7WUFDakJBLFVBQVUsQ0FBRSxJQUFGLEVBQVF6UCxPQUFSLEVBQWlCZ1EsVUFBakIsRUFBNkIvRCxHQUE3QixDQUFWO1VBQ0EsQ0FGRCxNQUVPO1lBQ045UixJQUFJLENBQUNzQyxLQUFMLENBQVl1RCxPQUFaLEVBQXFCZ1EsVUFBckI7VUFDQTtRQUNEO01BQ0QsQ0FuRmtCLENBQW5CO0lBb0ZBOztJQUVELFNBQVNDLGlCQUFULENBQTRCNUIsTUFBNUIsRUFBcUM7TUFDcEMsSUFBSTZCLFlBQUo7TUFBQSxJQUFrQnJELE9BQWxCO01BQUEsSUFBMkI5UCxDQUEzQjtNQUFBLElBQ0NELEdBQUcsR0FBR3VSLE1BQU0sQ0FBQzNTLE1BRGQ7TUFBQSxJQUVDeVUsZUFBZSxHQUFHN08sSUFBSSxDQUFDNkosUUFBTCxDQUFla0QsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVNVAsSUFBekIsQ0FGbkI7TUFBQSxJQUdDMlIsZ0JBQWdCLEdBQUdELGVBQWUsSUFBSTdPLElBQUksQ0FBQzZKLFFBQUwsQ0FBYyxHQUFkLENBSHZDO01BQUEsSUFJQzNPLENBQUMsR0FBRzJULGVBQWUsR0FBRyxDQUFILEdBQU8sQ0FKM0I7TUFBQSxJQU1DO01BQ0FFLFlBQVksR0FBRzVCLGFBQWEsQ0FBRSxVQUFVbFMsSUFBVixFQUFpQjtRQUM5QyxPQUFPQSxJQUFJLEtBQUsyVCxZQUFoQjtNQUNBLENBRjJCLEVBRXpCRSxnQkFGeUIsRUFFUCxJQUZPLENBUDdCO01BQUEsSUFVQ0UsZUFBZSxHQUFHN0IsYUFBYSxDQUFFLFVBQVVsUyxJQUFWLEVBQWlCO1FBQ2pELE9BQU9uQyxPQUFPLENBQUU4VixZQUFGLEVBQWdCM1QsSUFBaEIsQ0FBUCxHQUFnQyxDQUFDLENBQXhDO01BQ0EsQ0FGOEIsRUFFNUI2VCxnQkFGNEIsRUFFVixJQUZVLENBVmhDO01BQUEsSUFhQ25CLFFBQVEsR0FBRyxDQUFFLFVBQVUxUyxJQUFWLEVBQWdCMUIsT0FBaEIsRUFBeUJvUixHQUF6QixFQUErQjtRQUMzQyxJQUFJaFEsR0FBRyxHQUFLLENBQUNrVSxlQUFELEtBQXNCbEUsR0FBRyxJQUFJcFIsT0FBTyxLQUFLK0csZ0JBQXpDLENBQUYsS0FDVCxDQUFDc08sWUFBWSxHQUFHclYsT0FBaEIsRUFBeUJvRSxRQUF6QixHQUNDb1IsWUFBWSxDQUFFOVQsSUFBRixFQUFRMUIsT0FBUixFQUFpQm9SLEdBQWpCLENBRGIsR0FFQ3FFLGVBQWUsQ0FBRS9ULElBQUYsRUFBUTFCLE9BQVIsRUFBaUJvUixHQUFqQixDQUhQLENBQVYsQ0FEMkMsQ0FLM0M7O1FBQ0FpRSxZQUFZLEdBQUcsSUFBZjtRQUNBLE9BQU9qVSxHQUFQO01BQ0EsQ0FSVSxDQWJaOztNQXVCQSxPQUFRTyxDQUFDLEdBQUdNLEdBQVosRUFBaUJOLENBQUMsRUFBbEIsRUFBdUI7UUFDdEIsSUFBTXFRLE9BQU8sR0FBR3ZMLElBQUksQ0FBQzZKLFFBQUwsQ0FBZWtELE1BQU0sQ0FBQzdSLENBQUQsQ0FBTixDQUFVaUMsSUFBekIsQ0FBaEIsRUFBbUQ7VUFDbER3USxRQUFRLEdBQUcsQ0FBRVIsYUFBYSxDQUFDTyxjQUFjLENBQUVDLFFBQUYsQ0FBZixFQUE2QnBDLE9BQTdCLENBQWYsQ0FBWDtRQUNBLENBRkQsTUFFTztVQUNOQSxPQUFPLEdBQUd2TCxJQUFJLENBQUMwSCxNQUFMLENBQWFxRixNQUFNLENBQUM3UixDQUFELENBQU4sQ0FBVWlDLElBQXZCLEVBQThCaEMsS0FBOUIsQ0FBcUMsSUFBckMsRUFBMkM0UixNQUFNLENBQUM3UixDQUFELENBQU4sQ0FBVWdFLE9BQXJELENBQVYsQ0FETSxDQUdOOztVQUNBLElBQUtxTSxPQUFPLENBQUU3TyxPQUFGLENBQVosRUFBMEI7WUFDekI7WUFDQWpCLENBQUMsR0FBRyxFQUFFUCxDQUFOOztZQUNBLE9BQVFPLENBQUMsR0FBR0QsR0FBWixFQUFpQkMsQ0FBQyxFQUFsQixFQUF1QjtjQUN0QixJQUFLdUUsSUFBSSxDQUFDNkosUUFBTCxDQUFla0QsTUFBTSxDQUFDdFIsQ0FBRCxDQUFOLENBQVUwQixJQUF6QixDQUFMLEVBQXVDO2dCQUN0QztjQUNBO1lBQ0Q7O1lBQ0QsT0FBTzhRLFVBQVUsQ0FDaEIvUyxDQUFDLEdBQUcsQ0FBSixJQUFTd1MsY0FBYyxDQUFFQyxRQUFGLENBRFAsRUFFaEJ6UyxDQUFDLEdBQUcsQ0FBSixJQUFTMkosVUFBVSxFQUNsQjtZQUNBa0ksTUFBTSxDQUFDcFUsS0FBUCxDQUFjLENBQWQsRUFBaUJ1QyxDQUFDLEdBQUcsQ0FBckIsRUFBeUJ0QyxNQUF6QixDQUFnQztjQUFFeUcsS0FBSyxFQUFFME4sTUFBTSxDQUFFN1IsQ0FBQyxHQUFHLENBQU4sQ0FBTixDQUFnQmlDLElBQWhCLEtBQXlCLEdBQXpCLEdBQStCLEdBQS9CLEdBQXFDO1lBQTlDLENBQWhDLENBRmtCLENBQVYsQ0FHUE4sT0FITyxDQUdFbkQsS0FIRixFQUdTLElBSFQsQ0FGTyxFQU1oQjZSLE9BTmdCLEVBT2hCclEsQ0FBQyxHQUFHTyxDQUFKLElBQVNrVCxpQkFBaUIsQ0FBRTVCLE1BQU0sQ0FBQ3BVLEtBQVAsQ0FBY3VDLENBQWQsRUFBaUJPLENBQWpCLENBQUYsQ0FQVixFQVFoQkEsQ0FBQyxHQUFHRCxHQUFKLElBQVdtVCxpQkFBaUIsQ0FBRzVCLE1BQU0sR0FBR0EsTUFBTSxDQUFDcFUsS0FBUCxDQUFjOEMsQ0FBZCxDQUFaLENBUlosRUFTaEJBLENBQUMsR0FBR0QsR0FBSixJQUFXcUosVUFBVSxDQUFFa0ksTUFBRixDQVRMLENBQWpCO1VBV0E7O1VBQ0RZLFFBQVEsQ0FBQzlVLElBQVQsQ0FBZTBTLE9BQWY7UUFDQTtNQUNEOztNQUVELE9BQU9tQyxjQUFjLENBQUVDLFFBQUYsQ0FBckI7SUFDQTs7SUFFRCxTQUFTc0Isd0JBQVQsQ0FBbUNDLGVBQW5DLEVBQW9EQyxXQUFwRCxFQUFrRTtNQUNqRSxJQUFJQyxLQUFLLEdBQUdELFdBQVcsQ0FBQy9VLE1BQVosR0FBcUIsQ0FBakM7TUFBQSxJQUNDaVYsU0FBUyxHQUFHSCxlQUFlLENBQUM5VSxNQUFoQixHQUF5QixDQUR0QztNQUFBLElBRUNrVixZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFVM0wsSUFBVixFQUFnQnBLLE9BQWhCLEVBQXlCb1IsR0FBekIsRUFBOEJqTSxPQUE5QixFQUF1QzZRLFNBQXZDLEVBQW1EO1FBQ2pFLElBQUl0VSxJQUFKO1FBQUEsSUFBVVEsQ0FBVjtRQUFBLElBQWE4UCxPQUFiO1FBQUEsSUFDQ2lFLFlBQVksR0FBRyxDQURoQjtRQUFBLElBRUN0VSxDQUFDLEdBQUcsR0FGTDtRQUFBLElBR0NzUSxTQUFTLEdBQUc3SCxJQUFJLElBQUksRUFIckI7UUFBQSxJQUlDOEwsVUFBVSxHQUFHLEVBSmQ7UUFBQSxJQUtDQyxhQUFhLEdBQUdwUCxnQkFMakI7UUFBQSxJQU1DO1FBQ0E1RixLQUFLLEdBQUdpSixJQUFJLElBQUkwTCxTQUFTLElBQUlyUCxJQUFJLENBQUN5SCxJQUFMLENBQVUsS0FBVixFQUFrQixHQUFsQixFQUF1QjhILFNBQXZCLENBUDlCO1FBQUEsSUFRQztRQUNBSSxhQUFhLEdBQUkzTyxPQUFPLElBQUkwTyxhQUFhLElBQUksSUFBakIsR0FBd0IsQ0FBeEIsR0FBNEIvUyxJQUFJLENBQUNDLE1BQUwsTUFBaUIsR0FUMUU7UUFBQSxJQVVDcEIsR0FBRyxHQUFHZCxLQUFLLENBQUNOLE1BVmI7O1FBWUEsSUFBS21WLFNBQUwsRUFBaUI7VUFDaEJqUCxnQkFBZ0IsR0FBRy9HLE9BQU8sS0FBS2xCLFFBQVosSUFBd0JrQixPQUF4QixJQUFtQ2dXLFNBQXREO1FBQ0EsQ0FmZ0UsQ0FpQmpFO1FBQ0E7UUFDQTs7O1FBQ0EsT0FBUXJVLENBQUMsS0FBS00sR0FBTixJQUFhLENBQUNQLElBQUksR0FBR1AsS0FBSyxDQUFDUSxDQUFELENBQWIsS0FBcUIsSUFBMUMsRUFBZ0RBLENBQUMsRUFBakQsRUFBc0Q7VUFDckQsSUFBS21VLFNBQVMsSUFBSXBVLElBQWxCLEVBQXlCO1lBQ3hCUSxDQUFDLEdBQUcsQ0FBSjs7WUFDQSxJQUFLLENBQUNsQyxPQUFELElBQVkwQixJQUFJLENBQUNrSixhQUFMLEtBQXVCOUwsUUFBeEMsRUFBbUQ7Y0FDbERvSSxXQUFXLENBQUV4RixJQUFGLENBQVg7Y0FDQTBQLEdBQUcsR0FBRyxDQUFDaEssY0FBUDtZQUNBOztZQUNELE9BQVM0SyxPQUFPLEdBQUcyRCxlQUFlLENBQUN6VCxDQUFDLEVBQUYsQ0FBbEMsRUFBMkM7Y0FDMUMsSUFBSzhQLE9BQU8sQ0FBRXRRLElBQUYsRUFBUTFCLE9BQU8sSUFBSWxCLFFBQW5CLEVBQTZCc1MsR0FBN0IsQ0FBWixFQUFnRDtnQkFDL0NqTSxPQUFPLENBQUM3RixJQUFSLENBQWNvQyxJQUFkO2dCQUNBO2NBQ0E7WUFDRDs7WUFDRCxJQUFLc1UsU0FBTCxFQUFpQjtjQUNoQnZPLE9BQU8sR0FBRzJPLGFBQVY7WUFDQTtVQUNELENBaEJvRCxDQWtCckQ7OztVQUNBLElBQUtQLEtBQUwsRUFBYTtZQUNaO1lBQ0EsSUFBTW5VLElBQUksR0FBRyxDQUFDc1EsT0FBRCxJQUFZdFEsSUFBekIsRUFBaUM7Y0FDaEN1VSxZQUFZO1lBQ1osQ0FKVyxDQU1aOzs7WUFDQSxJQUFLN0wsSUFBTCxFQUFZO2NBQ1g2SCxTQUFTLENBQUMzUyxJQUFWLENBQWdCb0MsSUFBaEI7WUFDQTtVQUNEO1FBQ0QsQ0FsRGdFLENBb0RqRTtRQUNBOzs7UUFDQXVVLFlBQVksSUFBSXRVLENBQWhCLENBdERpRSxDQXdEakU7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBQ0EsSUFBS2tVLEtBQUssSUFBSWxVLENBQUMsS0FBS3NVLFlBQXBCLEVBQW1DO1VBQ2xDL1QsQ0FBQyxHQUFHLENBQUo7O1VBQ0EsT0FBUzhQLE9BQU8sR0FBRzRELFdBQVcsQ0FBQzFULENBQUMsRUFBRixDQUE5QixFQUF1QztZQUN0QzhQLE9BQU8sQ0FBRUMsU0FBRixFQUFhaUUsVUFBYixFQUF5QmxXLE9BQXpCLEVBQWtDb1IsR0FBbEMsQ0FBUDtVQUNBOztVQUVELElBQUtoSCxJQUFMLEVBQVk7WUFDWDtZQUNBLElBQUs2TCxZQUFZLEdBQUcsQ0FBcEIsRUFBd0I7Y0FDdkIsT0FBUXRVLENBQUMsRUFBVCxFQUFjO2dCQUNiLElBQUssRUFBRXNRLFNBQVMsQ0FBQ3RRLENBQUQsQ0FBVCxJQUFnQnVVLFVBQVUsQ0FBQ3ZVLENBQUQsQ0FBNUIsQ0FBTCxFQUF3QztrQkFDdkN1VSxVQUFVLENBQUN2VSxDQUFELENBQVYsR0FBZ0J3RyxHQUFHLENBQUNwSCxJQUFKLENBQVVvRSxPQUFWLENBQWhCO2dCQUNBO2NBQ0Q7WUFDRCxDQVJVLENBVVg7OztZQUNBK1EsVUFBVSxHQUFHM0IsUUFBUSxDQUFFMkIsVUFBRixDQUFyQjtVQUNBLENBbEJpQyxDQW9CbEM7OztVQUNBNVcsSUFBSSxDQUFDc0MsS0FBTCxDQUFZdUQsT0FBWixFQUFxQitRLFVBQXJCLEVBckJrQyxDQXVCbEM7O1VBQ0EsSUFBS0YsU0FBUyxJQUFJLENBQUM1TCxJQUFkLElBQXNCOEwsVUFBVSxDQUFDclYsTUFBWCxHQUFvQixDQUExQyxJQUNGb1YsWUFBWSxHQUFHTCxXQUFXLENBQUMvVSxNQUE3QixHQUF3QyxDQUR6QyxFQUM2QztZQUU1QzJGLE1BQU0sQ0FBQ3FKLFVBQVAsQ0FBbUIxSyxPQUFuQjtVQUNBO1FBQ0QsQ0E1RmdFLENBOEZqRTs7O1FBQ0EsSUFBSzZRLFNBQUwsRUFBaUI7VUFDaEJ2TyxPQUFPLEdBQUcyTyxhQUFWO1VBQ0FyUCxnQkFBZ0IsR0FBR29QLGFBQW5CO1FBQ0E7O1FBRUQsT0FBT2xFLFNBQVA7TUFDQSxDQXZHRjs7TUF5R0EsT0FBTzRELEtBQUssR0FDWDVKLFlBQVksQ0FBRThKLFlBQUYsQ0FERCxHQUVYQSxZQUZEO0lBR0E7O0lBRURsUCxPQUFPLEdBQUdMLE1BQU0sQ0FBQ0ssT0FBUCxHQUFpQixVQUFVOUcsUUFBVixFQUFvQnlLO0lBQU07SUFBMUIsRUFBb0Q7TUFDOUUsSUFBSTdJLENBQUo7TUFBQSxJQUNDaVUsV0FBVyxHQUFHLEVBRGY7TUFBQSxJQUVDRCxlQUFlLEdBQUcsRUFGbkI7TUFBQSxJQUdDaEMsTUFBTSxHQUFHN0wsYUFBYSxDQUFFL0gsUUFBUSxHQUFHLEdBQWIsQ0FIdkI7O01BS0EsSUFBSyxDQUFDNFQsTUFBTixFQUFlO1FBQ2Q7UUFDQSxJQUFLLENBQUNuSixLQUFOLEVBQWM7VUFDYkEsS0FBSyxHQUFHNUQsUUFBUSxDQUFFN0csUUFBRixDQUFoQjtRQUNBOztRQUNENEIsQ0FBQyxHQUFHNkksS0FBSyxDQUFDM0osTUFBVjs7UUFDQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztVQUNiZ1MsTUFBTSxHQUFHeUIsaUJBQWlCLENBQUU1SyxLQUFLLENBQUM3SSxDQUFELENBQVAsQ0FBMUI7O1VBQ0EsSUFBS2dTLE1BQU0sQ0FBRXhRLE9BQUYsQ0FBWCxFQUF5QjtZQUN4QnlTLFdBQVcsQ0FBQ3RXLElBQVosQ0FBa0JxVSxNQUFsQjtVQUNBLENBRkQsTUFFTztZQUNOZ0MsZUFBZSxDQUFDclcsSUFBaEIsQ0FBc0JxVSxNQUF0QjtVQUNBO1FBQ0QsQ0FiYSxDQWVkOzs7UUFDQUEsTUFBTSxHQUFHN0wsYUFBYSxDQUFFL0gsUUFBRixFQUFZMlYsd0JBQXdCLENBQUVDLGVBQUYsRUFBbUJDLFdBQW5CLENBQXBDLENBQXRCLENBaEJjLENBa0JkOztRQUNBakMsTUFBTSxDQUFDNVQsUUFBUCxHQUFrQkEsUUFBbEI7TUFDQTs7TUFDRCxPQUFPNFQsTUFBUDtJQUNBLENBNUJEO0lBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0E3TSxNQUFNLEdBQUdOLE1BQU0sQ0FBQ00sTUFBUCxHQUFnQixVQUFVL0csUUFBVixFQUFvQkMsT0FBcEIsRUFBNkJtRixPQUE3QixFQUFzQ2lGLElBQXRDLEVBQTZDO01BQ3JFLElBQUl6SSxDQUFKO01BQUEsSUFBTzZSLE1BQVA7TUFBQSxJQUFlNkMsS0FBZjtNQUFBLElBQXNCelMsSUFBdEI7TUFBQSxJQUE0QnNLLElBQTVCO01BQUEsSUFDQ29JLFFBQVEsR0FBRyxPQUFPdlcsUUFBUCxLQUFvQixVQUFwQixJQUFrQ0EsUUFEOUM7TUFBQSxJQUVDeUssS0FBSyxHQUFHLENBQUNKLElBQUQsSUFBU3hELFFBQVEsQ0FBRzdHLFFBQVEsR0FBR3VXLFFBQVEsQ0FBQ3ZXLFFBQVQsSUFBcUJBLFFBQW5DLENBRjFCO01BSUFvRixPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQixDQUxxRSxDQU9yRTtNQUNBOztNQUNBLElBQUtxRixLQUFLLENBQUMzSixNQUFOLEtBQWlCLENBQXRCLEVBQTBCO1FBRXpCO1FBQ0EyUyxNQUFNLEdBQUdoSixLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU3BMLEtBQVQsQ0FBZ0IsQ0FBaEIsQ0FBcEI7O1FBQ0EsSUFBS29VLE1BQU0sQ0FBQzNTLE1BQVAsR0FBZ0IsQ0FBaEIsSUFBcUIsQ0FBQ3dWLEtBQUssR0FBRzdDLE1BQU0sQ0FBQyxDQUFELENBQWYsRUFBb0I1UCxJQUFwQixLQUE2QixJQUFsRCxJQUNIaEUsT0FBTyxDQUFDb08sT0FETCxJQUNnQmhPLE9BQU8sQ0FBQ29FLFFBQVIsS0FBcUIsQ0FEckMsSUFDMENnRCxjQUQxQyxJQUVIWCxJQUFJLENBQUM2SixRQUFMLENBQWVrRCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVU1UCxJQUF6QixDQUZGLEVBRW9DO1VBRW5DNUQsT0FBTyxHQUFHLENBQUV5RyxJQUFJLENBQUN5SCxJQUFMLENBQVUsSUFBVixFQUFpQm1JLEtBQUssQ0FBQzFRLE9BQU4sQ0FBYyxDQUFkLEVBQWlCckMsT0FBakIsQ0FBeUJtRyxTQUF6QixFQUFvQ0MsU0FBcEMsQ0FBakIsRUFBaUUxSixPQUFqRSxLQUE4RSxFQUFoRixFQUFxRixDQUFyRixDQUFWOztVQUNBLElBQUssQ0FBQ0EsT0FBTixFQUFnQjtZQUNmLE9BQU9tRixPQUFQLENBRGUsQ0FHaEI7VUFDQyxDQUpELE1BSU8sSUFBS21SLFFBQUwsRUFBZ0I7WUFDdEJ0VyxPQUFPLEdBQUdBLE9BQU8sQ0FBQ3lMLFVBQWxCO1VBQ0E7O1VBRUQxTCxRQUFRLEdBQUdBLFFBQVEsQ0FBQ1gsS0FBVCxDQUFnQm9VLE1BQU0sQ0FBQ3hILEtBQVAsR0FBZWxHLEtBQWYsQ0FBcUJqRixNQUFyQyxDQUFYO1FBQ0EsQ0FsQndCLENBb0J6Qjs7O1FBQ0FjLENBQUMsR0FBR3VILFNBQVMsQ0FBQyxjQUFELENBQVQsQ0FBMEJpQyxJQUExQixDQUFnQ3BMLFFBQWhDLElBQTZDLENBQTdDLEdBQWlEeVQsTUFBTSxDQUFDM1MsTUFBNUQ7O1FBQ0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7VUFDYjBVLEtBQUssR0FBRzdDLE1BQU0sQ0FBQzdSLENBQUQsQ0FBZCxDQURhLENBR2I7O1VBQ0EsSUFBSzhFLElBQUksQ0FBQzZKLFFBQUwsQ0FBZ0IxTSxJQUFJLEdBQUd5UyxLQUFLLENBQUN6UyxJQUE3QixDQUFMLEVBQTRDO1lBQzNDO1VBQ0E7O1VBQ0QsSUFBTXNLLElBQUksR0FBR3pILElBQUksQ0FBQ3lILElBQUwsQ0FBV3RLLElBQVgsQ0FBYixFQUFrQztZQUNqQztZQUNBLElBQU13RyxJQUFJLEdBQUc4RCxJQUFJLENBQ2hCbUksS0FBSyxDQUFDMVEsT0FBTixDQUFjLENBQWQsRUFBaUJyQyxPQUFqQixDQUEwQm1HLFNBQTFCLEVBQXFDQyxTQUFyQyxDQURnQixFQUVoQkgsUUFBUSxDQUFDNEIsSUFBVCxDQUFlcUksTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVNVAsSUFBekIsS0FBbUM0SCxXQUFXLENBQUV4TCxPQUFPLENBQUN5TCxVQUFWLENBQTlDLElBQXdFekwsT0FGeEQsQ0FBakIsRUFHSztjQUVKO2NBQ0F3VCxNQUFNLENBQUNuUixNQUFQLENBQWVWLENBQWYsRUFBa0IsQ0FBbEI7Y0FDQTVCLFFBQVEsR0FBR3FLLElBQUksQ0FBQ3ZKLE1BQUwsSUFBZXlLLFVBQVUsQ0FBRWtJLE1BQUYsQ0FBcEM7O2NBQ0EsSUFBSyxDQUFDelQsUUFBTixFQUFpQjtnQkFDaEJULElBQUksQ0FBQ3NDLEtBQUwsQ0FBWXVELE9BQVosRUFBcUJpRixJQUFyQjtnQkFDQSxPQUFPakYsT0FBUDtjQUNBOztjQUVEO1lBQ0E7VUFDRDtRQUNEO01BQ0QsQ0F6RG9FLENBMkRyRTtNQUNBOzs7TUFDQSxDQUFFbVIsUUFBUSxJQUFJelAsT0FBTyxDQUFFOUcsUUFBRixFQUFZeUssS0FBWixDQUFyQixFQUNDSixJQURELEVBRUNwSyxPQUZELEVBR0MsQ0FBQ29ILGNBSEYsRUFJQ2pDLE9BSkQsRUFLQyxDQUFDbkYsT0FBRCxJQUFZdUosUUFBUSxDQUFDNEIsSUFBVCxDQUFlcEwsUUFBZixLQUE2QnlMLFdBQVcsQ0FBRXhMLE9BQU8sQ0FBQ3lMLFVBQVYsQ0FBcEQsSUFBOEV6TCxPQUwvRTtNQU9BLE9BQU9tRixPQUFQO0lBQ0EsQ0FyRUQsQ0FuOERvQixDQTBnRXBCO0lBRUE7OztJQUNBdkYsT0FBTyxDQUFDb1EsVUFBUixHQUFxQjdNLE9BQU8sQ0FBQ29ELEtBQVIsQ0FBYyxFQUFkLEVBQWtCbkUsSUFBbEIsQ0FBd0IyRixTQUF4QixFQUFvQ3dELElBQXBDLENBQXlDLEVBQXpDLE1BQWlEcEksT0FBdEUsQ0E3Z0VvQixDQStnRXBCO0lBQ0E7O0lBQ0F2RCxPQUFPLENBQUNtUSxnQkFBUixHQUEyQixDQUFDLENBQUM5SSxZQUE3QixDQWpoRW9CLENBbWhFcEI7O0lBQ0FDLFdBQVcsR0FwaEVTLENBc2hFcEI7SUFDQTs7SUFDQXRILE9BQU8sQ0FBQ3VQLFlBQVIsR0FBdUJqRCxNQUFNLENBQUMsVUFBVXFLLElBQVYsRUFBaUI7TUFDOUM7TUFDQSxPQUFPQSxJQUFJLENBQUN4SCx1QkFBTCxDQUE4QmpRLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBOUIsSUFBZ0UsQ0FBdkU7SUFDQSxDQUg0QixDQUE3QixDQXhoRW9CLENBNmhFcEI7SUFDQTtJQUNBOztJQUNBLElBQUssQ0FBQ0YsTUFBTSxDQUFDLFVBQVVDLEdBQVYsRUFBZ0I7TUFDNUJBLEdBQUcsQ0FBQ29DLFNBQUosR0FBZ0Isa0JBQWhCO01BQ0EsT0FBT3BDLEdBQUcsQ0FBQytELFVBQUosQ0FBZTlFLFlBQWYsQ0FBNEIsTUFBNUIsTUFBd0MsR0FBL0M7SUFDQSxDQUhXLENBQVosRUFHSztNQUNKa0IsU0FBUyxDQUFFLHdCQUFGLEVBQTRCLFVBQVU1SyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0JpRSxLQUF0QixFQUE4QjtRQUNsRSxJQUFLLENBQUNBLEtBQU4sRUFBYztVQUNiLE9BQU9qRixJQUFJLENBQUMwSixZQUFMLENBQW1CMUksSUFBbkIsRUFBeUJBLElBQUksQ0FBQ29DLFdBQUwsT0FBdUIsTUFBdkIsR0FBZ0MsQ0FBaEMsR0FBb0MsQ0FBN0QsQ0FBUDtRQUNBO01BQ0QsQ0FKUSxDQUFUO0lBS0EsQ0F6aUVtQixDQTJpRXBCO0lBQ0E7OztJQUNBLElBQUssQ0FBQ2xGLE9BQU8sQ0FBQzZJLFVBQVQsSUFBdUIsQ0FBQ3lELE1BQU0sQ0FBQyxVQUFVQyxHQUFWLEVBQWdCO01BQ25EQSxHQUFHLENBQUNvQyxTQUFKLEdBQWdCLFVBQWhCO01BQ0FwQyxHQUFHLENBQUMrRCxVQUFKLENBQWU3RSxZQUFmLENBQTZCLE9BQTdCLEVBQXNDLEVBQXRDO01BQ0EsT0FBT2MsR0FBRyxDQUFDK0QsVUFBSixDQUFlOUUsWUFBZixDQUE2QixPQUE3QixNQUEyQyxFQUFsRDtJQUNBLENBSmtDLENBQW5DLEVBSUs7TUFDSmtCLFNBQVMsQ0FBRSxPQUFGLEVBQVcsVUFBVTVLLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQmlFLEtBQXRCLEVBQThCO1FBQ2pELElBQUssQ0FBQ0EsS0FBRCxJQUFVakYsSUFBSSxDQUFDbUQsUUFBTCxDQUFjQyxXQUFkLE9BQWdDLE9BQS9DLEVBQXlEO1VBQ3hELE9BQU9wRCxJQUFJLENBQUM4VSxZQUFaO1FBQ0E7TUFDRCxDQUpRLENBQVQ7SUFLQSxDQXZqRW1CLENBeWpFcEI7SUFDQTs7O0lBQ0EsSUFBSyxDQUFDdEssTUFBTSxDQUFDLFVBQVVDLEdBQVYsRUFBZ0I7TUFDNUIsT0FBT0EsR0FBRyxDQUFDZixZQUFKLENBQWlCLFVBQWpCLEtBQWdDLElBQXZDO0lBQ0EsQ0FGVyxDQUFaLEVBRUs7TUFDSmtCLFNBQVMsQ0FBRWhFLFFBQUYsRUFBWSxVQUFVNUcsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCaUUsS0FBdEIsRUFBOEI7UUFDbEQsSUFBSWdKLEdBQUo7O1FBQ0EsSUFBSyxDQUFDaEosS0FBTixFQUFjO1VBQ2IsT0FBT2pGLElBQUksQ0FBRWdCLElBQUYsQ0FBSixLQUFpQixJQUFqQixHQUF3QkEsSUFBSSxDQUFDb0MsV0FBTCxFQUF4QixHQUNMLENBQUM2SyxHQUFHLEdBQUdqTyxJQUFJLENBQUMyTSxnQkFBTCxDQUF1QjNMLElBQXZCLENBQVAsS0FBeUNpTixHQUFHLENBQUNDLFNBQTdDLEdBQ0FELEdBQUcsQ0FBQzdKLEtBREosR0FFRCxJQUhEO1FBSUE7TUFDRCxDQVJRLENBQVQ7SUFTQTs7SUFFRCxPQUFPVSxNQUFQO0VBRUMsQ0Eza0VELENBMmtFSXZILE1BM2tFSixDQVhBOztFQTBsRUFhLE1BQU0sQ0FBQ29PLElBQVAsR0FBYzFILE1BQWQ7RUFDQTFHLE1BQU0sQ0FBQzBQLElBQVAsR0FBY2hKLE1BQU0sQ0FBQzRKLFNBQXJCO0VBQ0F0USxNQUFNLENBQUMwUCxJQUFQLENBQWEsR0FBYixJQUFxQjFQLE1BQU0sQ0FBQzBQLElBQVAsQ0FBWTlHLE9BQWpDO0VBQ0E1SSxNQUFNLENBQUMrUCxVQUFQLEdBQW9CL1AsTUFBTSxDQUFDMlcsTUFBUCxHQUFnQmpRLE1BQU0sQ0FBQ3FKLFVBQTNDO0VBQ0EvUCxNQUFNLENBQUNrRixJQUFQLEdBQWN3QixNQUFNLENBQUNFLE9BQXJCO0VBQ0E1RyxNQUFNLENBQUM0VyxRQUFQLEdBQWtCbFEsTUFBTSxDQUFDRyxLQUF6QjtFQUNBN0csTUFBTSxDQUFDeUgsUUFBUCxHQUFrQmYsTUFBTSxDQUFDZSxRQUF6Qjs7RUFJQSxJQUFJZ0osR0FBRyxHQUFHLGFBQVU3TyxJQUFWLEVBQWdCNk8sSUFBaEIsRUFBcUJvRyxLQUFyQixFQUE2QjtJQUN0QyxJQUFJNUUsT0FBTyxHQUFHLEVBQWQ7SUFBQSxJQUNDNkUsUUFBUSxHQUFHRCxLQUFLLEtBQUt6VCxTQUR0Qjs7SUFHQSxPQUFRLENBQUV4QixJQUFJLEdBQUdBLElBQUksQ0FBRTZPLElBQUYsQ0FBYixLQUEwQjdPLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBcEQsRUFBd0Q7TUFDdkQsSUFBSzFDLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7UUFDMUIsSUFBS3dTLFFBQVEsSUFBSTlXLE1BQU0sQ0FBRTRCLElBQUYsQ0FBTixDQUFlbVYsRUFBZixDQUFtQkYsS0FBbkIsQ0FBakIsRUFBOEM7VUFDN0M7UUFDQTs7UUFDRDVFLE9BQU8sQ0FBQ3pTLElBQVIsQ0FBY29DLElBQWQ7TUFDQTtJQUNEOztJQUNELE9BQU9xUSxPQUFQO0VBQ0EsQ0FiRDs7RUFnQkEsSUFBSStFLFNBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVVDLENBQVYsRUFBYXJWLElBQWIsRUFBb0I7SUFDbEMsSUFBSXFRLE9BQU8sR0FBRyxFQUFkOztJQUVBLE9BQVFnRixDQUFSLEVBQVdBLENBQUMsR0FBR0EsQ0FBQyxDQUFDakssV0FBakIsRUFBK0I7TUFDOUIsSUFBS2lLLENBQUMsQ0FBQzNTLFFBQUYsS0FBZSxDQUFmLElBQW9CMlMsQ0FBQyxLQUFLclYsSUFBL0IsRUFBc0M7UUFDckNxUSxPQUFPLENBQUN6UyxJQUFSLENBQWN5WCxDQUFkO01BQ0E7SUFDRDs7SUFFRCxPQUFPaEYsT0FBUDtFQUNBLENBVkQ7O0VBYUEsSUFBSWlGLGFBQWEsR0FBR2xYLE1BQU0sQ0FBQzBQLElBQVAsQ0FBWWhGLEtBQVosQ0FBa0J5TSxZQUF0QztFQUVBLElBQUlDLFVBQVUsR0FBSywrQkFBbkI7RUFJQSxJQUFJQyxTQUFTLEdBQUcsZ0JBQWhCLENBcHFGOEUsQ0FzcUY5RTs7RUFDQSxTQUFTQyxNQUFULENBQWlCM0gsUUFBakIsRUFBMkI0SCxTQUEzQixFQUFzQ0MsR0FBdEMsRUFBNEM7SUFDM0MsSUFBS3hYLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUJzVSxTQUFuQixDQUFMLEVBQXNDO01BQ3JDLE9BQU92WCxNQUFNLENBQUMwRixJQUFQLENBQWFpSyxRQUFiLEVBQXVCLFVBQVUvTixJQUFWLEVBQWdCQyxDQUFoQixFQUFvQjtRQUNqRDtRQUNBLE9BQU8sQ0FBQyxDQUFDMFYsU0FBUyxDQUFDdFcsSUFBVixDQUFnQlcsSUFBaEIsRUFBc0JDLENBQXRCLEVBQXlCRCxJQUF6QixDQUFGLEtBQXNDNFYsR0FBN0M7TUFDQSxDQUhNLENBQVA7SUFLQTs7SUFFRCxJQUFLRCxTQUFTLENBQUNqVCxRQUFmLEVBQTBCO01BQ3pCLE9BQU90RSxNQUFNLENBQUMwRixJQUFQLENBQWFpSyxRQUFiLEVBQXVCLFVBQVUvTixJQUFWLEVBQWlCO1FBQzlDLE9BQVNBLElBQUksS0FBSzJWLFNBQVgsS0FBMkJDLEdBQWxDO01BQ0EsQ0FGTSxDQUFQO0lBSUE7O0lBRUQsSUFBSyxPQUFPRCxTQUFQLEtBQXFCLFFBQTFCLEVBQXFDO01BQ3BDLElBQUtGLFNBQVMsQ0FBQ2hNLElBQVYsQ0FBZ0JrTSxTQUFoQixDQUFMLEVBQW1DO1FBQ2xDLE9BQU92WCxNQUFNLENBQUNxTyxNQUFQLENBQWVrSixTQUFmLEVBQTBCNUgsUUFBMUIsRUFBb0M2SCxHQUFwQyxDQUFQO01BQ0E7O01BRURELFNBQVMsR0FBR3ZYLE1BQU0sQ0FBQ3FPLE1BQVAsQ0FBZWtKLFNBQWYsRUFBMEI1SCxRQUExQixDQUFaO0lBQ0E7O0lBRUQsT0FBTzNQLE1BQU0sQ0FBQzBGLElBQVAsQ0FBYWlLLFFBQWIsRUFBdUIsVUFBVS9OLElBQVYsRUFBaUI7TUFDOUMsT0FBUzVCLE1BQU0sQ0FBQ3VGLE9BQVAsQ0FBZ0IzRCxJQUFoQixFQUFzQjJWLFNBQXRCLElBQW9DLENBQUMsQ0FBdkMsS0FBK0NDLEdBQXREO0lBQ0EsQ0FGTSxDQUFQO0VBR0E7O0VBRUR4WCxNQUFNLENBQUNxTyxNQUFQLEdBQWdCLFVBQVVxQixJQUFWLEVBQWdCck8sS0FBaEIsRUFBdUJtVyxHQUF2QixFQUE2QjtJQUM1QyxJQUFJNVYsSUFBSSxHQUFHUCxLQUFLLENBQUUsQ0FBRixDQUFoQjs7SUFFQSxJQUFLbVcsR0FBTCxFQUFXO01BQ1Y5SCxJQUFJLEdBQUcsVUFBVUEsSUFBVixHQUFpQixHQUF4QjtJQUNBOztJQUVELE9BQU9yTyxLQUFLLENBQUNOLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0JhLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBeEMsR0FDTnRFLE1BQU0sQ0FBQ29PLElBQVAsQ0FBWU8sZUFBWixDQUE2Qi9NLElBQTdCLEVBQW1DOE4sSUFBbkMsSUFBNEMsQ0FBRTlOLElBQUYsQ0FBNUMsR0FBdUQsRUFEakQsR0FFTjVCLE1BQU0sQ0FBQ29PLElBQVAsQ0FBWXZJLE9BQVosQ0FBcUI2SixJQUFyQixFQUEyQjFQLE1BQU0sQ0FBQzBGLElBQVAsQ0FBYXJFLEtBQWIsRUFBb0IsVUFBVU8sSUFBVixFQUFpQjtNQUMvRCxPQUFPQSxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQXpCO0lBQ0EsQ0FGMEIsQ0FBM0IsQ0FGRDtFQUtBLENBWkQ7O0VBY0F0RSxNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFDakI0TCxJQUFJLEVBQUUsY0FBVW5PLFFBQVYsRUFBcUI7TUFDMUIsSUFBSTRCLENBQUo7TUFBQSxJQUNDUCxHQUFHLEdBQUcsRUFEUDtNQUFBLElBRUNtVyxJQUFJLEdBQUcsSUFGUjtNQUFBLElBR0N0VixHQUFHLEdBQUdzVixJQUFJLENBQUMxVyxNQUhaOztNQUtBLElBQUssT0FBT2QsUUFBUCxLQUFvQixRQUF6QixFQUFvQztRQUNuQyxPQUFPLEtBQUttQixTQUFMLENBQWdCcEIsTUFBTSxDQUFFQyxRQUFGLENBQU4sQ0FBbUJvTyxNQUFuQixDQUEyQixZQUFXO1VBQzVELEtBQU14TSxDQUFDLEdBQUcsQ0FBVixFQUFhQSxDQUFDLEdBQUdNLEdBQWpCLEVBQXNCTixDQUFDLEVBQXZCLEVBQTRCO1lBQzNCLElBQUs3QixNQUFNLENBQUN5SCxRQUFQLENBQWlCZ1EsSUFBSSxDQUFFNVYsQ0FBRixDQUFyQixFQUE0QixJQUE1QixDQUFMLEVBQTBDO2NBQ3pDLE9BQU8sSUFBUDtZQUNBO1VBQ0Q7UUFDRCxDQU5zQixDQUFoQixDQUFQO01BT0E7O01BRUQsS0FBTUEsQ0FBQyxHQUFHLENBQVYsRUFBYUEsQ0FBQyxHQUFHTSxHQUFqQixFQUFzQk4sQ0FBQyxFQUF2QixFQUE0QjtRQUMzQjdCLE1BQU0sQ0FBQ29PLElBQVAsQ0FBYW5PLFFBQWIsRUFBdUJ3WCxJQUFJLENBQUU1VixDQUFGLENBQTNCLEVBQWtDUCxHQUFsQztNQUNBLENBbEJ5QixDQW9CMUI7OztNQUNBQSxHQUFHLEdBQUcsS0FBS0YsU0FBTCxDQUFnQmUsR0FBRyxHQUFHLENBQU4sR0FBVW5DLE1BQU0sQ0FBQzJXLE1BQVAsQ0FBZXJWLEdBQWYsQ0FBVixHQUFpQ0EsR0FBakQsQ0FBTjtNQUNBQSxHQUFHLENBQUNyQixRQUFKLEdBQWUsS0FBS0EsUUFBTCxHQUFnQixLQUFLQSxRQUFMLEdBQWdCLEdBQWhCLEdBQXNCQSxRQUF0QyxHQUFpREEsUUFBaEU7TUFDQSxPQUFPcUIsR0FBUDtJQUNBLENBekJnQjtJQTBCakIrTSxNQUFNLEVBQUUsZ0JBQVVwTyxRQUFWLEVBQXFCO01BQzVCLE9BQU8sS0FBS21CLFNBQUwsQ0FBZ0JrVyxNQUFNLENBQUUsSUFBRixFQUFRclgsUUFBUSxJQUFJLEVBQXBCLEVBQXdCLEtBQXhCLENBQXRCLENBQVA7SUFDQSxDQTVCZ0I7SUE2QmpCdVgsR0FBRyxFQUFFLGFBQVV2WCxRQUFWLEVBQXFCO01BQ3pCLE9BQU8sS0FBS21CLFNBQUwsQ0FBZ0JrVyxNQUFNLENBQUUsSUFBRixFQUFRclgsUUFBUSxJQUFJLEVBQXBCLEVBQXdCLElBQXhCLENBQXRCLENBQVA7SUFDQSxDQS9CZ0I7SUFnQ2pCOFcsRUFBRSxFQUFFLFlBQVU5VyxRQUFWLEVBQXFCO01BQ3hCLE9BQU8sQ0FBQyxDQUFDcVgsTUFBTSxDQUNkLElBRGMsRUFHZDtNQUNBO01BQ0EsT0FBT3JYLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0NpWCxhQUFhLENBQUM3TCxJQUFkLENBQW9CcEwsUUFBcEIsQ0FBaEMsR0FDQ0QsTUFBTSxDQUFFQyxRQUFGLENBRFAsR0FFQ0EsUUFBUSxJQUFJLEVBUEMsRUFRZCxLQVJjLENBQU4sQ0FTUGMsTUFURjtJQVVBO0VBM0NnQixDQUFsQixFQWx0RjhFLENBaXdGOUU7RUFHQTs7RUFDQSxJQUFJMlcsVUFBSjtFQUFBLElBRUM7RUFDQTtFQUNBO0VBQ0FsTyxVQUFVLEdBQUcscUNBTGQ7RUFBQSxJQU9DcEosSUFBSSxHQUFHSixNQUFNLENBQUNHLEVBQVAsQ0FBVUMsSUFBVixHQUFpQixVQUFVSCxRQUFWLEVBQW9CQyxPQUFwQixFQUE2QnlYLElBQTdCLEVBQW9DO0lBQzNELElBQUlqTixLQUFKLEVBQVc5SSxJQUFYLENBRDJELENBRzNEOztJQUNBLElBQUssQ0FBQzNCLFFBQU4sRUFBaUI7TUFDaEIsT0FBTyxJQUFQO0lBQ0EsQ0FOMEQsQ0FRM0Q7SUFDQTs7O0lBQ0EwWCxJQUFJLEdBQUdBLElBQUksSUFBSUQsVUFBZixDQVYyRCxDQVkzRDs7SUFDQSxJQUFLLE9BQU96WCxRQUFQLEtBQW9CLFFBQXpCLEVBQW9DO01BQ25DLElBQUtBLFFBQVEsQ0FBQzJYLE1BQVQsQ0FBaUIsQ0FBakIsTUFBeUIsR0FBekIsSUFDSjNYLFFBQVEsQ0FBQzJYLE1BQVQsQ0FBaUIzWCxRQUFRLENBQUNjLE1BQVQsR0FBa0IsQ0FBbkMsTUFBMkMsR0FEdkMsSUFFSmQsUUFBUSxDQUFDYyxNQUFULElBQW1CLENBRnBCLEVBRXdCO1FBRXZCO1FBQ0EySixLQUFLLEdBQUcsQ0FBRSxJQUFGLEVBQVF6SyxRQUFSLEVBQWtCLElBQWxCLENBQVI7TUFFQSxDQVBELE1BT087UUFDTnlLLEtBQUssR0FBR2xCLFVBQVUsQ0FBQ3VCLElBQVgsQ0FBaUI5SyxRQUFqQixDQUFSO01BQ0EsQ0FWa0MsQ0FZbkM7OztNQUNBLElBQUt5SyxLQUFLLEtBQU1BLEtBQUssQ0FBRSxDQUFGLENBQUwsSUFBYyxDQUFDeEssT0FBckIsQ0FBVixFQUEyQztRQUUxQztRQUNBLElBQUt3SyxLQUFLLENBQUUsQ0FBRixDQUFWLEVBQWtCO1VBQ2pCeEssT0FBTyxHQUFHQSxPQUFPLFlBQVlGLE1BQW5CLEdBQTRCRSxPQUFPLENBQUUsQ0FBRixDQUFuQyxHQUEyQ0EsT0FBckQsQ0FEaUIsQ0FHakI7VUFDQTs7VUFDQUYsTUFBTSxDQUFDdUIsS0FBUCxDQUFjLElBQWQsRUFBb0J2QixNQUFNLENBQUM2WCxTQUFQLENBQ25Cbk4sS0FBSyxDQUFFLENBQUYsQ0FEYyxFQUVuQnhLLE9BQU8sSUFBSUEsT0FBTyxDQUFDb0UsUUFBbkIsR0FBOEJwRSxPQUFPLENBQUM0SyxhQUFSLElBQXlCNUssT0FBdkQsR0FBaUVsQixRQUY5QyxFQUduQixJQUhtQixDQUFwQixFQUxpQixDQVdqQjs7VUFDQSxJQUFLb1ksVUFBVSxDQUFDL0wsSUFBWCxDQUFpQlgsS0FBSyxDQUFFLENBQUYsQ0FBdEIsS0FBaUMxSyxNQUFNLENBQUNrRCxhQUFQLENBQXNCaEQsT0FBdEIsQ0FBdEMsRUFBd0U7WUFDdkUsS0FBTXdLLEtBQU4sSUFBZXhLLE9BQWYsRUFBeUI7Y0FFeEI7Y0FDQSxJQUFLRixNQUFNLENBQUNpRCxVQUFQLENBQW1CLEtBQU15SCxLQUFOLENBQW5CLENBQUwsRUFBMEM7Z0JBQ3pDLEtBQU1BLEtBQU4sRUFBZXhLLE9BQU8sQ0FBRXdLLEtBQUYsQ0FBdEIsRUFEeUMsQ0FHMUM7Y0FDQyxDQUpELE1BSU87Z0JBQ04sS0FBS2tGLElBQUwsQ0FBV2xGLEtBQVgsRUFBa0J4SyxPQUFPLENBQUV3SyxLQUFGLENBQXpCO2NBQ0E7WUFDRDtVQUNEOztVQUVELE9BQU8sSUFBUCxDQTFCaUIsQ0E0QmxCO1FBQ0MsQ0E3QkQsTUE2Qk87VUFDTjlJLElBQUksR0FBRzVDLFFBQVEsQ0FBQ2dNLGNBQVQsQ0FBeUJOLEtBQUssQ0FBRSxDQUFGLENBQTlCLENBQVAsQ0FETSxDQUdOO1VBQ0E7O1VBQ0EsSUFBSzlJLElBQUksSUFBSUEsSUFBSSxDQUFDK0osVUFBbEIsRUFBK0I7WUFFOUI7WUFDQTtZQUNBLElBQUsvSixJQUFJLENBQUNxSixFQUFMLEtBQVlQLEtBQUssQ0FBRSxDQUFGLENBQXRCLEVBQThCO2NBQzdCLE9BQU9nTixVQUFVLENBQUN0SixJQUFYLENBQWlCbk8sUUFBakIsQ0FBUDtZQUNBLENBTjZCLENBUTlCOzs7WUFDQSxLQUFLYyxNQUFMLEdBQWMsQ0FBZDtZQUNBLEtBQU0sQ0FBTixJQUFZYSxJQUFaO1VBQ0E7O1VBRUQsS0FBSzFCLE9BQUwsR0FBZWxCLFFBQWY7VUFDQSxLQUFLaUIsUUFBTCxHQUFnQkEsUUFBaEI7VUFDQSxPQUFPLElBQVA7UUFDQSxDQXJEeUMsQ0F1RDNDOztNQUNDLENBeERELE1Bd0RPLElBQUssQ0FBQ0MsT0FBRCxJQUFZQSxPQUFPLENBQUNXLE1BQXpCLEVBQWtDO1FBQ3hDLE9BQU8sQ0FBRVgsT0FBTyxJQUFJeVgsSUFBYixFQUFvQnZKLElBQXBCLENBQTBCbk8sUUFBMUIsQ0FBUCxDQUR3QyxDQUd6QztRQUNBO01BQ0MsQ0FMTSxNQUtBO1FBQ04sT0FBTyxLQUFLYSxXQUFMLENBQWtCWixPQUFsQixFQUE0QmtPLElBQTVCLENBQWtDbk8sUUFBbEMsQ0FBUDtNQUNBLENBNUVrQyxDQThFcEM7O0lBQ0MsQ0EvRUQsTUErRU8sSUFBS0EsUUFBUSxDQUFDcUUsUUFBZCxFQUF5QjtNQUMvQixLQUFLcEUsT0FBTCxHQUFlLEtBQU0sQ0FBTixJQUFZRCxRQUEzQjtNQUNBLEtBQUtjLE1BQUwsR0FBYyxDQUFkO01BQ0EsT0FBTyxJQUFQLENBSCtCLENBS2hDO01BQ0E7SUFDQyxDQVBNLE1BT0EsSUFBS2YsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQmhELFFBQW5CLENBQUwsRUFBcUM7TUFDM0MsT0FBTyxPQUFPMFgsSUFBSSxDQUFDRyxLQUFaLEtBQXNCLFdBQXRCLEdBQ05ILElBQUksQ0FBQ0csS0FBTCxDQUFZN1gsUUFBWixDQURNLEdBR047TUFDQUEsUUFBUSxDQUFFRCxNQUFGLENBSlQ7SUFLQTs7SUFFRCxJQUFLQyxRQUFRLENBQUNBLFFBQVQsS0FBc0JtRCxTQUEzQixFQUF1QztNQUN0QyxLQUFLbkQsUUFBTCxHQUFnQkEsUUFBUSxDQUFDQSxRQUF6QjtNQUNBLEtBQUtDLE9BQUwsR0FBZUQsUUFBUSxDQUFDQyxPQUF4QjtJQUNBOztJQUVELE9BQU9GLE1BQU0sQ0FBQ21GLFNBQVAsQ0FBa0JsRixRQUFsQixFQUE0QixJQUE1QixDQUFQO0VBQ0EsQ0F4SEYsQ0Fyd0Y4RSxDQSszRjlFOzs7RUFDQUcsSUFBSSxDQUFDUSxTQUFMLEdBQWlCWixNQUFNLENBQUNHLEVBQXhCLENBaDRGOEUsQ0FrNEY5RTs7RUFDQXVYLFVBQVUsR0FBRzFYLE1BQU0sQ0FBRWhCLFFBQUYsQ0FBbkI7RUFHQSxJQUFJK1ksWUFBWSxHQUFHLGdDQUFuQjtFQUFBLElBRUM7RUFDQUMsZ0JBQWdCLEdBQUc7SUFDbEJDLFFBQVEsRUFBRSxJQURRO0lBRWxCQyxRQUFRLEVBQUUsSUFGUTtJQUdsQkMsSUFBSSxFQUFFLElBSFk7SUFJbEJDLElBQUksRUFBRTtFQUpZLENBSHBCO0VBVUFwWSxNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFDakI2VixHQUFHLEVBQUUsYUFBVXRWLE1BQVYsRUFBbUI7TUFDdkIsSUFBSWxCLENBQUo7TUFBQSxJQUNDeVcsT0FBTyxHQUFHdFksTUFBTSxDQUFFK0MsTUFBRixFQUFVLElBQVYsQ0FEakI7TUFBQSxJQUVDWixHQUFHLEdBQUdtVyxPQUFPLENBQUN2WCxNQUZmO01BSUEsT0FBTyxLQUFLc04sTUFBTCxDQUFhLFlBQVc7UUFDOUIsS0FBTXhNLENBQUMsR0FBRyxDQUFWLEVBQWFBLENBQUMsR0FBR00sR0FBakIsRUFBc0JOLENBQUMsRUFBdkIsRUFBNEI7VUFDM0IsSUFBSzdCLE1BQU0sQ0FBQ3lILFFBQVAsQ0FBaUIsSUFBakIsRUFBdUI2USxPQUFPLENBQUV6VyxDQUFGLENBQTlCLENBQUwsRUFBNkM7WUFDNUMsT0FBTyxJQUFQO1VBQ0E7UUFDRDtNQUNELENBTk0sQ0FBUDtJQU9BLENBYmdCO0lBZWpCMFcsT0FBTyxFQUFFLGlCQUFVakksU0FBVixFQUFxQnBRLE9BQXJCLEVBQStCO01BQ3ZDLElBQUkyTSxHQUFKO01BQUEsSUFDQ2hMLENBQUMsR0FBRyxDQURMO01BQUEsSUFFQzJXLENBQUMsR0FBRyxLQUFLelgsTUFGVjtNQUFBLElBR0NrUixPQUFPLEdBQUcsRUFIWDtNQUFBLElBSUN3RyxHQUFHLEdBQUd2QixhQUFhLENBQUM3TCxJQUFkLENBQW9CaUYsU0FBcEIsS0FBbUMsT0FBT0EsU0FBUCxLQUFxQixRQUF4RCxHQUNMdFEsTUFBTSxDQUFFc1EsU0FBRixFQUFhcFEsT0FBTyxJQUFJLEtBQUtBLE9BQTdCLENBREQsR0FFTCxDQU5GOztNQVFBLE9BQVEyQixDQUFDLEdBQUcyVyxDQUFaLEVBQWUzVyxDQUFDLEVBQWhCLEVBQXFCO1FBQ3BCLEtBQU1nTCxHQUFHLEdBQUcsS0FBTWhMLENBQU4sQ0FBWixFQUF1QmdMLEdBQUcsSUFBSUEsR0FBRyxLQUFLM00sT0FBdEMsRUFBK0MyTSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ2xCLFVBQXpELEVBQXNFO1VBRXJFO1VBQ0EsSUFBS2tCLEdBQUcsQ0FBQ3ZJLFFBQUosR0FBZSxFQUFmLEtBQXVCbVUsR0FBRyxHQUM5QkEsR0FBRyxDQUFDQyxLQUFKLENBQVc3TCxHQUFYLElBQW1CLENBQUMsQ0FEVSxHQUc5QjtVQUNBQSxHQUFHLENBQUN2SSxRQUFKLEtBQWlCLENBQWpCLElBQ0N0RSxNQUFNLENBQUNvTyxJQUFQLENBQVlPLGVBQVosQ0FBNkI5QixHQUE3QixFQUFrQ3lELFNBQWxDLENBTEcsQ0FBTCxFQUtvRDtZQUVuRDJCLE9BQU8sQ0FBQ3pTLElBQVIsQ0FBY3FOLEdBQWQ7WUFDQTtVQUNBO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPLEtBQUt6TCxTQUFMLENBQWdCNlEsT0FBTyxDQUFDbFIsTUFBUixHQUFpQixDQUFqQixHQUFxQmYsTUFBTSxDQUFDK1AsVUFBUCxDQUFtQmtDLE9BQW5CLENBQXJCLEdBQW9EQSxPQUFwRSxDQUFQO0lBQ0EsQ0ExQ2dCO0lBNENqQjtJQUNBO0lBQ0F5RyxLQUFLLEVBQUUsZUFBVTlXLElBQVYsRUFBaUI7TUFFdkI7TUFDQSxJQUFLLENBQUNBLElBQU4sRUFBYTtRQUNaLE9BQVMsS0FBTSxDQUFOLEtBQWEsS0FBTSxDQUFOLEVBQVUrSixVQUF6QixHQUF3QyxLQUFLM0osS0FBTCxHQUFhMlcsT0FBYixHQUF1QjVYLE1BQS9ELEdBQXdFLENBQUMsQ0FBaEY7TUFDQSxDQUxzQixDQU92Qjs7O01BQ0EsSUFBSyxPQUFPYSxJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO1FBQy9CLE9BQU81QixNQUFNLENBQUN1RixPQUFQLENBQWdCLEtBQU0sQ0FBTixDQUFoQixFQUEyQnZGLE1BQU0sQ0FBRTRCLElBQUYsQ0FBakMsQ0FBUDtNQUNBLENBVnNCLENBWXZCOzs7TUFDQSxPQUFPNUIsTUFBTSxDQUFDdUYsT0FBUCxFQUVOO01BQ0EzRCxJQUFJLENBQUNmLE1BQUwsR0FBY2UsSUFBSSxDQUFFLENBQUYsQ0FBbEIsR0FBMEJBLElBSHBCLEVBRzBCLElBSDFCLENBQVA7SUFJQSxDQS9EZ0I7SUFpRWpCZ1gsR0FBRyxFQUFFLGFBQVUzWSxRQUFWLEVBQW9CQyxPQUFwQixFQUE4QjtNQUNsQyxPQUFPLEtBQUtrQixTQUFMLENBQ05wQixNQUFNLENBQUMrUCxVQUFQLENBQ0MvUCxNQUFNLENBQUN1QixLQUFQLENBQWMsS0FBS0wsR0FBTCxFQUFkLEVBQTBCbEIsTUFBTSxDQUFFQyxRQUFGLEVBQVlDLE9BQVosQ0FBaEMsQ0FERCxDQURNLENBQVA7SUFLQSxDQXZFZ0I7SUF5RWpCMlksT0FBTyxFQUFFLGlCQUFVNVksUUFBVixFQUFxQjtNQUM3QixPQUFPLEtBQUsyWSxHQUFMLENBQVUzWSxRQUFRLElBQUksSUFBWixHQUNoQixLQUFLdUIsVUFEVyxHQUNFLEtBQUtBLFVBQUwsQ0FBZ0I2TSxNQUFoQixDQUF3QnBPLFFBQXhCLENBRFosQ0FBUDtJQUdBO0VBN0VnQixDQUFsQjs7RUFnRkEsU0FBUzZZLE9BQVQsQ0FBa0JqTSxHQUFsQixFQUF1QjRELEdBQXZCLEVBQTZCO0lBQzVCLEdBQUc7TUFDRjVELEdBQUcsR0FBR0EsR0FBRyxDQUFFNEQsR0FBRixDQUFUO0lBQ0EsQ0FGRCxRQUVVNUQsR0FBRyxJQUFJQSxHQUFHLENBQUN2SSxRQUFKLEtBQWlCLENBRmxDOztJQUlBLE9BQU91SSxHQUFQO0VBQ0E7O0VBRUQ3TSxNQUFNLENBQUN5QixJQUFQLENBQWE7SUFDWmdNLE1BQU0sRUFBRSxnQkFBVTdMLElBQVYsRUFBaUI7TUFDeEIsSUFBSTZMLE1BQU0sR0FBRzdMLElBQUksQ0FBQytKLFVBQWxCO01BQ0EsT0FBTzhCLE1BQU0sSUFBSUEsTUFBTSxDQUFDbkosUUFBUCxLQUFvQixFQUE5QixHQUFtQ21KLE1BQW5DLEdBQTRDLElBQW5EO0lBQ0EsQ0FKVztJQUtac0wsT0FBTyxFQUFFLGlCQUFVblgsSUFBVixFQUFpQjtNQUN6QixPQUFPNk8sR0FBRyxDQUFFN08sSUFBRixFQUFRLFlBQVIsQ0FBVjtJQUNBLENBUFc7SUFRWm9YLFlBQVksRUFBRSxzQkFBVXBYLElBQVYsRUFBZ0JDLENBQWhCLEVBQW1CZ1YsS0FBbkIsRUFBMkI7TUFDeEMsT0FBT3BHLEdBQUcsQ0FBRTdPLElBQUYsRUFBUSxZQUFSLEVBQXNCaVYsS0FBdEIsQ0FBVjtJQUNBLENBVlc7SUFXWnNCLElBQUksRUFBRSxjQUFVdlcsSUFBVixFQUFpQjtNQUN0QixPQUFPa1gsT0FBTyxDQUFFbFgsSUFBRixFQUFRLGFBQVIsQ0FBZDtJQUNBLENBYlc7SUFjWndXLElBQUksRUFBRSxjQUFVeFcsSUFBVixFQUFpQjtNQUN0QixPQUFPa1gsT0FBTyxDQUFFbFgsSUFBRixFQUFRLGlCQUFSLENBQWQ7SUFDQSxDQWhCVztJQWlCWnFYLE9BQU8sRUFBRSxpQkFBVXJYLElBQVYsRUFBaUI7TUFDekIsT0FBTzZPLEdBQUcsQ0FBRTdPLElBQUYsRUFBUSxhQUFSLENBQVY7SUFDQSxDQW5CVztJQW9CWitXLE9BQU8sRUFBRSxpQkFBVS9XLElBQVYsRUFBaUI7TUFDekIsT0FBTzZPLEdBQUcsQ0FBRTdPLElBQUYsRUFBUSxpQkFBUixDQUFWO0lBQ0EsQ0F0Qlc7SUF1QlpzWCxTQUFTLEVBQUUsbUJBQVV0WCxJQUFWLEVBQWdCQyxDQUFoQixFQUFtQmdWLEtBQW5CLEVBQTJCO01BQ3JDLE9BQU9wRyxHQUFHLENBQUU3TyxJQUFGLEVBQVEsYUFBUixFQUF1QmlWLEtBQXZCLENBQVY7SUFDQSxDQXpCVztJQTBCWnNDLFNBQVMsRUFBRSxtQkFBVXZYLElBQVYsRUFBZ0JDLENBQWhCLEVBQW1CZ1YsS0FBbkIsRUFBMkI7TUFDckMsT0FBT3BHLEdBQUcsQ0FBRTdPLElBQUYsRUFBUSxpQkFBUixFQUEyQmlWLEtBQTNCLENBQVY7SUFDQSxDQTVCVztJQTZCWkcsUUFBUSxFQUFFLGtCQUFVcFYsSUFBVixFQUFpQjtNQUMxQixPQUFPb1YsU0FBUSxDQUFFLENBQUVwVixJQUFJLENBQUMrSixVQUFMLElBQW1CLEVBQXJCLEVBQTBCeUUsVUFBNUIsRUFBd0N4TyxJQUF4QyxDQUFmO0lBQ0EsQ0EvQlc7SUFnQ1pxVyxRQUFRLEVBQUUsa0JBQVVyVyxJQUFWLEVBQWlCO01BQzFCLE9BQU9vVixTQUFRLENBQUVwVixJQUFJLENBQUN3TyxVQUFQLENBQWY7SUFDQSxDQWxDVztJQW1DWjhILFFBQVEsRUFBRSxrQkFBVXRXLElBQVYsRUFBaUI7TUFDMUIsT0FBTzVCLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJuRCxJQUFqQixFQUF1QixRQUF2QixJQUNOQSxJQUFJLENBQUN3WCxlQUFMLElBQXdCeFgsSUFBSSxDQUFDeVgsYUFBTCxDQUFtQnJhLFFBRHJDLEdBRU5nQixNQUFNLENBQUN1QixLQUFQLENBQWMsRUFBZCxFQUFrQkssSUFBSSxDQUFDd0ksVUFBdkIsQ0FGRDtJQUdBO0VBdkNXLENBQWIsRUF3Q0csVUFBVXhILElBQVYsRUFBZ0J6QyxFQUFoQixFQUFxQjtJQUN2QkgsTUFBTSxDQUFDRyxFQUFQLENBQVd5QyxJQUFYLElBQW9CLFVBQVVpVSxLQUFWLEVBQWlCNVcsUUFBakIsRUFBNEI7TUFDL0MsSUFBSXFCLEdBQUcsR0FBR3RCLE1BQU0sQ0FBQzJCLEdBQVAsQ0FBWSxJQUFaLEVBQWtCeEIsRUFBbEIsRUFBc0IwVyxLQUF0QixDQUFWOztNQUVBLElBQUtqVSxJQUFJLENBQUN0RCxLQUFMLENBQVksQ0FBQyxDQUFiLE1BQXFCLE9BQTFCLEVBQW9DO1FBQ25DVyxRQUFRLEdBQUc0VyxLQUFYO01BQ0E7O01BRUQsSUFBSzVXLFFBQVEsSUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXJDLEVBQWdEO1FBQy9DcUIsR0FBRyxHQUFHdEIsTUFBTSxDQUFDcU8sTUFBUCxDQUFlcE8sUUFBZixFQUF5QnFCLEdBQXpCLENBQU47TUFDQTs7TUFFRCxJQUFLLEtBQUtQLE1BQUwsR0FBYyxDQUFuQixFQUF1QjtRQUV0QjtRQUNBLElBQUssQ0FBQ2lYLGdCQUFnQixDQUFFcFYsSUFBRixDQUF0QixFQUFpQztVQUNoQ3RCLEdBQUcsR0FBR3RCLE1BQU0sQ0FBQytQLFVBQVAsQ0FBbUJ6TyxHQUFuQixDQUFOO1FBQ0EsQ0FMcUIsQ0FPdEI7OztRQUNBLElBQUt5VyxZQUFZLENBQUMxTSxJQUFiLENBQW1CekksSUFBbkIsQ0FBTCxFQUFpQztVQUNoQ3RCLEdBQUcsR0FBR0EsR0FBRyxDQUFDZ1ksT0FBSixFQUFOO1FBQ0E7TUFDRDs7TUFFRCxPQUFPLEtBQUtsWSxTQUFMLENBQWdCRSxHQUFoQixDQUFQO0lBQ0EsQ0F6QkQ7RUEwQkEsQ0FuRUQ7RUFvRUEsSUFBSWlZLFNBQVMsR0FBSyxNQUFsQixDQTVpRzhFLENBZ2pHOUU7O0VBQ0EsU0FBU0MsYUFBVCxDQUF3QjNXLE9BQXhCLEVBQWtDO0lBQ2pDLElBQUk0VyxNQUFNLEdBQUcsRUFBYjtJQUNBelosTUFBTSxDQUFDeUIsSUFBUCxDQUFhb0IsT0FBTyxDQUFDNkgsS0FBUixDQUFlNk8sU0FBZixLQUE4QixFQUEzQyxFQUErQyxVQUFVMVAsQ0FBVixFQUFhNlAsSUFBYixFQUFvQjtNQUNsRUQsTUFBTSxDQUFFQyxJQUFGLENBQU4sR0FBaUIsSUFBakI7SUFDQSxDQUZEO0lBR0EsT0FBT0QsTUFBUDtFQUNBO0VBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztFQUNBelosTUFBTSxDQUFDMlosU0FBUCxHQUFtQixVQUFVOVcsT0FBVixFQUFvQjtJQUV0QztJQUNBO0lBQ0FBLE9BQU8sR0FBRyxPQUFPQSxPQUFQLEtBQW1CLFFBQW5CLEdBQ1QyVyxhQUFhLENBQUUzVyxPQUFGLENBREosR0FFVDdDLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZSxFQUFmLEVBQW1CSyxPQUFuQixDQUZEOztJQUlBLElBQUk7SUFDSCtXLE1BREQ7SUFBQSxJQUdDO0lBQ0FDLE1BSkQ7SUFBQSxJQU1DO0lBQ0FDLE1BUEQ7SUFBQSxJQVNDO0lBQ0FDLE9BVkQ7SUFBQSxJQVlDO0lBQ0F4UixJQUFJLEdBQUcsRUFiUjtJQUFBLElBZUM7SUFDQXlSLEtBQUssR0FBRyxFQWhCVDtJQUFBLElBa0JDO0lBQ0FDLFdBQVcsR0FBRyxDQUFDLENBbkJoQjtJQUFBLElBcUJDO0lBQ0FDLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVc7TUFFakI7TUFDQUgsT0FBTSxHQUFHbFgsT0FBTyxDQUFDc1gsSUFBakIsQ0FIaUIsQ0FLakI7TUFDQTs7TUFDQUwsTUFBSyxHQUFHRixNQUFNLEdBQUcsSUFBakI7O01BQ0EsT0FBUUksS0FBSyxDQUFDalosTUFBZCxFQUFzQmtaLFdBQVcsR0FBRyxDQUFDLENBQXJDLEVBQXlDO1FBQ3hDSixNQUFNLEdBQUdHLEtBQUssQ0FBQzlOLEtBQU4sRUFBVDs7UUFDQSxPQUFRLEVBQUUrTixXQUFGLEdBQWdCMVIsSUFBSSxDQUFDeEgsTUFBN0IsRUFBc0M7VUFFckM7VUFDQSxJQUFLd0gsSUFBSSxDQUFFMFIsV0FBRixDQUFKLENBQW9CblksS0FBcEIsQ0FBMkIrWCxNQUFNLENBQUUsQ0FBRixDQUFqQyxFQUF3Q0EsTUFBTSxDQUFFLENBQUYsQ0FBOUMsTUFBMEQsS0FBMUQsSUFDSmhYLE9BQU8sQ0FBQ3VYLFdBRFQsRUFDdUI7WUFFdEI7WUFDQUgsV0FBVyxHQUFHMVIsSUFBSSxDQUFDeEgsTUFBbkI7WUFDQThZLE1BQU0sR0FBRyxLQUFUO1VBQ0E7UUFDRDtNQUNELENBckJnQixDQXVCakI7OztNQUNBLElBQUssQ0FBQ2hYLE9BQU8sQ0FBQ2dYLE1BQWQsRUFBdUI7UUFDdEJBLE1BQU0sR0FBRyxLQUFUO01BQ0E7O01BRURELE1BQU0sR0FBRyxLQUFULENBNUJpQixDQThCakI7O01BQ0EsSUFBS0csT0FBTCxFQUFjO1FBRWI7UUFDQSxJQUFLRixNQUFMLEVBQWM7VUFDYnRSLElBQUksR0FBRyxFQUFQLENBRGEsQ0FHZDtRQUNDLENBSkQsTUFJTztVQUNOQSxJQUFJLEdBQUcsRUFBUDtRQUNBO01BQ0Q7SUFDRCxDQWhFRjtJQUFBLElBa0VDO0lBQ0FrUCxJQUFJLEdBQUc7TUFFTjtNQUNBbUIsR0FBRyxFQUFFLGVBQVc7UUFDZixJQUFLclEsSUFBTCxFQUFZO1VBRVg7VUFDQSxJQUFLc1IsTUFBTSxJQUFJLENBQUNELE1BQWhCLEVBQXlCO1lBQ3hCSyxXQUFXLEdBQUcxUixJQUFJLENBQUN4SCxNQUFMLEdBQWMsQ0FBNUI7WUFDQWlaLEtBQUssQ0FBQ3hhLElBQU4sQ0FBWXFhLE1BQVo7VUFDQTs7VUFFRCxDQUFFLFNBQVNqQixHQUFULENBQWN6UyxJQUFkLEVBQXFCO1lBQ3RCbkcsTUFBTSxDQUFDeUIsSUFBUCxDQUFhMEUsSUFBYixFQUFtQixVQUFVMEQsQ0FBVixFQUFhOUQsR0FBYixFQUFtQjtjQUNyQyxJQUFLL0YsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQjhDLEdBQW5CLENBQUwsRUFBZ0M7Z0JBQy9CLElBQUssQ0FBQ2xELE9BQU8sQ0FBQzhULE1BQVQsSUFBbUIsQ0FBQ2MsSUFBSSxDQUFDWSxHQUFMLENBQVV0UyxHQUFWLENBQXpCLEVBQTJDO2tCQUMxQ3dDLElBQUksQ0FBQy9JLElBQUwsQ0FBV3VHLEdBQVg7Z0JBQ0E7Y0FDRCxDQUpELE1BSU8sSUFBS0EsR0FBRyxJQUFJQSxHQUFHLENBQUNoRixNQUFYLElBQXFCZixNQUFNLENBQUM4RCxJQUFQLENBQWFpQyxHQUFiLE1BQXVCLFFBQWpELEVBQTREO2dCQUVsRTtnQkFDQTZTLEdBQUcsQ0FBRTdTLEdBQUYsQ0FBSDtjQUNBO1lBQ0QsQ0FWRDtVQVdBLENBWkQsRUFZS2hFLFNBWkw7O1VBY0EsSUFBSzhYLE1BQU0sSUFBSSxDQUFDRCxNQUFoQixFQUF5QjtZQUN4Qk0sSUFBSTtVQUNKO1FBQ0Q7O1FBQ0QsT0FBTyxJQUFQO01BQ0EsQ0EvQks7TUFpQ047TUFDQUcsTUFBTSxFQUFFLGtCQUFXO1FBQ2xCcmEsTUFBTSxDQUFDeUIsSUFBUCxDQUFhTSxTQUFiLEVBQXdCLFVBQVU4SCxDQUFWLEVBQWE5RCxHQUFiLEVBQW1CO1VBQzFDLElBQUkyUyxLQUFKOztVQUNBLE9BQVEsQ0FBRUEsS0FBSyxHQUFHMVksTUFBTSxDQUFDdUYsT0FBUCxDQUFnQlEsR0FBaEIsRUFBcUJ3QyxJQUFyQixFQUEyQm1RLEtBQTNCLENBQVYsSUFBaUQsQ0FBQyxDQUExRCxFQUE4RDtZQUM3RG5RLElBQUksQ0FBQ2hHLE1BQUwsQ0FBYW1XLEtBQWIsRUFBb0IsQ0FBcEIsRUFENkQsQ0FHN0Q7O1lBQ0EsSUFBS0EsS0FBSyxJQUFJdUIsV0FBZCxFQUE0QjtjQUMzQkEsV0FBVztZQUNYO1VBQ0Q7UUFDRCxDQVZEO1FBV0EsT0FBTyxJQUFQO01BQ0EsQ0EvQ0s7TUFpRE47TUFDQTtNQUNBNUIsR0FBRyxFQUFFLGFBQVVsWSxFQUFWLEVBQWU7UUFDbkIsT0FBT0EsRUFBRSxHQUNSSCxNQUFNLENBQUN1RixPQUFQLENBQWdCcEYsRUFBaEIsRUFBb0JvSSxJQUFwQixJQUE2QixDQUFDLENBRHRCLEdBRVJBLElBQUksQ0FBQ3hILE1BQUwsR0FBYyxDQUZmO01BR0EsQ0F2REs7TUF5RE47TUFDQXVaLEtBQUssRUFBRSxpQkFBVztRQUNqQixJQUFLL1IsSUFBTCxFQUFZO1VBQ1hBLElBQUksR0FBRyxFQUFQO1FBQ0E7O1FBQ0QsT0FBTyxJQUFQO01BQ0EsQ0EvREs7TUFpRU47TUFDQTtNQUNBO01BQ0FnUyxPQUFPLEVBQUUsbUJBQVc7UUFDbkJSLE9BQU0sR0FBR0MsS0FBSyxHQUFHLEVBQWpCO1FBQ0F6UixJQUFJLEdBQUdzUixNQUFNLEdBQUcsRUFBaEI7UUFDQSxPQUFPLElBQVA7TUFDQSxDQXhFSztNQXlFTmhILFFBQVEsRUFBRSxvQkFBVztRQUNwQixPQUFPLENBQUN0SyxJQUFSO01BQ0EsQ0EzRUs7TUE2RU47TUFDQTtNQUNBO01BQ0FpUyxJQUFJLEVBQUUsZ0JBQVc7UUFDaEJULE9BQU0sR0FBRyxJQUFUOztRQUNBLElBQUssQ0FBQ0YsTUFBTixFQUFlO1VBQ2RwQyxJQUFJLENBQUM4QyxPQUFMO1FBQ0E7O1FBQ0QsT0FBTyxJQUFQO01BQ0EsQ0F0Rks7TUF1Rk5SLE1BQU0sRUFBRSxrQkFBVztRQUNsQixPQUFPLENBQUMsQ0FBQ0EsT0FBVDtNQUNBLENBekZLO01BMkZOO01BQ0FVLFFBQVEsRUFBRSxrQkFBVXZhLE9BQVYsRUFBbUJpRyxJQUFuQixFQUEwQjtRQUNuQyxJQUFLLENBQUM0VCxPQUFOLEVBQWU7VUFDZDVULElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7VUFDQUEsSUFBSSxHQUFHLENBQUVqRyxPQUFGLEVBQVdpRyxJQUFJLENBQUM3RyxLQUFMLEdBQWE2RyxJQUFJLENBQUM3RyxLQUFMLEVBQWIsR0FBNEI2RyxJQUF2QyxDQUFQO1VBQ0E2VCxLQUFLLENBQUN4YSxJQUFOLENBQVkyRyxJQUFaOztVQUNBLElBQUssQ0FBQ3lULE1BQU4sRUFBZTtZQUNkTSxJQUFJO1VBQ0o7UUFDRDs7UUFDRCxPQUFPLElBQVA7TUFDQSxDQXRHSztNQXdHTjtNQUNBQSxJQUFJLEVBQUUsZ0JBQVc7UUFDaEJ6QyxJQUFJLENBQUNnRCxRQUFMLENBQWUsSUFBZixFQUFxQjFZLFNBQXJCO1FBQ0EsT0FBTyxJQUFQO01BQ0EsQ0E1R0s7TUE4R047TUFDQStYLEtBQUssRUFBRSxpQkFBVztRQUNqQixPQUFPLENBQUMsQ0FBQ0EsTUFBVDtNQUNBO0lBakhLLENBbkVSOztJQXVMQSxPQUFPckMsSUFBUDtFQUNBLENBaE1EOztFQW1NQXpYLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZTtJQUVka1ksUUFBUSxFQUFFLGtCQUFVQyxJQUFWLEVBQWlCO01BQzFCLElBQUlDLE1BQU0sR0FBRyxDQUVYO01BQ0EsQ0FBRSxTQUFGLEVBQWEsTUFBYixFQUFxQjVhLE1BQU0sQ0FBQzJaLFNBQVAsQ0FBa0IsYUFBbEIsQ0FBckIsRUFBd0QsVUFBeEQsQ0FIVyxFQUlYLENBQUUsUUFBRixFQUFZLE1BQVosRUFBb0IzWixNQUFNLENBQUMyWixTQUFQLENBQWtCLGFBQWxCLENBQXBCLEVBQXVELFVBQXZELENBSlcsRUFLWCxDQUFFLFFBQUYsRUFBWSxVQUFaLEVBQXdCM1osTUFBTSxDQUFDMlosU0FBUCxDQUFrQixRQUFsQixDQUF4QixDQUxXLENBQWI7TUFBQSxJQU9Da0IsTUFBSyxHQUFHLFNBUFQ7TUFBQSxJQVFDQyxRQUFPLEdBQUc7UUFDVEQsS0FBSyxFQUFFLGlCQUFXO1VBQ2pCLE9BQU9BLE1BQVA7UUFDQSxDQUhRO1FBSVRFLE1BQU0sRUFBRSxrQkFBVztVQUNsQkMsUUFBUSxDQUFDcFQsSUFBVCxDQUFlN0YsU0FBZixFQUEyQmtaLElBQTNCLENBQWlDbFosU0FBakM7VUFDQSxPQUFPLElBQVA7UUFDQSxDQVBRO1FBUVRtWixJQUFJLEVBQUU7VUFBVTtRQUFWLE9BQTZDO1VBQ2xELElBQUlDLEdBQUcsR0FBR3BaLFNBQVY7VUFDQSxPQUFPL0IsTUFBTSxDQUFDMGEsUUFBUCxDQUFpQixVQUFVVSxRQUFWLEVBQXFCO1lBQzVDcGIsTUFBTSxDQUFDeUIsSUFBUCxDQUFhbVosTUFBYixFQUFxQixVQUFVL1ksQ0FBVixFQUFhd1osS0FBYixFQUFxQjtjQUN6QyxJQUFJbGIsRUFBRSxHQUFHSCxNQUFNLENBQUNpRCxVQUFQLENBQW1Ca1ksR0FBRyxDQUFFdFosQ0FBRixDQUF0QixLQUFpQ3NaLEdBQUcsQ0FBRXRaLENBQUYsQ0FBN0MsQ0FEeUMsQ0FHekM7O2NBQ0FtWixRQUFRLENBQUVLLEtBQUssQ0FBRSxDQUFGLENBQVAsQ0FBUixDQUF3QixZQUFXO2dCQUNsQyxJQUFJQyxRQUFRLEdBQUduYixFQUFFLElBQUlBLEVBQUUsQ0FBQzJCLEtBQUgsQ0FBVSxJQUFWLEVBQWdCQyxTQUFoQixDQUFyQjs7Z0JBQ0EsSUFBS3VaLFFBQVEsSUFBSXRiLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUJxWSxRQUFRLENBQUNSLE9BQTVCLENBQWpCLEVBQXlEO2tCQUN4RFEsUUFBUSxDQUFDUixPQUFULEdBQ0VTLFFBREYsQ0FDWUgsUUFBUSxDQUFDSSxNQURyQixFQUVFNVQsSUFGRixDQUVRd1QsUUFBUSxDQUFDSyxPQUZqQixFQUdFUixJQUhGLENBR1FHLFFBQVEsQ0FBQ00sTUFIakI7Z0JBSUEsQ0FMRCxNQUtPO2tCQUNOTixRQUFRLENBQUVDLEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYSxNQUFmLENBQVIsQ0FDQyxTQUFTUCxRQUFULEdBQW1CTSxRQUFRLENBQUNOLE9BQVQsRUFBbkIsR0FBd0MsSUFEekMsRUFFQzNhLEVBQUUsR0FBRyxDQUFFbWIsUUFBRixDQUFILEdBQWtCdlosU0FGckI7Z0JBSUE7Y0FDRCxDQWJEO1lBY0EsQ0FsQkQ7WUFtQkFvWixHQUFHLEdBQUcsSUFBTjtVQUNBLENBckJNLEVBcUJITCxPQXJCRyxFQUFQO1FBc0JBLENBaENRO1FBa0NUO1FBQ0E7UUFDQUEsT0FBTyxFQUFFLGlCQUFValgsR0FBVixFQUFnQjtVQUN4QixPQUFPQSxHQUFHLElBQUksSUFBUCxHQUFjN0QsTUFBTSxDQUFDd0MsTUFBUCxDQUFlcUIsR0FBZixFQUFvQmlYLFFBQXBCLENBQWQsR0FBOENBLFFBQXJEO1FBQ0E7TUF0Q1EsQ0FSWDtNQUFBLElBZ0RDRSxRQUFRLEdBQUcsRUFoRFosQ0FEMEIsQ0FtRDFCOztNQUNBRixRQUFPLENBQUNhLElBQVIsR0FBZWIsUUFBTyxDQUFDSSxJQUF2QixDQXBEMEIsQ0FzRDFCOztNQUNBbGIsTUFBTSxDQUFDeUIsSUFBUCxDQUFhbVosTUFBYixFQUFxQixVQUFVL1ksQ0FBVixFQUFhd1osS0FBYixFQUFxQjtRQUN6QyxJQUFJOVMsSUFBSSxHQUFHOFMsS0FBSyxDQUFFLENBQUYsQ0FBaEI7UUFBQSxJQUNDTyxXQUFXLEdBQUdQLEtBQUssQ0FBRSxDQUFGLENBRHBCLENBRHlDLENBSXpDOztRQUNBUCxRQUFPLENBQUVPLEtBQUssQ0FBRSxDQUFGLENBQVAsQ0FBUCxHQUF3QjlTLElBQUksQ0FBQ3FRLEdBQTdCLENBTHlDLENBT3pDOztRQUNBLElBQUtnRCxXQUFMLEVBQW1CO1VBQ2xCclQsSUFBSSxDQUFDcVEsR0FBTCxDQUFVLFlBQVc7WUFFcEI7WUFDQWlDLE1BQUssR0FBR2UsV0FBUixDQUhvQixDQUtyQjtVQUNDLENBTkQsRUFNR2hCLE1BQU0sQ0FBRS9ZLENBQUMsR0FBRyxDQUFOLENBQU4sQ0FBaUIsQ0FBakIsRUFBcUIwWSxPQU54QixFQU1pQ0ssTUFBTSxDQUFFLENBQUYsQ0FBTixDQUFhLENBQWIsRUFBaUJKLElBTmxEO1FBT0EsQ0FoQndDLENBa0J6Qzs7O1FBQ0FRLFFBQVEsQ0FBRUssS0FBSyxDQUFFLENBQUYsQ0FBUCxDQUFSLEdBQXlCLFlBQVc7VUFDbkNMLFFBQVEsQ0FBRUssS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhLE1BQWYsQ0FBUixDQUFpQyxTQUFTTCxRQUFULEdBQW9CRixRQUFwQixHQUE4QixJQUEvRCxFQUFxRS9ZLFNBQXJFO1VBQ0EsT0FBTyxJQUFQO1FBQ0EsQ0FIRDs7UUFJQWlaLFFBQVEsQ0FBRUssS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhLE1BQWYsQ0FBUixHQUFrQzlTLElBQUksQ0FBQ2tTLFFBQXZDO01BQ0EsQ0F4QkQsRUF2RDBCLENBaUYxQjs7TUFDQUssUUFBTyxDQUFDQSxPQUFSLENBQWlCRSxRQUFqQixFQWxGMEIsQ0FvRjFCOzs7TUFDQSxJQUFLTCxJQUFMLEVBQVk7UUFDWEEsSUFBSSxDQUFDMVosSUFBTCxDQUFXK1osUUFBWCxFQUFxQkEsUUFBckI7TUFDQSxDQXZGeUIsQ0F5RjFCOzs7TUFDQSxPQUFPQSxRQUFQO0lBQ0EsQ0E3RmE7SUErRmQ7SUFDQWEsSUFBSSxFQUFFLGNBQVVDO0lBQVk7SUFBdEIsRUFBa0Q7TUFDdkQsSUFBSWphLENBQUMsR0FBRyxDQUFSO01BQUEsSUFDQ2thLGFBQWEsR0FBR3pjLE1BQUssQ0FBQzJCLElBQU4sQ0FBWWMsU0FBWixDQURqQjtNQUFBLElBRUNoQixNQUFNLEdBQUdnYixhQUFhLENBQUNoYixNQUZ4QjtNQUFBLElBSUM7TUFDQWliLFNBQVMsR0FBR2piLE1BQU0sS0FBSyxDQUFYLElBQ1QrYSxXQUFXLElBQUk5YixNQUFNLENBQUNpRCxVQUFQLENBQW1CNlksV0FBVyxDQUFDaEIsT0FBL0IsQ0FETixHQUNtRC9aLE1BRG5ELEdBQzRELENBTnpFO01BQUEsSUFRQztNQUNBO01BQ0FpYSxRQUFRLEdBQUdnQixTQUFTLEtBQUssQ0FBZCxHQUFrQkYsV0FBbEIsR0FBZ0M5YixNQUFNLENBQUMwYSxRQUFQLEVBVjVDO01BQUEsSUFZQztNQUNBdUIsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVXBhLENBQVYsRUFBYTJTLFFBQWIsRUFBdUIwSCxNQUF2QixFQUFnQztRQUM1QyxPQUFPLFVBQVVsVyxLQUFWLEVBQWtCO1VBQ3hCd08sUUFBUSxDQUFFM1MsQ0FBRixDQUFSLEdBQWdCLElBQWhCO1VBQ0FxYSxNQUFNLENBQUVyYSxDQUFGLENBQU4sR0FBY0UsU0FBUyxDQUFDaEIsTUFBVixHQUFtQixDQUFuQixHQUF1QnpCLE1BQUssQ0FBQzJCLElBQU4sQ0FBWWMsU0FBWixDQUF2QixHQUFpRGlFLEtBQS9EOztVQUNBLElBQUtrVyxNQUFNLEtBQUtDLGNBQWhCLEVBQWlDO1lBQ2hDbkIsUUFBUSxDQUFDb0IsVUFBVCxDQUFxQjVILFFBQXJCLEVBQStCMEgsTUFBL0I7VUFFQSxDQUhELE1BR08sSUFBSyxDQUFHLEdBQUVGLFNBQVYsRUFBd0I7WUFDOUJoQixRQUFRLENBQUNxQixXQUFULENBQXNCN0gsUUFBdEIsRUFBZ0MwSCxNQUFoQztVQUNBO1FBQ0QsQ0FURDtNQVVBLENBeEJGO01BQUEsSUEwQkNDLGNBMUJEO01BQUEsSUEwQmlCRyxnQkExQmpCO01BQUEsSUEwQm1DQyxlQTFCbkMsQ0FEdUQsQ0E2QnZEOzs7TUFDQSxJQUFLeGIsTUFBTSxHQUFHLENBQWQsRUFBa0I7UUFDakJvYixjQUFjLEdBQUcsSUFBSXBZLEtBQUosQ0FBV2hELE1BQVgsQ0FBakI7UUFDQXViLGdCQUFnQixHQUFHLElBQUl2WSxLQUFKLENBQVdoRCxNQUFYLENBQW5CO1FBQ0F3YixlQUFlLEdBQUcsSUFBSXhZLEtBQUosQ0FBV2hELE1BQVgsQ0FBbEI7O1FBQ0EsT0FBUWMsQ0FBQyxHQUFHZCxNQUFaLEVBQW9CYyxDQUFDLEVBQXJCLEVBQTBCO1VBQ3pCLElBQUtrYSxhQUFhLENBQUVsYSxDQUFGLENBQWIsSUFBc0I3QixNQUFNLENBQUNpRCxVQUFQLENBQW1COFksYUFBYSxDQUFFbGEsQ0FBRixDQUFiLENBQW1CaVosT0FBdEMsQ0FBM0IsRUFBNkU7WUFDNUVpQixhQUFhLENBQUVsYSxDQUFGLENBQWIsQ0FBbUJpWixPQUFuQixHQUNFUyxRQURGLENBQ1lVLFVBQVUsQ0FBRXBhLENBQUYsRUFBS3lhLGdCQUFMLEVBQXVCSCxjQUF2QixDQUR0QixFQUVFdlUsSUFGRixDQUVRcVUsVUFBVSxDQUFFcGEsQ0FBRixFQUFLMGEsZUFBTCxFQUFzQlIsYUFBdEIsQ0FGbEIsRUFHRWQsSUFIRixDQUdRRCxRQUFRLENBQUNVLE1BSGpCO1VBSUEsQ0FMRCxNQUtPO1lBQ04sRUFBRU0sU0FBRjtVQUNBO1FBQ0Q7TUFDRCxDQTVDc0QsQ0E4Q3ZEOzs7TUFDQSxJQUFLLENBQUNBLFNBQU4sRUFBa0I7UUFDakJoQixRQUFRLENBQUNxQixXQUFULENBQXNCRSxlQUF0QixFQUF1Q1IsYUFBdkM7TUFDQTs7TUFFRCxPQUFPZixRQUFRLENBQUNGLE9BQVQsRUFBUDtJQUNBO0VBcEphLENBQWYsRUFseEc4RSxDQTA2RzlFOztFQUNBLElBQUkwQixTQUFKOztFQUVBeGMsTUFBTSxDQUFDRyxFQUFQLENBQVUyWCxLQUFWLEdBQWtCLFVBQVUzWCxFQUFWLEVBQWU7SUFFaEM7SUFDQUgsTUFBTSxDQUFDOFgsS0FBUCxDQUFhZ0QsT0FBYixHQUF1QmxULElBQXZCLENBQTZCekgsRUFBN0I7SUFFQSxPQUFPLElBQVA7RUFDQSxDQU5EOztFQVFBSCxNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFFZDtJQUNBaUIsT0FBTyxFQUFFLEtBSEs7SUFLZDtJQUNBO0lBQ0FnWixTQUFTLEVBQUUsQ0FQRztJQVNkO0lBQ0FDLFNBQVMsRUFBRSxtQkFBVUMsSUFBVixFQUFpQjtNQUMzQixJQUFLQSxJQUFMLEVBQVk7UUFDWDNjLE1BQU0sQ0FBQ3ljLFNBQVA7TUFDQSxDQUZELE1BRU87UUFDTnpjLE1BQU0sQ0FBQzhYLEtBQVAsQ0FBYyxJQUFkO01BQ0E7SUFDRCxDQWhCYTtJQWtCZDtJQUNBQSxLQUFLLEVBQUUsZUFBVThFLElBQVYsRUFBaUI7TUFFdkI7TUFDQSxJQUFLQSxJQUFJLEtBQUssSUFBVCxHQUFnQixFQUFFNWMsTUFBTSxDQUFDeWMsU0FBekIsR0FBcUN6YyxNQUFNLENBQUN5RCxPQUFqRCxFQUEyRDtRQUMxRDtNQUNBLENBTHNCLENBT3ZCOzs7TUFDQXpELE1BQU0sQ0FBQ3lELE9BQVAsR0FBaUIsSUFBakIsQ0FSdUIsQ0FVdkI7O01BQ0EsSUFBS21aLElBQUksS0FBSyxJQUFULElBQWlCLEVBQUU1YyxNQUFNLENBQUN5YyxTQUFULEdBQXFCLENBQTNDLEVBQStDO1FBQzlDO01BQ0EsQ0Fic0IsQ0FldkI7OztNQUNBRCxTQUFTLENBQUNILFdBQVYsQ0FBdUJyZCxRQUF2QixFQUFpQyxDQUFFZ0IsTUFBRixDQUFqQyxFQWhCdUIsQ0FrQnZCOztNQUNBLElBQUtBLE1BQU0sQ0FBQ0csRUFBUCxDQUFVMGMsY0FBZixFQUFnQztRQUMvQjdjLE1BQU0sQ0FBRWhCLFFBQUYsQ0FBTixDQUFtQjZkLGNBQW5CLENBQW1DLE9BQW5DO1FBQ0E3YyxNQUFNLENBQUVoQixRQUFGLENBQU4sQ0FBbUI4ZCxHQUFuQixDQUF3QixPQUF4QjtNQUNBO0lBQ0Q7RUExQ2EsQ0FBZjtFQTZDQTtBQUNBO0FBQ0E7O0VBQ0EsU0FBU0MsTUFBVCxHQUFrQjtJQUNqQixJQUFLL2QsUUFBUSxDQUFDNk8sZ0JBQWQsRUFBaUM7TUFDaEM3TyxRQUFRLENBQUNnZSxtQkFBVCxDQUE4QixrQkFBOUIsRUFBa0RDLFNBQWxEO01BQ0E5ZCxNQUFNLENBQUM2ZCxtQkFBUCxDQUE0QixNQUE1QixFQUFvQ0MsU0FBcEM7SUFFQSxDQUpELE1BSU87TUFDTmplLFFBQVEsQ0FBQ2tlLFdBQVQsQ0FBc0Isb0JBQXRCLEVBQTRDRCxTQUE1QztNQUNBOWQsTUFBTSxDQUFDK2QsV0FBUCxDQUFvQixRQUFwQixFQUE4QkQsU0FBOUI7SUFDQTtFQUNEO0VBRUQ7QUFDQTtBQUNBOzs7RUFDQSxTQUFTQSxTQUFULEdBQXFCO0lBRXBCO0lBQ0EsSUFBS2plLFFBQVEsQ0FBQzZPLGdCQUFULElBQ0oxTyxNQUFNLENBQUNnZSxLQUFQLENBQWFyWixJQUFiLEtBQXNCLE1BRGxCLElBRUo5RSxRQUFRLENBQUNvZSxVQUFULEtBQXdCLFVBRnpCLEVBRXNDO01BRXJDTCxNQUFNO01BQ04vYyxNQUFNLENBQUM4WCxLQUFQO0lBQ0E7RUFDRDs7RUFFRDlYLE1BQU0sQ0FBQzhYLEtBQVAsQ0FBYWdELE9BQWIsR0FBdUIsVUFBVWpYLEdBQVYsRUFBZ0I7SUFDdEMsSUFBSyxDQUFDMlksU0FBTixFQUFrQjtNQUVqQkEsU0FBUyxHQUFHeGMsTUFBTSxDQUFDMGEsUUFBUCxFQUFaLENBRmlCLENBSWpCO01BQ0E7TUFDQTtNQUNBOztNQUNBLElBQUsxYixRQUFRLENBQUNvZSxVQUFULEtBQXdCLFVBQXhCLElBQ0ZwZSxRQUFRLENBQUNvZSxVQUFULEtBQXdCLFNBQXhCLElBQXFDLENBQUNwZSxRQUFRLENBQUNzTyxlQUFULENBQXlCK1AsUUFEbEUsRUFDK0U7UUFFOUU7UUFDQWxlLE1BQU0sQ0FBQ21lLFVBQVAsQ0FBbUJ0ZCxNQUFNLENBQUM4WCxLQUExQixFQUg4RSxDQUsvRTtNQUNDLENBUEQsTUFPTyxJQUFLOVksUUFBUSxDQUFDNk8sZ0JBQWQsRUFBaUM7UUFFdkM7UUFDQTdPLFFBQVEsQ0FBQzZPLGdCQUFULENBQTJCLGtCQUEzQixFQUErQ29QLFNBQS9DLEVBSHVDLENBS3ZDOztRQUNBOWQsTUFBTSxDQUFDME8sZ0JBQVAsQ0FBeUIsTUFBekIsRUFBaUNvUCxTQUFqQyxFQU51QyxDQVF4QztNQUNDLENBVE0sTUFTQTtRQUVOO1FBQ0FqZSxRQUFRLENBQUM4TyxXQUFULENBQXNCLG9CQUF0QixFQUE0Q21QLFNBQTVDLEVBSE0sQ0FLTjs7UUFDQTlkLE1BQU0sQ0FBQzJPLFdBQVAsQ0FBb0IsUUFBcEIsRUFBOEJtUCxTQUE5QixFQU5NLENBUU47UUFDQTs7UUFDQSxJQUFJclAsR0FBRyxHQUFHLEtBQVY7O1FBRUEsSUFBSTtVQUNIQSxHQUFHLEdBQUd6TyxNQUFNLENBQUNvZSxZQUFQLElBQXVCLElBQXZCLElBQStCdmUsUUFBUSxDQUFDc08sZUFBOUM7UUFDQSxDQUZELENBRUUsT0FBUS9JLENBQVIsRUFBWSxDQUFFOztRQUVoQixJQUFLcUosR0FBRyxJQUFJQSxHQUFHLENBQUN5UCxRQUFoQixFQUEyQjtVQUMxQixDQUFFLFNBQVNHLGFBQVQsR0FBeUI7WUFDMUIsSUFBSyxDQUFDeGQsTUFBTSxDQUFDeUQsT0FBYixFQUF1QjtjQUV0QixJQUFJO2dCQUVIO2dCQUNBO2dCQUNBbUssR0FBRyxDQUFDeVAsUUFBSixDQUFjLE1BQWQ7Y0FDQSxDQUxELENBS0UsT0FBUTlZLENBQVIsRUFBWTtnQkFDYixPQUFPcEYsTUFBTSxDQUFDbWUsVUFBUCxDQUFtQkUsYUFBbkIsRUFBa0MsRUFBbEMsQ0FBUDtjQUNBLENBVHFCLENBV3RCOzs7Y0FDQVQsTUFBTSxHQVpnQixDQWN0Qjs7Y0FDQS9jLE1BQU0sQ0FBQzhYLEtBQVA7WUFDQTtVQUNELENBbEJEO1FBbUJBO01BQ0Q7SUFDRDs7SUFDRCxPQUFPMEUsU0FBUyxDQUFDMUIsT0FBVixDQUFtQmpYLEdBQW5CLENBQVA7RUFDQSxDQWpFRCxDQS8vRzhFLENBa2tIOUU7OztFQUNBN0QsTUFBTSxDQUFDOFgsS0FBUCxDQUFhZ0QsT0FBYixHQW5rSDhFLENBd2tIOUU7RUFDQTs7RUFDQSxJQUFJalosQ0FBSjs7RUFDQSxLQUFNQSxDQUFOLElBQVc3QixNQUFNLENBQUVGLE9BQUYsQ0FBakIsRUFBK0I7SUFDOUI7RUFDQTs7RUFDREEsT0FBTyxDQUFDMEUsUUFBUixHQUFtQjNDLENBQUMsS0FBSyxHQUF6QixDQTlrSDhFLENBZ2xIOUU7RUFDQTs7RUFDQS9CLE9BQU8sQ0FBQzJkLHNCQUFSLEdBQWlDLEtBQWpDLENBbGxIOEUsQ0FvbEg5RTs7RUFDQXpkLE1BQU0sQ0FBRSxZQUFXO0lBRWxCO0lBQ0EsSUFBSTZQLEdBQUosRUFBU3hELEdBQVQsRUFBY3FSLElBQWQsRUFBb0JDLFNBQXBCO0lBRUFELElBQUksR0FBRzFlLFFBQVEsQ0FBQ2tNLG9CQUFULENBQStCLE1BQS9CLEVBQXlDLENBQXpDLENBQVA7O0lBQ0EsSUFBSyxDQUFDd1MsSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ0UsS0FBcEIsRUFBNEI7TUFFM0I7TUFDQTtJQUNBLENBVmlCLENBWWxCOzs7SUFDQXZSLEdBQUcsR0FBR3JOLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBTjtJQUNBcVIsU0FBUyxHQUFHM2UsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQUFaO0lBQ0FxUixTQUFTLENBQUNDLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLGdFQUExQjtJQUNBSCxJQUFJLENBQUMxUCxXQUFMLENBQWtCMlAsU0FBbEIsRUFBOEIzUCxXQUE5QixDQUEyQzNCLEdBQTNDOztJQUVBLElBQUssT0FBT0EsR0FBRyxDQUFDdVIsS0FBSixDQUFVRSxJQUFqQixLQUEwQixXQUEvQixFQUE2QztNQUU1QztNQUNBO01BQ0E7TUFDQTtNQUNBelIsR0FBRyxDQUFDdVIsS0FBSixDQUFVQyxPQUFWLEdBQW9CLCtEQUFwQjtNQUVBL2QsT0FBTyxDQUFDMmQsc0JBQVIsR0FBaUM1TixHQUFHLEdBQUd4RCxHQUFHLENBQUMwUixXQUFKLEtBQW9CLENBQTNEOztNQUNBLElBQUtsTyxHQUFMLEVBQVc7UUFFVjtRQUNBO1FBQ0E7UUFDQTZOLElBQUksQ0FBQ0UsS0FBTCxDQUFXRSxJQUFYLEdBQWtCLENBQWxCO01BQ0E7SUFDRDs7SUFFREosSUFBSSxDQUFDblIsV0FBTCxDQUFrQm9SLFNBQWxCO0VBQ0EsQ0FyQ0ssQ0FBTjs7RUF3Q0EsQ0FBRSxZQUFXO0lBQ1osSUFBSXRSLEdBQUcsR0FBR3JOLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBVixDQURZLENBR1o7O0lBQ0F4TSxPQUFPLENBQUNrZSxhQUFSLEdBQXdCLElBQXhCOztJQUNBLElBQUk7TUFDSCxPQUFPM1IsR0FBRyxDQUFDaEIsSUFBWDtJQUNBLENBRkQsQ0FFRSxPQUFROUcsQ0FBUixFQUFZO01BQ2J6RSxPQUFPLENBQUNrZSxhQUFSLEdBQXdCLEtBQXhCO0lBQ0EsQ0FUVyxDQVdaOzs7SUFDQTNSLEdBQUcsR0FBRyxJQUFOO0VBQ0EsQ0FiRDs7RUFjQSxJQUFJNFIsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVXJjLElBQVYsRUFBaUI7SUFDakMsSUFBSXNjLE1BQU0sR0FBR2xlLE1BQU0sQ0FBQ2tlLE1BQVAsQ0FBZSxDQUFFdGMsSUFBSSxDQUFDbUQsUUFBTCxHQUFnQixHQUFsQixFQUF3QkMsV0FBeEIsRUFBZixDQUFiO0lBQUEsSUFDQ1YsUUFBUSxHQUFHLENBQUMxQyxJQUFJLENBQUMwQyxRQUFOLElBQWtCLENBRDlCLENBRGlDLENBSWpDOztJQUNBLE9BQU9BLFFBQVEsS0FBSyxDQUFiLElBQWtCQSxRQUFRLEtBQUssQ0FBL0IsR0FDTixLQURNLEdBR047SUFDQSxDQUFDNFosTUFBRCxJQUFXQSxNQUFNLEtBQUssSUFBWCxJQUFtQnRjLElBQUksQ0FBQzBKLFlBQUwsQ0FBbUIsU0FBbkIsTUFBbUM0UyxNQUpsRTtFQUtBLENBVkQ7O0VBZUEsSUFBSUMsTUFBTSxHQUFHLCtCQUFiO0VBQUEsSUFDQ0MsVUFBVSxHQUFHLFVBRGQ7O0VBR0EsU0FBU0MsUUFBVCxDQUFtQnpjLElBQW5CLEVBQXlCeUMsR0FBekIsRUFBOEJLLElBQTlCLEVBQXFDO0lBRXBDO0lBQ0E7SUFDQSxJQUFLQSxJQUFJLEtBQUt0QixTQUFULElBQXNCeEIsSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUE3QyxFQUFpRDtNQUVoRCxJQUFJMUIsSUFBSSxHQUFHLFVBQVV5QixHQUFHLENBQUNiLE9BQUosQ0FBYTRhLFVBQWIsRUFBeUIsS0FBekIsRUFBaUNwWixXQUFqQyxFQUFyQjtNQUVBTixJQUFJLEdBQUc5QyxJQUFJLENBQUMwSixZQUFMLENBQW1CMUksSUFBbkIsQ0FBUDs7TUFFQSxJQUFLLE9BQU84QixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO1FBQy9CLElBQUk7VUFDSEEsSUFBSSxHQUFHQSxJQUFJLEtBQUssTUFBVCxHQUFrQixJQUFsQixHQUNOQSxJQUFJLEtBQUssT0FBVCxHQUFtQixLQUFuQixHQUNBQSxJQUFJLEtBQUssTUFBVCxHQUFrQixJQUFsQixHQUVBO1VBQ0EsQ0FBQ0EsSUFBRCxHQUFRLEVBQVIsS0FBZUEsSUFBZixHQUFzQixDQUFDQSxJQUF2QixHQUNBeVosTUFBTSxDQUFDOVMsSUFBUCxDQUFhM0csSUFBYixJQUFzQjFFLE1BQU0sQ0FBQ3NlLFNBQVAsQ0FBa0I1WixJQUFsQixDQUF0QixHQUNBQSxJQVBEO1FBUUEsQ0FURCxDQVNFLE9BQVFILENBQVIsRUFBWSxDQUFFLENBVmUsQ0FZL0I7OztRQUNBdkUsTUFBTSxDQUFDMEUsSUFBUCxDQUFhOUMsSUFBYixFQUFtQnlDLEdBQW5CLEVBQXdCSyxJQUF4QjtNQUVBLENBZkQsTUFlTztRQUNOQSxJQUFJLEdBQUd0QixTQUFQO01BQ0E7SUFDRDs7SUFFRCxPQUFPc0IsSUFBUDtFQUNBLENBNXJINkUsQ0E4ckg5RTs7O0VBQ0EsU0FBUzZaLGlCQUFULENBQTRCMWEsR0FBNUIsRUFBa0M7SUFDakMsSUFBSWpCLElBQUo7O0lBQ0EsS0FBTUEsSUFBTixJQUFjaUIsR0FBZCxFQUFvQjtNQUVuQjtNQUNBLElBQUtqQixJQUFJLEtBQUssTUFBVCxJQUFtQjVDLE1BQU0sQ0FBQ29FLGFBQVAsQ0FBc0JQLEdBQUcsQ0FBRWpCLElBQUYsQ0FBekIsQ0FBeEIsRUFBOEQ7UUFDN0Q7TUFDQTs7TUFDRCxJQUFLQSxJQUFJLEtBQUssUUFBZCxFQUF5QjtRQUN4QixPQUFPLEtBQVA7TUFDQTtJQUNEOztJQUVELE9BQU8sSUFBUDtFQUNBOztFQUVELFNBQVM0YixZQUFULENBQXVCNWMsSUFBdkIsRUFBNkJnQixJQUE3QixFQUFtQzhCLElBQW5DLEVBQXlDK1o7RUFBSTtFQUE3QyxFQUF1RTtJQUN0RSxJQUFLLENBQUNSLFVBQVUsQ0FBRXJjLElBQUYsQ0FBaEIsRUFBMkI7TUFDMUI7SUFDQTs7SUFFRCxJQUFJTixHQUFKO0lBQUEsSUFBU29kLFNBQVQ7SUFBQSxJQUNDQyxXQUFXLEdBQUczZSxNQUFNLENBQUNxRCxPQUR0QjtJQUFBLElBR0M7SUFDQTtJQUNBdWIsTUFBTSxHQUFHaGQsSUFBSSxDQUFDMEMsUUFMZjtJQUFBLElBT0M7SUFDQTtJQUNBMEgsS0FBSyxHQUFHNFMsTUFBTSxHQUFHNWUsTUFBTSxDQUFDZ00sS0FBVixHQUFrQnBLLElBVGpDO0lBQUEsSUFXQztJQUNBO0lBQ0FxSixFQUFFLEdBQUcyVCxNQUFNLEdBQUdoZCxJQUFJLENBQUUrYyxXQUFGLENBQVAsR0FBeUIvYyxJQUFJLENBQUUrYyxXQUFGLENBQUosSUFBdUJBLFdBYjVELENBTHNFLENBb0J0RTtJQUNBOztJQUNBLElBQUssQ0FBRSxDQUFDMVQsRUFBRCxJQUFPLENBQUNlLEtBQUssQ0FBRWYsRUFBRixDQUFiLElBQXlCLENBQUN3VCxHQUFELElBQVEsQ0FBQ3pTLEtBQUssQ0FBRWYsRUFBRixDQUFMLENBQVl2RyxJQUFoRCxLQUNKQSxJQUFJLEtBQUt0QixTQURMLElBQ2tCLE9BQU9SLElBQVAsS0FBZ0IsUUFEdkMsRUFDa0Q7TUFDakQ7SUFDQTs7SUFFRCxJQUFLLENBQUNxSSxFQUFOLEVBQVc7TUFFVjtNQUNBO01BQ0EsSUFBSzJULE1BQUwsRUFBYztRQUNiM1QsRUFBRSxHQUFHckosSUFBSSxDQUFFK2MsV0FBRixDQUFKLEdBQXNCdGYsVUFBVSxDQUFDZ0osR0FBWCxNQUFvQnJJLE1BQU0sQ0FBQ2lHLElBQVAsRUFBL0M7TUFDQSxDQUZELE1BRU87UUFDTmdGLEVBQUUsR0FBRzBULFdBQUw7TUFDQTtJQUNEOztJQUVELElBQUssQ0FBQzNTLEtBQUssQ0FBRWYsRUFBRixDQUFYLEVBQW9CO01BRW5CO01BQ0E7TUFDQWUsS0FBSyxDQUFFZixFQUFGLENBQUwsR0FBYzJULE1BQU0sR0FBRyxFQUFILEdBQVE7UUFBRUMsTUFBTSxFQUFFN2UsTUFBTSxDQUFDNEQ7TUFBakIsQ0FBNUI7SUFDQSxDQTNDcUUsQ0E2Q3RFO0lBQ0E7OztJQUNBLElBQUssUUFBT2hCLElBQVAsTUFBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFqRCxFQUE4RDtNQUM3RCxJQUFLNmIsR0FBTCxFQUFXO1FBQ1Z6UyxLQUFLLENBQUVmLEVBQUYsQ0FBTCxHQUFjakwsTUFBTSxDQUFDd0MsTUFBUCxDQUFld0osS0FBSyxDQUFFZixFQUFGLENBQXBCLEVBQTRCckksSUFBNUIsQ0FBZDtNQUNBLENBRkQsTUFFTztRQUNOb0osS0FBSyxDQUFFZixFQUFGLENBQUwsQ0FBWXZHLElBQVosR0FBbUIxRSxNQUFNLENBQUN3QyxNQUFQLENBQWV3SixLQUFLLENBQUVmLEVBQUYsQ0FBTCxDQUFZdkcsSUFBM0IsRUFBaUM5QixJQUFqQyxDQUFuQjtNQUNBO0lBQ0Q7O0lBRUQ4YixTQUFTLEdBQUcxUyxLQUFLLENBQUVmLEVBQUYsQ0FBakIsQ0F2RHNFLENBeUR0RTtJQUNBO0lBQ0E7O0lBQ0EsSUFBSyxDQUFDd1QsR0FBTixFQUFZO01BQ1gsSUFBSyxDQUFDQyxTQUFTLENBQUNoYSxJQUFoQixFQUF1QjtRQUN0QmdhLFNBQVMsQ0FBQ2hhLElBQVYsR0FBaUIsRUFBakI7TUFDQTs7TUFFRGdhLFNBQVMsR0FBR0EsU0FBUyxDQUFDaGEsSUFBdEI7SUFDQTs7SUFFRCxJQUFLQSxJQUFJLEtBQUt0QixTQUFkLEVBQTBCO01BQ3pCc2IsU0FBUyxDQUFFMWUsTUFBTSxDQUFDNkUsU0FBUCxDQUFrQmpDLElBQWxCLENBQUYsQ0FBVCxHQUF3QzhCLElBQXhDO0lBQ0EsQ0F0RXFFLENBd0V0RTtJQUNBOzs7SUFDQSxJQUFLLE9BQU85QixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO01BRS9CO01BQ0F0QixHQUFHLEdBQUdvZCxTQUFTLENBQUU5YixJQUFGLENBQWYsQ0FIK0IsQ0FLL0I7O01BQ0EsSUFBS3RCLEdBQUcsSUFBSSxJQUFaLEVBQW1CO1FBRWxCO1FBQ0FBLEdBQUcsR0FBR29kLFNBQVMsQ0FBRTFlLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0JqQyxJQUFsQixDQUFGLENBQWY7TUFDQTtJQUNELENBWEQsTUFXTztNQUNOdEIsR0FBRyxHQUFHb2QsU0FBTjtJQUNBOztJQUVELE9BQU9wZCxHQUFQO0VBQ0E7O0VBRUQsU0FBU3dkLGtCQUFULENBQTZCbGQsSUFBN0IsRUFBbUNnQixJQUFuQyxFQUF5QzZiLEdBQXpDLEVBQStDO0lBQzlDLElBQUssQ0FBQ1IsVUFBVSxDQUFFcmMsSUFBRixDQUFoQixFQUEyQjtNQUMxQjtJQUNBOztJQUVELElBQUk4YyxTQUFKO0lBQUEsSUFBZTdjLENBQWY7SUFBQSxJQUNDK2MsTUFBTSxHQUFHaGQsSUFBSSxDQUFDMEMsUUFEZjtJQUFBLElBR0M7SUFDQTBILEtBQUssR0FBRzRTLE1BQU0sR0FBRzVlLE1BQU0sQ0FBQ2dNLEtBQVYsR0FBa0JwSyxJQUpqQztJQUFBLElBS0NxSixFQUFFLEdBQUcyVCxNQUFNLEdBQUdoZCxJQUFJLENBQUU1QixNQUFNLENBQUNxRCxPQUFULENBQVAsR0FBNEJyRCxNQUFNLENBQUNxRCxPQUwvQyxDQUw4QyxDQVk5QztJQUNBOztJQUNBLElBQUssQ0FBQzJJLEtBQUssQ0FBRWYsRUFBRixDQUFYLEVBQW9CO01BQ25CO0lBQ0E7O0lBRUQsSUFBS3JJLElBQUwsRUFBWTtNQUVYOGIsU0FBUyxHQUFHRCxHQUFHLEdBQUd6UyxLQUFLLENBQUVmLEVBQUYsQ0FBUixHQUFpQmUsS0FBSyxDQUFFZixFQUFGLENBQUwsQ0FBWXZHLElBQTVDOztNQUVBLElBQUtnYSxTQUFMLEVBQWlCO1FBRWhCO1FBQ0EsSUFBSyxDQUFDMWUsTUFBTSxDQUFDbUQsT0FBUCxDQUFnQlAsSUFBaEIsQ0FBTixFQUErQjtVQUU5QjtVQUNBLElBQUtBLElBQUksSUFBSThiLFNBQWIsRUFBeUI7WUFDeEI5YixJQUFJLEdBQUcsQ0FBRUEsSUFBRixDQUFQO1VBQ0EsQ0FGRCxNQUVPO1lBRU47WUFDQUEsSUFBSSxHQUFHNUMsTUFBTSxDQUFDNkUsU0FBUCxDQUFrQmpDLElBQWxCLENBQVA7O1lBQ0EsSUFBS0EsSUFBSSxJQUFJOGIsU0FBYixFQUF5QjtjQUN4QjliLElBQUksR0FBRyxDQUFFQSxJQUFGLENBQVA7WUFDQSxDQUZELE1BRU87Y0FDTkEsSUFBSSxHQUFHQSxJQUFJLENBQUM2RCxLQUFMLENBQVksR0FBWixDQUFQO1lBQ0E7VUFDRDtRQUNELENBZkQsTUFlTztVQUVOO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBN0QsSUFBSSxHQUFHQSxJQUFJLENBQUNyRCxNQUFMLENBQWFTLE1BQU0sQ0FBQzJCLEdBQVAsQ0FBWWlCLElBQVosRUFBa0I1QyxNQUFNLENBQUM2RSxTQUF6QixDQUFiLENBQVA7UUFDQTs7UUFFRGhELENBQUMsR0FBR2UsSUFBSSxDQUFDN0IsTUFBVDs7UUFDQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztVQUNiLE9BQU82YyxTQUFTLENBQUU5YixJQUFJLENBQUVmLENBQUYsQ0FBTixDQUFoQjtRQUNBLENBaENlLENBa0NoQjtRQUNBOzs7UUFDQSxJQUFLNGMsR0FBRyxHQUFHLENBQUNGLGlCQUFpQixDQUFFRyxTQUFGLENBQXJCLEdBQXFDLENBQUMxZSxNQUFNLENBQUNvRSxhQUFQLENBQXNCc2EsU0FBdEIsQ0FBOUMsRUFBa0Y7VUFDakY7UUFDQTtNQUNEO0lBQ0QsQ0E5RDZDLENBZ0U5Qzs7O0lBQ0EsSUFBSyxDQUFDRCxHQUFOLEVBQVk7TUFDWCxPQUFPelMsS0FBSyxDQUFFZixFQUFGLENBQUwsQ0FBWXZHLElBQW5CLENBRFcsQ0FHWDtNQUNBOztNQUNBLElBQUssQ0FBQzZaLGlCQUFpQixDQUFFdlMsS0FBSyxDQUFFZixFQUFGLENBQVAsQ0FBdkIsRUFBeUM7UUFDeEM7TUFDQTtJQUNELENBekU2QyxDQTJFOUM7OztJQUNBLElBQUsyVCxNQUFMLEVBQWM7TUFDYjVlLE1BQU0sQ0FBQytlLFNBQVAsQ0FBa0IsQ0FBRW5kLElBQUYsQ0FBbEIsRUFBNEIsSUFBNUIsRUFEYSxDQUdkOztNQUNBO0lBQ0MsQ0FMRCxNQUtPLElBQUs5QixPQUFPLENBQUNrZSxhQUFSLElBQXlCaFMsS0FBSyxJQUFJQSxLQUFLLENBQUM3TSxNQUE3QyxFQUFzRDtNQUM1RDtNQUNBLE9BQU82TSxLQUFLLENBQUVmLEVBQUYsQ0FBWixDQUY0RCxDQUk3RDtJQUNDLENBTE0sTUFLQTtNQUNOZSxLQUFLLENBQUVmLEVBQUYsQ0FBTCxHQUFjN0gsU0FBZDtJQUNBO0VBQ0Q7O0VBRURwRCxNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFDZHdKLEtBQUssRUFBRSxFQURPO0lBR2Q7SUFDQTtJQUNBa1MsTUFBTSxFQUFFO01BQ1AsV0FBVyxJQURKO01BRVAsVUFBVSxJQUZIO01BSVA7TUFDQSxXQUFXO0lBTEosQ0FMTTtJQWFkYyxPQUFPLEVBQUUsaUJBQVVwZCxJQUFWLEVBQWlCO01BQ3pCQSxJQUFJLEdBQUdBLElBQUksQ0FBQzBDLFFBQUwsR0FBZ0J0RSxNQUFNLENBQUNnTSxLQUFQLENBQWNwSyxJQUFJLENBQUU1QixNQUFNLENBQUNxRCxPQUFULENBQWxCLENBQWhCLEdBQXlEekIsSUFBSSxDQUFFNUIsTUFBTSxDQUFDcUQsT0FBVCxDQUFwRTtNQUNBLE9BQU8sQ0FBQyxDQUFDekIsSUFBRixJQUFVLENBQUMyYyxpQkFBaUIsQ0FBRTNjLElBQUYsQ0FBbkM7SUFDQSxDQWhCYTtJQWtCZDhDLElBQUksRUFBRSxjQUFVOUMsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCOEIsS0FBdEIsRUFBNkI7TUFDbEMsT0FBTzhaLFlBQVksQ0FBRTVjLElBQUYsRUFBUWdCLElBQVIsRUFBYzhCLEtBQWQsQ0FBbkI7SUFDQSxDQXBCYTtJQXNCZHVhLFVBQVUsRUFBRSxvQkFBVXJkLElBQVYsRUFBZ0JnQixJQUFoQixFQUF1QjtNQUNsQyxPQUFPa2Msa0JBQWtCLENBQUVsZCxJQUFGLEVBQVFnQixJQUFSLENBQXpCO0lBQ0EsQ0F4QmE7SUEwQmQ7SUFDQXNjLEtBQUssRUFBRSxlQUFVdGQsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCOEIsSUFBdEIsRUFBNkI7TUFDbkMsT0FBTzhaLFlBQVksQ0FBRTVjLElBQUYsRUFBUWdCLElBQVIsRUFBYzhCLElBQWQsRUFBb0IsSUFBcEIsQ0FBbkI7SUFDQSxDQTdCYTtJQStCZHlhLFdBQVcsRUFBRSxxQkFBVXZkLElBQVYsRUFBZ0JnQixJQUFoQixFQUF1QjtNQUNuQyxPQUFPa2Msa0JBQWtCLENBQUVsZCxJQUFGLEVBQVFnQixJQUFSLEVBQWMsSUFBZCxDQUF6QjtJQUNBO0VBakNhLENBQWY7RUFvQ0E1QyxNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFDakJrQyxJQUFJLEVBQUUsY0FBVUwsR0FBVixFQUFlMkIsS0FBZixFQUF1QjtNQUM1QixJQUFJbkUsQ0FBSjtNQUFBLElBQU9lLElBQVA7TUFBQSxJQUFhOEIsSUFBYjtNQUFBLElBQ0M5QyxJQUFJLEdBQUcsS0FBTSxDQUFOLENBRFI7TUFBQSxJQUVDNkssS0FBSyxHQUFHN0ssSUFBSSxJQUFJQSxJQUFJLENBQUMrRyxVQUZ0QixDQUQ0QixDQUs1QjtNQUNBO01BRUE7O01BQ0EsSUFBS3RFLEdBQUcsS0FBS2pCLFNBQWIsRUFBeUI7UUFDeEIsSUFBSyxLQUFLckMsTUFBVixFQUFtQjtVQUNsQjJELElBQUksR0FBRzFFLE1BQU0sQ0FBQzBFLElBQVAsQ0FBYTlDLElBQWIsQ0FBUDs7VUFFQSxJQUFLQSxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxCLElBQXVCLENBQUN0RSxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9CLGFBQXBCLENBQTdCLEVBQW1FO1lBQ2xFQyxDQUFDLEdBQUc0SyxLQUFLLENBQUMxTCxNQUFWOztZQUNBLE9BQVFjLENBQUMsRUFBVCxFQUFjO2NBRWI7Y0FDQTtjQUNBLElBQUs0SyxLQUFLLENBQUU1SyxDQUFGLENBQVYsRUFBa0I7Z0JBQ2pCZSxJQUFJLEdBQUc2SixLQUFLLENBQUU1SyxDQUFGLENBQUwsQ0FBV2UsSUFBbEI7O2dCQUNBLElBQUtBLElBQUksQ0FBQ25ELE9BQUwsQ0FBYyxPQUFkLE1BQTRCLENBQWpDLEVBQXFDO2tCQUNwQ21ELElBQUksR0FBRzVDLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0JqQyxJQUFJLENBQUN0RCxLQUFMLENBQVksQ0FBWixDQUFsQixDQUFQO2tCQUNBK2UsUUFBUSxDQUFFemMsSUFBRixFQUFRZ0IsSUFBUixFQUFjOEIsSUFBSSxDQUFFOUIsSUFBRixDQUFsQixDQUFSO2dCQUNBO2NBQ0Q7WUFDRDs7WUFDRDVDLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsRUFBb0IsYUFBcEIsRUFBbUMsSUFBbkM7VUFDQTtRQUNEOztRQUVELE9BQU84QyxJQUFQO01BQ0EsQ0FoQzJCLENBa0M1Qjs7O01BQ0EsSUFBSyxRQUFPTCxHQUFQLE1BQWUsUUFBcEIsRUFBK0I7UUFDOUIsT0FBTyxLQUFLNUMsSUFBTCxDQUFXLFlBQVc7VUFDNUJ6QixNQUFNLENBQUMwRSxJQUFQLENBQWEsSUFBYixFQUFtQkwsR0FBbkI7UUFDQSxDQUZNLENBQVA7TUFHQTs7TUFFRCxPQUFPdEMsU0FBUyxDQUFDaEIsTUFBVixHQUFtQixDQUFuQixHQUVOO01BQ0EsS0FBS1UsSUFBTCxDQUFXLFlBQVc7UUFDckJ6QixNQUFNLENBQUMwRSxJQUFQLENBQWEsSUFBYixFQUFtQkwsR0FBbkIsRUFBd0IyQixLQUF4QjtNQUNBLENBRkQsQ0FITSxHQU9OO01BQ0E7TUFDQXBFLElBQUksR0FBR3ljLFFBQVEsQ0FBRXpjLElBQUYsRUFBUXlDLEdBQVIsRUFBYXJFLE1BQU0sQ0FBQzBFLElBQVAsQ0FBYTlDLElBQWIsRUFBbUJ5QyxHQUFuQixDQUFiLENBQVgsR0FBcURqQixTQVQxRDtJQVVBLENBcERnQjtJQXNEakI2YixVQUFVLEVBQUUsb0JBQVU1YSxHQUFWLEVBQWdCO01BQzNCLE9BQU8sS0FBSzVDLElBQUwsQ0FBVyxZQUFXO1FBQzVCekIsTUFBTSxDQUFDaWYsVUFBUCxDQUFtQixJQUFuQixFQUF5QjVhLEdBQXpCO01BQ0EsQ0FGTSxDQUFQO0lBR0E7RUExRGdCLENBQWxCO0VBOERBckUsTUFBTSxDQUFDd0MsTUFBUCxDQUFlO0lBQ2R3WCxLQUFLLEVBQUUsZUFBVXBZLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQlksSUFBdEIsRUFBNkI7TUFDbkMsSUFBSXNWLEtBQUo7O01BRUEsSUFBS3BZLElBQUwsRUFBWTtRQUNYa0MsSUFBSSxHQUFHLENBQUVBLElBQUksSUFBSSxJQUFWLElBQW1CLE9BQTFCO1FBQ0FrVyxLQUFLLEdBQUdoYSxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9Ca0MsSUFBcEIsQ0FBUixDQUZXLENBSVg7O1FBQ0EsSUFBS1ksSUFBTCxFQUFZO1VBQ1gsSUFBSyxDQUFDc1YsS0FBRCxJQUFVaGEsTUFBTSxDQUFDbUQsT0FBUCxDQUFnQnVCLElBQWhCLENBQWYsRUFBd0M7WUFDdkNzVixLQUFLLEdBQUdoYSxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9Ca0MsSUFBcEIsRUFBMEI5RCxNQUFNLENBQUNtRixTQUFQLENBQWtCVCxJQUFsQixDQUExQixDQUFSO1VBQ0EsQ0FGRCxNQUVPO1lBQ05zVixLQUFLLENBQUN4YSxJQUFOLENBQVlrRixJQUFaO1VBQ0E7UUFDRDs7UUFDRCxPQUFPc1YsS0FBSyxJQUFJLEVBQWhCO01BQ0E7SUFDRCxDQWxCYTtJQW9CZG9GLE9BQU8sRUFBRSxpQkFBVXhkLElBQVYsRUFBZ0JrQyxJQUFoQixFQUF1QjtNQUMvQkEsSUFBSSxHQUFHQSxJQUFJLElBQUksSUFBZjs7TUFFQSxJQUFJa1csS0FBSyxHQUFHaGEsTUFBTSxDQUFDZ2EsS0FBUCxDQUFjcFksSUFBZCxFQUFvQmtDLElBQXBCLENBQVo7TUFBQSxJQUNDdWIsV0FBVyxHQUFHckYsS0FBSyxDQUFDalosTUFEckI7TUFBQSxJQUVDWixFQUFFLEdBQUc2WixLQUFLLENBQUM5TixLQUFOLEVBRk47TUFBQSxJQUdDb1QsS0FBSyxHQUFHdGYsTUFBTSxDQUFDdWYsV0FBUCxDQUFvQjNkLElBQXBCLEVBQTBCa0MsSUFBMUIsQ0FIVDtNQUFBLElBSUNxVSxJQUFJLEdBQUcsU0FBUEEsSUFBTyxHQUFXO1FBQ2pCblksTUFBTSxDQUFDb2YsT0FBUCxDQUFnQnhkLElBQWhCLEVBQXNCa0MsSUFBdEI7TUFDQSxDQU5GLENBSCtCLENBVy9COzs7TUFDQSxJQUFLM0QsRUFBRSxLQUFLLFlBQVosRUFBMkI7UUFDMUJBLEVBQUUsR0FBRzZaLEtBQUssQ0FBQzlOLEtBQU4sRUFBTDtRQUNBbVQsV0FBVztNQUNYOztNQUVELElBQUtsZixFQUFMLEVBQVU7UUFFVDtRQUNBO1FBQ0EsSUFBSzJELElBQUksS0FBSyxJQUFkLEVBQXFCO1VBQ3BCa1csS0FBSyxDQUFDdkssT0FBTixDQUFlLFlBQWY7UUFDQSxDQU5RLENBUVQ7OztRQUNBLE9BQU82UCxLQUFLLENBQUNFLElBQWI7UUFDQXJmLEVBQUUsQ0FBQ2MsSUFBSCxDQUFTVyxJQUFULEVBQWV1VyxJQUFmLEVBQXFCbUgsS0FBckI7TUFDQTs7TUFFRCxJQUFLLENBQUNELFdBQUQsSUFBZ0JDLEtBQXJCLEVBQTZCO1FBQzVCQSxLQUFLLENBQUNoRixLQUFOLENBQVlKLElBQVo7TUFDQTtJQUNELENBckRhO0lBdURkO0lBQ0E7SUFDQXFGLFdBQVcsRUFBRSxxQkFBVTNkLElBQVYsRUFBZ0JrQyxJQUFoQixFQUF1QjtNQUNuQyxJQUFJTyxHQUFHLEdBQUdQLElBQUksR0FBRyxZQUFqQjtNQUNBLE9BQU85RCxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9CeUMsR0FBcEIsS0FBNkJyRSxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9CeUMsR0FBcEIsRUFBeUI7UUFDNURpVyxLQUFLLEVBQUV0YSxNQUFNLENBQUMyWixTQUFQLENBQWtCLGFBQWxCLEVBQWtDZixHQUFsQyxDQUF1QyxZQUFXO1VBQ3hENVksTUFBTSxDQUFDbWYsV0FBUCxDQUFvQnZkLElBQXBCLEVBQTBCa0MsSUFBSSxHQUFHLE9BQWpDOztVQUNBOUQsTUFBTSxDQUFDbWYsV0FBUCxDQUFvQnZkLElBQXBCLEVBQTBCeUMsR0FBMUI7UUFDQSxDQUhNO01BRHFELENBQXpCLENBQXBDO0lBTUE7RUFqRWEsQ0FBZjtFQW9FQXJFLE1BQU0sQ0FBQ0csRUFBUCxDQUFVcUMsTUFBVixDQUFrQjtJQUNqQndYLEtBQUssRUFBRSxlQUFVbFcsSUFBVixFQUFnQlksSUFBaEIsRUFBdUI7TUFDN0IsSUFBSSthLE1BQU0sR0FBRyxDQUFiOztNQUVBLElBQUssT0FBTzNiLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7UUFDL0JZLElBQUksR0FBR1osSUFBUDtRQUNBQSxJQUFJLEdBQUcsSUFBUDtRQUNBMmIsTUFBTTtNQUNOOztNQUVELElBQUsxZCxTQUFTLENBQUNoQixNQUFWLEdBQW1CMGUsTUFBeEIsRUFBaUM7UUFDaEMsT0FBT3pmLE1BQU0sQ0FBQ2dhLEtBQVAsQ0FBYyxLQUFNLENBQU4sQ0FBZCxFQUF5QmxXLElBQXpCLENBQVA7TUFDQTs7TUFFRCxPQUFPWSxJQUFJLEtBQUt0QixTQUFULEdBQ04sSUFETSxHQUVOLEtBQUszQixJQUFMLENBQVcsWUFBVztRQUNyQixJQUFJdVksS0FBSyxHQUFHaGEsTUFBTSxDQUFDZ2EsS0FBUCxDQUFjLElBQWQsRUFBb0JsVyxJQUFwQixFQUEwQlksSUFBMUIsQ0FBWixDQURxQixDQUdyQjs7UUFDQTFFLE1BQU0sQ0FBQ3VmLFdBQVAsQ0FBb0IsSUFBcEIsRUFBMEJ6YixJQUExQjs7UUFFQSxJQUFLQSxJQUFJLEtBQUssSUFBVCxJQUFpQmtXLEtBQUssQ0FBRSxDQUFGLENBQUwsS0FBZSxZQUFyQyxFQUFvRDtVQUNuRGhhLE1BQU0sQ0FBQ29mLE9BQVAsQ0FBZ0IsSUFBaEIsRUFBc0J0YixJQUF0QjtRQUNBO01BQ0QsQ0FURCxDQUZEO0lBWUEsQ0ExQmdCO0lBMkJqQnNiLE9BQU8sRUFBRSxpQkFBVXRiLElBQVYsRUFBaUI7TUFDekIsT0FBTyxLQUFLckMsSUFBTCxDQUFXLFlBQVc7UUFDNUJ6QixNQUFNLENBQUNvZixPQUFQLENBQWdCLElBQWhCLEVBQXNCdGIsSUFBdEI7TUFDQSxDQUZNLENBQVA7SUFHQSxDQS9CZ0I7SUFnQ2pCNGIsVUFBVSxFQUFFLG9CQUFVNWIsSUFBVixFQUFpQjtNQUM1QixPQUFPLEtBQUtrVyxLQUFMLENBQVlsVyxJQUFJLElBQUksSUFBcEIsRUFBMEIsRUFBMUIsQ0FBUDtJQUNBLENBbENnQjtJQW9DakI7SUFDQTtJQUNBZ1gsT0FBTyxFQUFFLGlCQUFVaFgsSUFBVixFQUFnQkQsR0FBaEIsRUFBc0I7TUFDOUIsSUFBSXVDLEdBQUo7TUFBQSxJQUNDdVosS0FBSyxHQUFHLENBRFQ7TUFBQSxJQUVDQyxLQUFLLEdBQUc1ZixNQUFNLENBQUMwYSxRQUFQLEVBRlQ7TUFBQSxJQUdDL0ssUUFBUSxHQUFHLElBSFo7TUFBQSxJQUlDOU4sQ0FBQyxHQUFHLEtBQUtkLE1BSlY7TUFBQSxJQUtDMGEsT0FBTyxHQUFHLFNBQVZBLE9BQVUsR0FBVztRQUNwQixJQUFLLENBQUcsR0FBRWtFLEtBQVYsRUFBb0I7VUFDbkJDLEtBQUssQ0FBQ3ZELFdBQU4sQ0FBbUIxTSxRQUFuQixFQUE2QixDQUFFQSxRQUFGLENBQTdCO1FBQ0E7TUFDRCxDQVRGOztNQVdBLElBQUssT0FBTzdMLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7UUFDL0JELEdBQUcsR0FBR0MsSUFBTjtRQUNBQSxJQUFJLEdBQUdWLFNBQVA7TUFDQTs7TUFDRFUsSUFBSSxHQUFHQSxJQUFJLElBQUksSUFBZjs7TUFFQSxPQUFRakMsQ0FBQyxFQUFULEVBQWM7UUFDYnVFLEdBQUcsR0FBR3BHLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3ZQLFFBQVEsQ0FBRTlOLENBQUYsQ0FBdEIsRUFBNkJpQyxJQUFJLEdBQUcsWUFBcEMsQ0FBTjs7UUFDQSxJQUFLc0MsR0FBRyxJQUFJQSxHQUFHLENBQUNrVSxLQUFoQixFQUF3QjtVQUN2QnFGLEtBQUs7VUFDTHZaLEdBQUcsQ0FBQ2tVLEtBQUosQ0FBVTFCLEdBQVYsQ0FBZTZDLE9BQWY7UUFDQTtNQUNEOztNQUNEQSxPQUFPO01BQ1AsT0FBT21FLEtBQUssQ0FBQzlFLE9BQU4sQ0FBZWpYLEdBQWYsQ0FBUDtJQUNBO0VBakVnQixDQUFsQjs7RUFxRUEsQ0FBRSxZQUFXO0lBQ1osSUFBSWdjLG1CQUFKOztJQUVBL2YsT0FBTyxDQUFDZ2dCLGdCQUFSLEdBQTJCLFlBQVc7TUFDckMsSUFBS0QsbUJBQW1CLElBQUksSUFBNUIsRUFBbUM7UUFDbEMsT0FBT0EsbUJBQVA7TUFDQSxDQUhvQyxDQUtyQzs7O01BQ0FBLG1CQUFtQixHQUFHLEtBQXRCLENBTnFDLENBUXJDOztNQUNBLElBQUl4VCxHQUFKLEVBQVNxUixJQUFULEVBQWVDLFNBQWY7TUFFQUQsSUFBSSxHQUFHMWUsUUFBUSxDQUFDa00sb0JBQVQsQ0FBK0IsTUFBL0IsRUFBeUMsQ0FBekMsQ0FBUDs7TUFDQSxJQUFLLENBQUN3UyxJQUFELElBQVMsQ0FBQ0EsSUFBSSxDQUFDRSxLQUFwQixFQUE0QjtRQUUzQjtRQUNBO01BQ0EsQ0FoQm9DLENBa0JyQzs7O01BQ0F2UixHQUFHLEdBQUdyTixRQUFRLENBQUNzTixhQUFULENBQXdCLEtBQXhCLENBQU47TUFDQXFSLFNBQVMsR0FBRzNlLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBWjtNQUNBcVIsU0FBUyxDQUFDQyxLQUFWLENBQWdCQyxPQUFoQixHQUEwQixnRUFBMUI7TUFDQUgsSUFBSSxDQUFDMVAsV0FBTCxDQUFrQjJQLFNBQWxCLEVBQThCM1AsV0FBOUIsQ0FBMkMzQixHQUEzQyxFQXRCcUMsQ0F3QnJDO01BQ0E7O01BQ0EsSUFBSyxPQUFPQSxHQUFHLENBQUN1UixLQUFKLENBQVVFLElBQWpCLEtBQTBCLFdBQS9CLEVBQTZDO1FBRTVDO1FBQ0F6UixHQUFHLENBQUN1UixLQUFKLENBQVVDLE9BQVYsR0FFQztRQUNBO1FBQ0EsZ0VBQ0EseURBREEsR0FFQSw4QkFORDtRQU9BeFIsR0FBRyxDQUFDMkIsV0FBSixDQUFpQmhQLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBakIsRUFBbURzUixLQUFuRCxDQUF5RG1DLEtBQXpELEdBQWlFLEtBQWpFO1FBQ0FGLG1CQUFtQixHQUFHeFQsR0FBRyxDQUFDMFIsV0FBSixLQUFvQixDQUExQztNQUNBOztNQUVETCxJQUFJLENBQUNuUixXQUFMLENBQWtCb1IsU0FBbEI7TUFFQSxPQUFPa0MsbUJBQVA7SUFDQSxDQTNDRDtFQTZDQSxDQWhERDs7RUFpREEsSUFBSUcsSUFBSSxHQUFLLHFDQUFGLENBQTBDQyxNQUFyRDtFQUVBLElBQUlDLE9BQU8sR0FBRyxJQUFJcFgsTUFBSixDQUFZLG1CQUFtQmtYLElBQW5CLEdBQTBCLGFBQXRDLEVBQXFELEdBQXJELENBQWQ7RUFHQSxJQUFJRyxTQUFTLEdBQUcsQ0FBRSxLQUFGLEVBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixNQUE1QixDQUFoQjs7RUFFQSxJQUFJQyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVeGUsSUFBVixFQUFnQnllLEVBQWhCLEVBQXFCO0lBRWxDO0lBQ0E7SUFDQXplLElBQUksR0FBR3llLEVBQUUsSUFBSXplLElBQWI7SUFDQSxPQUFPNUIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsU0FBbEIsTUFBa0MsTUFBbEMsSUFDTixDQUFDNUIsTUFBTSxDQUFDeUgsUUFBUCxDQUFpQjdGLElBQUksQ0FBQ2tKLGFBQXRCLEVBQXFDbEosSUFBckMsQ0FERjtFQUVBLENBUEY7O0VBV0EsU0FBUzJlLFNBQVQsQ0FBb0IzZSxJQUFwQixFQUEwQjRlLElBQTFCLEVBQWdDQyxVQUFoQyxFQUE0Q0MsS0FBNUMsRUFBb0Q7SUFDbkQsSUFBSUMsUUFBSjtJQUFBLElBQ0NDLEtBQUssR0FBRyxDQURUO0lBQUEsSUFFQ0MsYUFBYSxHQUFHLEVBRmpCO0lBQUEsSUFHQ0MsWUFBWSxHQUFHSixLQUFLLEdBQ25CLFlBQVc7TUFBRSxPQUFPQSxLQUFLLENBQUM3VCxHQUFOLEVBQVA7SUFBcUIsQ0FEZixHQUVuQixZQUFXO01BQUUsT0FBTzdNLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCNGUsSUFBbEIsRUFBd0IsRUFBeEIsQ0FBUDtJQUFzQyxDQUxyRDtJQUFBLElBTUNPLE9BQU8sR0FBR0QsWUFBWSxFQU52QjtJQUFBLElBT0NFLElBQUksR0FBR1AsVUFBVSxJQUFJQSxVQUFVLENBQUUsQ0FBRixDQUF4QixLQUFtQ3pnQixNQUFNLENBQUNpaEIsU0FBUCxDQUFrQlQsSUFBbEIsSUFBMkIsRUFBM0IsR0FBZ0MsSUFBbkUsQ0FQUjtJQUFBLElBU0M7SUFDQVUsYUFBYSxHQUFHLENBQUVsaEIsTUFBTSxDQUFDaWhCLFNBQVAsQ0FBa0JULElBQWxCLEtBQTRCUSxJQUFJLEtBQUssSUFBVCxJQUFpQixDQUFDRCxPQUFoRCxLQUNmYixPQUFPLENBQUNuVixJQUFSLENBQWMvSyxNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQjRlLElBQWxCLENBQWQsQ0FYRjs7SUFhQSxJQUFLVSxhQUFhLElBQUlBLGFBQWEsQ0FBRSxDQUFGLENBQWIsS0FBdUJGLElBQTdDLEVBQW9EO01BRW5EO01BQ0FBLElBQUksR0FBR0EsSUFBSSxJQUFJRSxhQUFhLENBQUUsQ0FBRixDQUE1QixDQUhtRCxDQUtuRDs7TUFDQVQsVUFBVSxHQUFHQSxVQUFVLElBQUksRUFBM0IsQ0FObUQsQ0FRbkQ7O01BQ0FTLGFBQWEsR0FBRyxDQUFDSCxPQUFELElBQVksQ0FBNUI7O01BRUEsR0FBRztRQUVGO1FBQ0E7UUFDQUgsS0FBSyxHQUFHQSxLQUFLLElBQUksSUFBakIsQ0FKRSxDQU1GOztRQUNBTSxhQUFhLEdBQUdBLGFBQWEsR0FBR04sS0FBaEM7UUFDQTVnQixNQUFNLENBQUM0ZCxLQUFQLENBQWNoYyxJQUFkLEVBQW9CNGUsSUFBcEIsRUFBMEJVLGFBQWEsR0FBR0YsSUFBMUMsRUFSRSxDQVVIO1FBQ0E7TUFDQyxDQVpELFFBYUNKLEtBQUssTUFBT0EsS0FBSyxHQUFHRSxZQUFZLEtBQUtDLE9BQWhDLENBQUwsSUFBa0RILEtBQUssS0FBSyxDQUE1RCxJQUFpRSxFQUFFQyxhQWJwRTtJQWVBOztJQUVELElBQUtKLFVBQUwsRUFBa0I7TUFDakJTLGFBQWEsR0FBRyxDQUFDQSxhQUFELElBQWtCLENBQUNILE9BQW5CLElBQThCLENBQTlDLENBRGlCLENBR2pCOztNQUNBSixRQUFRLEdBQUdGLFVBQVUsQ0FBRSxDQUFGLENBQVYsR0FDVlMsYUFBYSxHQUFHLENBQUVULFVBQVUsQ0FBRSxDQUFGLENBQVYsR0FBa0IsQ0FBcEIsSUFBMEJBLFVBQVUsQ0FBRSxDQUFGLENBRDFDLEdBRVYsQ0FBQ0EsVUFBVSxDQUFFLENBQUYsQ0FGWjs7TUFHQSxJQUFLQyxLQUFMLEVBQWE7UUFDWkEsS0FBSyxDQUFDTSxJQUFOLEdBQWFBLElBQWI7UUFDQU4sS0FBSyxDQUFDaFAsS0FBTixHQUFjd1AsYUFBZDtRQUNBUixLQUFLLENBQUNyZSxHQUFOLEdBQVlzZSxRQUFaO01BQ0E7SUFDRDs7SUFDRCxPQUFPQSxRQUFQO0VBQ0EsQ0E1dUk2RSxDQSt1STlFO0VBQ0E7OztFQUNBLElBQUlRLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVU5ZixLQUFWLEVBQWlCbEIsRUFBakIsRUFBcUJrRSxHQUFyQixFQUEwQjJCLEtBQTFCLEVBQWlDb2IsU0FBakMsRUFBNENDLFFBQTVDLEVBQXNEQyxHQUF0RCxFQUE0RDtJQUN4RSxJQUFJemYsQ0FBQyxHQUFHLENBQVI7SUFBQSxJQUNDZCxNQUFNLEdBQUdNLEtBQUssQ0FBQ04sTUFEaEI7SUFBQSxJQUVDd2dCLElBQUksR0FBR2xkLEdBQUcsSUFBSSxJQUZmLENBRHdFLENBS3hFOztJQUNBLElBQUtyRSxNQUFNLENBQUM4RCxJQUFQLENBQWFPLEdBQWIsTUFBdUIsUUFBNUIsRUFBdUM7TUFDdEMrYyxTQUFTLEdBQUcsSUFBWjs7TUFDQSxLQUFNdmYsQ0FBTixJQUFXd0MsR0FBWCxFQUFpQjtRQUNoQjhjLE1BQU0sQ0FBRTlmLEtBQUYsRUFBU2xCLEVBQVQsRUFBYTBCLENBQWIsRUFBZ0J3QyxHQUFHLENBQUV4QyxDQUFGLENBQW5CLEVBQTBCLElBQTFCLEVBQWdDd2YsUUFBaEMsRUFBMENDLEdBQTFDLENBQU47TUFDQSxDQUpxQyxDQU12Qzs7SUFDQyxDQVBELE1BT08sSUFBS3RiLEtBQUssS0FBSzVDLFNBQWYsRUFBMkI7TUFDakNnZSxTQUFTLEdBQUcsSUFBWjs7TUFFQSxJQUFLLENBQUNwaEIsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQitDLEtBQW5CLENBQU4sRUFBbUM7UUFDbENzYixHQUFHLEdBQUcsSUFBTjtNQUNBOztNQUVELElBQUtDLElBQUwsRUFBWTtRQUVYO1FBQ0EsSUFBS0QsR0FBTCxFQUFXO1VBQ1ZuaEIsRUFBRSxDQUFDYyxJQUFILENBQVNJLEtBQVQsRUFBZ0IyRSxLQUFoQjtVQUNBN0YsRUFBRSxHQUFHLElBQUwsQ0FGVSxDQUlYO1FBQ0MsQ0FMRCxNQUtPO1VBQ05vaEIsSUFBSSxHQUFHcGhCLEVBQVA7O1VBQ0FBLEVBQUUsR0FBRyxZQUFVeUIsSUFBVixFQUFnQnlDLEdBQWhCLEVBQXFCMkIsS0FBckIsRUFBNkI7WUFDakMsT0FBT3ViLElBQUksQ0FBQ3RnQixJQUFMLENBQVdqQixNQUFNLENBQUU0QixJQUFGLENBQWpCLEVBQTJCb0UsS0FBM0IsQ0FBUDtVQUNBLENBRkQ7UUFHQTtNQUNEOztNQUVELElBQUs3RixFQUFMLEVBQVU7UUFDVCxPQUFRMEIsQ0FBQyxHQUFHZCxNQUFaLEVBQW9CYyxDQUFDLEVBQXJCLEVBQTBCO1VBQ3pCMUIsRUFBRSxDQUNEa0IsS0FBSyxDQUFFUSxDQUFGLENBREosRUFFRHdDLEdBRkMsRUFHRGlkLEdBQUcsR0FBR3RiLEtBQUgsR0FBV0EsS0FBSyxDQUFDL0UsSUFBTixDQUFZSSxLQUFLLENBQUVRLENBQUYsQ0FBakIsRUFBd0JBLENBQXhCLEVBQTJCMUIsRUFBRSxDQUFFa0IsS0FBSyxDQUFFUSxDQUFGLENBQVAsRUFBY3dDLEdBQWQsQ0FBN0IsQ0FIYixDQUFGO1FBS0E7TUFDRDtJQUNEOztJQUVELE9BQU8rYyxTQUFTLEdBQ2YvZixLQURlLEdBR2Y7SUFDQWtnQixJQUFJLEdBQ0hwaEIsRUFBRSxDQUFDYyxJQUFILENBQVNJLEtBQVQsQ0FERyxHQUVITixNQUFNLEdBQUdaLEVBQUUsQ0FBRWtCLEtBQUssQ0FBRSxDQUFGLENBQVAsRUFBY2dELEdBQWQsQ0FBTCxHQUEyQmdkLFFBTm5DO0VBT0EsQ0F0REQ7O0VBdURBLElBQUlHLGNBQWMsR0FBSyx1QkFBdkI7RUFFQSxJQUFJQyxRQUFRLEdBQUssWUFBakI7RUFFQSxJQUFJQyxXQUFXLEdBQUssMkJBQXBCO0VBRUEsSUFBSUMsa0JBQWtCLEdBQUssTUFBM0I7RUFFQSxJQUFJQyxTQUFTLEdBQUcsdURBQ2QsNkRBRGMsR0FFZCw0RUFGRjs7RUFNQSxTQUFTQyxrQkFBVCxDQUE2QjdpQixRQUE3QixFQUF3QztJQUN2QyxJQUFJdUosSUFBSSxHQUFHcVosU0FBUyxDQUFDbmIsS0FBVixDQUFpQixHQUFqQixDQUFYO0lBQUEsSUFDQ3FiLFFBQVEsR0FBRzlpQixRQUFRLENBQUMraUIsc0JBQVQsRUFEWjs7SUFHQSxJQUFLRCxRQUFRLENBQUN4VixhQUFkLEVBQThCO01BQzdCLE9BQVEvRCxJQUFJLENBQUN4SCxNQUFiLEVBQXNCO1FBQ3JCK2dCLFFBQVEsQ0FBQ3hWLGFBQVQsQ0FDQy9ELElBQUksQ0FBQ0YsR0FBTCxFQUREO01BR0E7SUFDRDs7SUFDRCxPQUFPeVosUUFBUDtFQUNBOztFQUdELENBQUUsWUFBVztJQUNaLElBQUl6VixHQUFHLEdBQUdyTixRQUFRLENBQUNzTixhQUFULENBQXdCLEtBQXhCLENBQVY7SUFBQSxJQUNDMFYsUUFBUSxHQUFHaGpCLFFBQVEsQ0FBQytpQixzQkFBVCxFQURaO0lBQUEsSUFFQ3JULEtBQUssR0FBRzFQLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsT0FBeEIsQ0FGVCxDQURZLENBS1o7O0lBQ0FELEdBQUcsQ0FBQ29DLFNBQUosR0FBZ0Isb0VBQWhCLENBTlksQ0FRWjs7SUFDQTNPLE9BQU8sQ0FBQ21pQixpQkFBUixHQUE0QjVWLEdBQUcsQ0FBQytELFVBQUosQ0FBZTlMLFFBQWYsS0FBNEIsQ0FBeEQsQ0FUWSxDQVdaO0lBQ0E7O0lBQ0F4RSxPQUFPLENBQUNvaUIsS0FBUixHQUFnQixDQUFDN1YsR0FBRyxDQUFDbkIsb0JBQUosQ0FBMEIsT0FBMUIsRUFBb0NuSyxNQUFyRCxDQWJZLENBZVo7SUFDQTs7SUFDQWpCLE9BQU8sQ0FBQ3FpQixhQUFSLEdBQXdCLENBQUMsQ0FBQzlWLEdBQUcsQ0FBQ25CLG9CQUFKLENBQTBCLE1BQTFCLEVBQW1DbkssTUFBN0QsQ0FqQlksQ0FtQlo7SUFDQTs7SUFDQWpCLE9BQU8sQ0FBQ3NpQixVQUFSLEdBQ0NwakIsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixFQUFnQytWLFNBQWhDLENBQTJDLElBQTNDLEVBQWtEQyxTQUFsRCxLQUFnRSxlQURqRSxDQXJCWSxDQXdCWjtJQUNBOztJQUNBNVQsS0FBSyxDQUFDNUssSUFBTixHQUFhLFVBQWI7SUFDQTRLLEtBQUssQ0FBQ29FLE9BQU4sR0FBZ0IsSUFBaEI7SUFDQWtQLFFBQVEsQ0FBQ2hVLFdBQVQsQ0FBc0JVLEtBQXRCO0lBQ0E1TyxPQUFPLENBQUN5aUIsYUFBUixHQUF3QjdULEtBQUssQ0FBQ29FLE9BQTlCLENBN0JZLENBK0JaO0lBQ0E7O0lBQ0F6RyxHQUFHLENBQUNvQyxTQUFKLEdBQWdCLHdCQUFoQjtJQUNBM08sT0FBTyxDQUFDMGlCLGNBQVIsR0FBeUIsQ0FBQyxDQUFDblcsR0FBRyxDQUFDZ1csU0FBSixDQUFlLElBQWYsRUFBc0J6USxTQUF0QixDQUFnQzhFLFlBQTNELENBbENZLENBb0NaOztJQUNBc0wsUUFBUSxDQUFDaFUsV0FBVCxDQUFzQjNCLEdBQXRCLEVBckNZLENBdUNaO0lBQ0E7O0lBQ0FxQyxLQUFLLEdBQUcxUCxRQUFRLENBQUNzTixhQUFULENBQXdCLE9BQXhCLENBQVI7SUFDQW9DLEtBQUssQ0FBQ25ELFlBQU4sQ0FBb0IsTUFBcEIsRUFBNEIsT0FBNUI7SUFDQW1ELEtBQUssQ0FBQ25ELFlBQU4sQ0FBb0IsU0FBcEIsRUFBK0IsU0FBL0I7SUFDQW1ELEtBQUssQ0FBQ25ELFlBQU4sQ0FBb0IsTUFBcEIsRUFBNEIsR0FBNUI7SUFFQWMsR0FBRyxDQUFDMkIsV0FBSixDQUFpQlUsS0FBakIsRUE5Q1ksQ0FnRFo7SUFDQTs7SUFDQTVPLE9BQU8sQ0FBQzJpQixVQUFSLEdBQXFCcFcsR0FBRyxDQUFDZ1csU0FBSixDQUFlLElBQWYsRUFBc0JBLFNBQXRCLENBQWlDLElBQWpDLEVBQXdDelEsU0FBeEMsQ0FBa0RrQixPQUF2RSxDQWxEWSxDQW9EWjtJQUNBOztJQUNBaFQsT0FBTyxDQUFDNGlCLFlBQVIsR0FBdUIsQ0FBQyxDQUFDclcsR0FBRyxDQUFDd0IsZ0JBQTdCLENBdERZLENBd0RaO0lBQ0E7SUFDQTs7SUFDQXhCLEdBQUcsQ0FBRXJNLE1BQU0sQ0FBQ3FELE9BQVQsQ0FBSCxHQUF3QixDQUF4QjtJQUNBdkQsT0FBTyxDQUFDNkksVUFBUixHQUFxQixDQUFDMEQsR0FBRyxDQUFDZixZQUFKLENBQWtCdEwsTUFBTSxDQUFDcUQsT0FBekIsQ0FBdEI7RUFDQSxDQTdERCxJQXIwSThFLENBcTRJOUU7OztFQUNBLElBQUlzZixPQUFPLEdBQUc7SUFDYkMsTUFBTSxFQUFFLENBQUUsQ0FBRixFQUFLLDhCQUFMLEVBQXFDLFdBQXJDLENBREs7SUFFYkMsTUFBTSxFQUFFLENBQUUsQ0FBRixFQUFLLFlBQUwsRUFBbUIsYUFBbkIsQ0FGSztJQUdiQyxJQUFJLEVBQUUsQ0FBRSxDQUFGLEVBQUssT0FBTCxFQUFjLFFBQWQsQ0FITztJQUtiO0lBQ0FDLEtBQUssRUFBRSxDQUFFLENBQUYsRUFBSyxVQUFMLEVBQWlCLFdBQWpCLENBTk07SUFPYkMsS0FBSyxFQUFFLENBQUUsQ0FBRixFQUFLLFNBQUwsRUFBZ0IsVUFBaEIsQ0FQTTtJQVFiQyxFQUFFLEVBQUUsQ0FBRSxDQUFGLEVBQUssZ0JBQUwsRUFBdUIsa0JBQXZCLENBUlM7SUFTYkMsR0FBRyxFQUFFLENBQUUsQ0FBRixFQUFLLGtDQUFMLEVBQXlDLHFCQUF6QyxDQVRRO0lBVWJDLEVBQUUsRUFBRSxDQUFFLENBQUYsRUFBSyxvQkFBTCxFQUEyQix1QkFBM0IsQ0FWUztJQVliO0lBQ0E7SUFDQUMsUUFBUSxFQUFFdGpCLE9BQU8sQ0FBQ3FpQixhQUFSLEdBQXdCLENBQUUsQ0FBRixFQUFLLEVBQUwsRUFBUyxFQUFULENBQXhCLEdBQXdDLENBQUUsQ0FBRixFQUFLLFFBQUwsRUFBZSxRQUFmO0VBZHJDLENBQWQsQ0F0NEk4RSxDQXU1STlFOztFQUNBUSxPQUFPLENBQUNVLFFBQVIsR0FBbUJWLE9BQU8sQ0FBQ0MsTUFBM0I7RUFFQUQsT0FBTyxDQUFDVCxLQUFSLEdBQWdCUyxPQUFPLENBQUNXLEtBQVIsR0FBZ0JYLE9BQU8sQ0FBQ1ksUUFBUixHQUFtQlosT0FBTyxDQUFDYSxPQUFSLEdBQWtCYixPQUFPLENBQUNLLEtBQTdFO0VBQ0FMLE9BQU8sQ0FBQ2MsRUFBUixHQUFhZCxPQUFPLENBQUNRLEVBQXJCOztFQUdBLFNBQVNPLE1BQVQsQ0FBaUJ4akIsT0FBakIsRUFBMEJzTyxHQUExQixFQUFnQztJQUMvQixJQUFJbk4sS0FBSjtJQUFBLElBQVdPLElBQVg7SUFBQSxJQUNDQyxDQUFDLEdBQUcsQ0FETDtJQUFBLElBRUM4aEIsS0FBSyxHQUFHLE9BQU96akIsT0FBTyxDQUFDZ0wsb0JBQWYsS0FBd0MsV0FBeEMsR0FDUGhMLE9BQU8sQ0FBQ2dMLG9CQUFSLENBQThCc0QsR0FBRyxJQUFJLEdBQXJDLENBRE8sR0FFUCxPQUFPdE8sT0FBTyxDQUFDMEwsZ0JBQWYsS0FBb0MsV0FBcEMsR0FDQzFMLE9BQU8sQ0FBQzBMLGdCQUFSLENBQTBCNEMsR0FBRyxJQUFJLEdBQWpDLENBREQsR0FFQ3BMLFNBTkg7O0lBUUEsSUFBSyxDQUFDdWdCLEtBQU4sRUFBYztNQUNiLEtBQU1BLEtBQUssR0FBRyxFQUFSLEVBQVl0aUIsS0FBSyxHQUFHbkIsT0FBTyxDQUFDa0ssVUFBUixJQUFzQmxLLE9BQWhELEVBQ0MsQ0FBRTBCLElBQUksR0FBR1AsS0FBSyxDQUFFUSxDQUFGLENBQWQsS0FBeUIsSUFEMUIsRUFFQ0EsQ0FBQyxFQUZGLEVBR0U7UUFDRCxJQUFLLENBQUMyTSxHQUFELElBQVF4TyxNQUFNLENBQUMrRSxRQUFQLENBQWlCbkQsSUFBakIsRUFBdUI0TSxHQUF2QixDQUFiLEVBQTRDO1VBQzNDbVYsS0FBSyxDQUFDbmtCLElBQU4sQ0FBWW9DLElBQVo7UUFDQSxDQUZELE1BRU87VUFDTjVCLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBY29pQixLQUFkLEVBQXFCRCxNQUFNLENBQUU5aEIsSUFBRixFQUFRNE0sR0FBUixDQUEzQjtRQUNBO01BQ0Q7SUFDRDs7SUFFRCxPQUFPQSxHQUFHLEtBQUtwTCxTQUFSLElBQXFCb0wsR0FBRyxJQUFJeE8sTUFBTSxDQUFDK0UsUUFBUCxDQUFpQjdFLE9BQWpCLEVBQTBCc08sR0FBMUIsQ0FBNUIsR0FDTnhPLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBYyxDQUFFckIsT0FBRixDQUFkLEVBQTJCeWpCLEtBQTNCLENBRE0sR0FFTkEsS0FGRDtFQUdBLENBdjdJNkUsQ0EwN0k5RTs7O0VBQ0EsU0FBU0MsYUFBVCxDQUF3QnZpQixLQUF4QixFQUErQndpQixXQUEvQixFQUE2QztJQUM1QyxJQUFJamlCLElBQUo7SUFBQSxJQUNDQyxDQUFDLEdBQUcsQ0FETDs7SUFFQSxPQUFRLENBQUVELElBQUksR0FBR1AsS0FBSyxDQUFFUSxDQUFGLENBQWQsS0FBeUIsSUFBakMsRUFBdUNBLENBQUMsRUFBeEMsRUFBNkM7TUFDNUM3QixNQUFNLENBQUNrZixLQUFQLENBQ0N0ZCxJQURELEVBRUMsWUFGRCxFQUdDLENBQUNpaUIsV0FBRCxJQUFnQjdqQixNQUFNLENBQUNrZixLQUFQLENBQWMyRSxXQUFXLENBQUVoaUIsQ0FBRixDQUF6QixFQUFnQyxZQUFoQyxDQUhqQjtJQUtBO0VBQ0Q7O0VBR0QsSUFBSWlpQixLQUFLLEdBQUcsV0FBWjtFQUFBLElBQ0NDLE1BQU0sR0FBRyxTQURWOztFQUdBLFNBQVNDLGlCQUFULENBQTRCcGlCLElBQTVCLEVBQW1DO0lBQ2xDLElBQUs0ZixjQUFjLENBQUNuVyxJQUFmLENBQXFCekosSUFBSSxDQUFDa0MsSUFBMUIsQ0FBTCxFQUF3QztNQUN2Q2xDLElBQUksQ0FBQ3FpQixjQUFMLEdBQXNCcmlCLElBQUksQ0FBQ2tSLE9BQTNCO0lBQ0E7RUFDRDs7RUFFRCxTQUFTb1IsYUFBVCxDQUF3QjdpQixLQUF4QixFQUErQm5CLE9BQS9CLEVBQXdDaWtCLE9BQXhDLEVBQWlEQyxTQUFqRCxFQUE0REMsT0FBNUQsRUFBc0U7SUFDckUsSUFBSWppQixDQUFKO0lBQUEsSUFBT1IsSUFBUDtJQUFBLElBQWE2RixRQUFiO0lBQUEsSUFDQ3JCLEdBREQ7SUFBQSxJQUNNb0ksR0FETjtJQUFBLElBQ1cwVCxLQURYO0lBQUEsSUFDa0JvQyxJQURsQjtJQUFBLElBRUM5TCxDQUFDLEdBQUduWCxLQUFLLENBQUNOLE1BRlg7SUFBQSxJQUlDO0lBQ0F3akIsSUFBSSxHQUFHMUMsa0JBQWtCLENBQUUzaEIsT0FBRixDQUwxQjtJQUFBLElBT0Nza0IsS0FBSyxHQUFHLEVBUFQ7SUFBQSxJQVFDM2lCLENBQUMsR0FBRyxDQVJMOztJQVVBLE9BQVFBLENBQUMsR0FBRzJXLENBQVosRUFBZTNXLENBQUMsRUFBaEIsRUFBcUI7TUFDcEJELElBQUksR0FBR1AsS0FBSyxDQUFFUSxDQUFGLENBQVo7O01BRUEsSUFBS0QsSUFBSSxJQUFJQSxJQUFJLEtBQUssQ0FBdEIsRUFBMEI7UUFFekI7UUFDQSxJQUFLNUIsTUFBTSxDQUFDOEQsSUFBUCxDQUFhbEMsSUFBYixNQUF3QixRQUE3QixFQUF3QztVQUN2QzVCLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBY2lqQixLQUFkLEVBQXFCNWlCLElBQUksQ0FBQzBDLFFBQUwsR0FBZ0IsQ0FBRTFDLElBQUYsQ0FBaEIsR0FBMkJBLElBQWhELEVBRHVDLENBR3hDO1FBQ0MsQ0FKRCxNQUlPLElBQUssQ0FBQ2tpQixLQUFLLENBQUN6WSxJQUFOLENBQVl6SixJQUFaLENBQU4sRUFBMkI7VUFDakM0aUIsS0FBSyxDQUFDaGxCLElBQU4sQ0FBWVUsT0FBTyxDQUFDdWtCLGNBQVIsQ0FBd0I3aUIsSUFBeEIsQ0FBWixFQURpQyxDQUdsQztRQUNDLENBSk0sTUFJQTtVQUNOd0UsR0FBRyxHQUFHQSxHQUFHLElBQUltZSxJQUFJLENBQUN2VyxXQUFMLENBQWtCOU4sT0FBTyxDQUFDb00sYUFBUixDQUF1QixLQUF2QixDQUFsQixDQUFiLENBRE0sQ0FHTjs7VUFDQWtDLEdBQUcsR0FBRyxDQUFFaVQsUUFBUSxDQUFDMVcsSUFBVCxDQUFlbkosSUFBZixLQUF5QixDQUFFLEVBQUYsRUFBTSxFQUFOLENBQTNCLEVBQXlDLENBQXpDLEVBQTZDb0QsV0FBN0MsRUFBTjtVQUNBc2YsSUFBSSxHQUFHM0IsT0FBTyxDQUFFblUsR0FBRixDQUFQLElBQWtCbVUsT0FBTyxDQUFDUyxRQUFqQztVQUVBaGQsR0FBRyxDQUFDcUksU0FBSixHQUFnQjZWLElBQUksQ0FBRSxDQUFGLENBQUosR0FBWXRrQixNQUFNLENBQUMwa0IsYUFBUCxDQUFzQjlpQixJQUF0QixDQUFaLEdBQTJDMGlCLElBQUksQ0FBRSxDQUFGLENBQS9ELENBUE0sQ0FTTjs7VUFDQWxpQixDQUFDLEdBQUdraUIsSUFBSSxDQUFFLENBQUYsQ0FBUjs7VUFDQSxPQUFRbGlCLENBQUMsRUFBVCxFQUFjO1lBQ2JnRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3dMLFNBQVY7VUFDQSxDQWJLLENBZU47OztVQUNBLElBQUssQ0FBQzlSLE9BQU8sQ0FBQ21pQixpQkFBVCxJQUE4Qk4sa0JBQWtCLENBQUN0VyxJQUFuQixDQUF5QnpKLElBQXpCLENBQW5DLEVBQXFFO1lBQ3BFNGlCLEtBQUssQ0FBQ2hsQixJQUFOLENBQVlVLE9BQU8sQ0FBQ3VrQixjQUFSLENBQXdCOUMsa0JBQWtCLENBQUM1VyxJQUFuQixDQUF5Qm5KLElBQXpCLEVBQWlDLENBQWpDLENBQXhCLENBQVo7VUFDQSxDQWxCSyxDQW9CTjs7O1VBQ0EsSUFBSyxDQUFDOUIsT0FBTyxDQUFDb2lCLEtBQWQsRUFBc0I7WUFFckI7WUFDQXRnQixJQUFJLEdBQUc0TSxHQUFHLEtBQUssT0FBUixJQUFtQixDQUFDdVYsTUFBTSxDQUFDMVksSUFBUCxDQUFhekosSUFBYixDQUFwQixHQUNOd0UsR0FBRyxDQUFDZ0ssVUFERSxHQUdOO1lBQ0FrVSxJQUFJLENBQUUsQ0FBRixDQUFKLEtBQWMsU0FBZCxJQUEyQixDQUFDUCxNQUFNLENBQUMxWSxJQUFQLENBQWF6SixJQUFiLENBQTVCLEdBQ0N3RSxHQURELEdBRUMsQ0FORjtZQVFBaEUsQ0FBQyxHQUFHUixJQUFJLElBQUlBLElBQUksQ0FBQ3dJLFVBQUwsQ0FBZ0JySixNQUE1Qjs7WUFDQSxPQUFRcUIsQ0FBQyxFQUFULEVBQWM7Y0FDYixJQUFLcEMsTUFBTSxDQUFDK0UsUUFBUCxDQUFtQm1kLEtBQUssR0FBR3RnQixJQUFJLENBQUN3SSxVQUFMLENBQWlCaEksQ0FBakIsQ0FBM0IsRUFBbUQsT0FBbkQsS0FDSixDQUFDOGYsS0FBSyxDQUFDOVgsVUFBTixDQUFpQnJKLE1BRG5CLEVBQzRCO2dCQUUzQmEsSUFBSSxDQUFDMkssV0FBTCxDQUFrQjJWLEtBQWxCO2NBQ0E7WUFDRDtVQUNEOztVQUVEbGlCLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBY2lqQixLQUFkLEVBQXFCcGUsR0FBRyxDQUFDZ0UsVUFBekIsRUExQ00sQ0E0Q047O1VBQ0FoRSxHQUFHLENBQUMrSixXQUFKLEdBQWtCLEVBQWxCLENBN0NNLENBK0NOOztVQUNBLE9BQVEvSixHQUFHLENBQUNnSyxVQUFaLEVBQXlCO1lBQ3hCaEssR0FBRyxDQUFDbUcsV0FBSixDQUFpQm5HLEdBQUcsQ0FBQ2dLLFVBQXJCO1VBQ0EsQ0FsREssQ0FvRE47OztVQUNBaEssR0FBRyxHQUFHbWUsSUFBSSxDQUFDM1MsU0FBWDtRQUNBO01BQ0Q7SUFDRCxDQWpGb0UsQ0FtRnJFOzs7SUFDQSxJQUFLeEwsR0FBTCxFQUFXO01BQ1ZtZSxJQUFJLENBQUNoWSxXQUFMLENBQWtCbkcsR0FBbEI7SUFDQSxDQXRGb0UsQ0F3RnJFO0lBQ0E7OztJQUNBLElBQUssQ0FBQ3RHLE9BQU8sQ0FBQ3lpQixhQUFkLEVBQThCO01BQzdCdmlCLE1BQU0sQ0FBQzBGLElBQVAsQ0FBYWdlLE1BQU0sQ0FBRWMsS0FBRixFQUFTLE9BQVQsQ0FBbkIsRUFBdUNSLGlCQUF2QztJQUNBOztJQUVEbmlCLENBQUMsR0FBRyxDQUFKOztJQUNBLE9BQVVELElBQUksR0FBRzRpQixLQUFLLENBQUUzaUIsQ0FBQyxFQUFILENBQXRCLEVBQWtDO01BRWpDO01BQ0EsSUFBS3VpQixTQUFTLElBQUlwa0IsTUFBTSxDQUFDdUYsT0FBUCxDQUFnQjNELElBQWhCLEVBQXNCd2lCLFNBQXRCLElBQW9DLENBQUMsQ0FBdkQsRUFBMkQ7UUFDMUQsSUFBS0MsT0FBTCxFQUFlO1VBQ2RBLE9BQU8sQ0FBQzdrQixJQUFSLENBQWNvQyxJQUFkO1FBQ0E7O1FBRUQ7TUFDQTs7TUFFRDZGLFFBQVEsR0FBR3pILE1BQU0sQ0FBQ3lILFFBQVAsQ0FBaUI3RixJQUFJLENBQUNrSixhQUF0QixFQUFxQ2xKLElBQXJDLENBQVgsQ0FYaUMsQ0FhakM7O01BQ0F3RSxHQUFHLEdBQUdzZCxNQUFNLENBQUVhLElBQUksQ0FBQ3ZXLFdBQUwsQ0FBa0JwTSxJQUFsQixDQUFGLEVBQTRCLFFBQTVCLENBQVosQ0FkaUMsQ0FnQmpDOztNQUNBLElBQUs2RixRQUFMLEVBQWdCO1FBQ2ZtYyxhQUFhLENBQUV4ZCxHQUFGLENBQWI7TUFDQSxDQW5CZ0MsQ0FxQmpDOzs7TUFDQSxJQUFLK2QsT0FBTCxFQUFlO1FBQ2QvaEIsQ0FBQyxHQUFHLENBQUo7O1FBQ0EsT0FBVVIsSUFBSSxHQUFHd0UsR0FBRyxDQUFFaEUsQ0FBQyxFQUFILENBQXBCLEVBQWdDO1VBQy9CLElBQUtzZixXQUFXLENBQUNyVyxJQUFaLENBQWtCekosSUFBSSxDQUFDa0MsSUFBTCxJQUFhLEVBQS9CLENBQUwsRUFBMkM7WUFDMUNxZ0IsT0FBTyxDQUFDM2tCLElBQVIsQ0FBY29DLElBQWQ7VUFDQTtRQUNEO01BQ0Q7SUFDRDs7SUFFRHdFLEdBQUcsR0FBRyxJQUFOO0lBRUEsT0FBT21lLElBQVA7RUFDQTs7RUFHRCxDQUFFLFlBQVc7SUFDWixJQUFJMWlCLENBQUo7SUFBQSxJQUFPOGlCLFNBQVA7SUFBQSxJQUNDdFksR0FBRyxHQUFHck4sUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQURQLENBRFksQ0FJWjs7SUFDQSxLQUFNekssQ0FBTixJQUFXO01BQUV5UixNQUFNLEVBQUUsSUFBVjtNQUFnQnNSLE1BQU0sRUFBRSxJQUF4QjtNQUE4QkMsT0FBTyxFQUFFO0lBQXZDLENBQVgsRUFBMkQ7TUFDMURGLFNBQVMsR0FBRyxPQUFPOWlCLENBQW5COztNQUVBLElBQUssRUFBRy9CLE9BQU8sQ0FBRStCLENBQUYsQ0FBUCxHQUFlOGlCLFNBQVMsSUFBSXhsQixNQUEvQixDQUFMLEVBQStDO1FBRTlDO1FBQ0FrTixHQUFHLENBQUNkLFlBQUosQ0FBa0JvWixTQUFsQixFQUE2QixHQUE3QjtRQUNBN2tCLE9BQU8sQ0FBRStCLENBQUYsQ0FBUCxHQUFld0ssR0FBRyxDQUFDMUQsVUFBSixDQUFnQmdjLFNBQWhCLEVBQTRCdGhCLE9BQTVCLEtBQXdDLEtBQXZEO01BQ0E7SUFDRCxDQWRXLENBZ0JaOzs7SUFDQWdKLEdBQUcsR0FBRyxJQUFOO0VBQ0EsQ0FsQkQ7O0VBcUJBLElBQUl5WSxVQUFVLEdBQUcsOEJBQWpCO0VBQUEsSUFDQ0MsU0FBUyxHQUFHLE1BRGI7RUFBQSxJQUVDQyxXQUFXLEdBQUcsZ0RBRmY7RUFBQSxJQUdDQyxXQUFXLEdBQUcsaUNBSGY7RUFBQSxJQUlDQyxjQUFjLEdBQUcscUJBSmxCOztFQU1BLFNBQVNDLFVBQVQsR0FBc0I7SUFDckIsT0FBTyxJQUFQO0VBQ0E7O0VBRUQsU0FBU0MsV0FBVCxHQUF1QjtJQUN0QixPQUFPLEtBQVA7RUFDQSxDQXZuSjZFLENBeW5KOUU7RUFDQTs7O0VBQ0EsU0FBU0MsaUJBQVQsR0FBNkI7SUFDNUIsSUFBSTtNQUNILE9BQU9ybUIsUUFBUSxDQUFDeVQsYUFBaEI7SUFDQSxDQUZELENBRUUsT0FBUTZTLEdBQVIsRUFBYyxDQUFHO0VBQ25COztFQUVELFNBQVNDLEdBQVQsQ0FBYTNqQixJQUFiLEVBQW1CNGpCLEtBQW5CLEVBQTBCdmxCLFFBQTFCLEVBQW9DeUUsSUFBcEMsRUFBMEN2RSxFQUExQyxFQUE4Q3NsQixHQUE5QyxFQUFvRDtJQUNuRCxJQUFJQyxNQUFKLEVBQVk1aEIsSUFBWixDQURtRCxDQUduRDs7SUFDQSxJQUFLLFFBQU8waEIsS0FBUCxNQUFpQixRQUF0QixFQUFpQztNQUVoQztNQUNBLElBQUssT0FBT3ZsQixRQUFQLEtBQW9CLFFBQXpCLEVBQW9DO1FBRW5DO1FBQ0F5RSxJQUFJLEdBQUdBLElBQUksSUFBSXpFLFFBQWY7UUFDQUEsUUFBUSxHQUFHbUQsU0FBWDtNQUNBOztNQUNELEtBQU1VLElBQU4sSUFBYzBoQixLQUFkLEVBQXNCO1FBQ3JCRCxHQUFFLENBQUUzakIsSUFBRixFQUFRa0MsSUFBUixFQUFjN0QsUUFBZCxFQUF3QnlFLElBQXhCLEVBQThCOGdCLEtBQUssQ0FBRTFoQixJQUFGLENBQW5DLEVBQTZDMmhCLEdBQTdDLENBQUY7TUFDQTs7TUFDRCxPQUFPN2pCLElBQVA7SUFDQTs7SUFFRCxJQUFLOEMsSUFBSSxJQUFJLElBQVIsSUFBZ0J2RSxFQUFFLElBQUksSUFBM0IsRUFBa0M7TUFFakM7TUFDQUEsRUFBRSxHQUFHRixRQUFMO01BQ0F5RSxJQUFJLEdBQUd6RSxRQUFRLEdBQUdtRCxTQUFsQjtJQUNBLENBTEQsTUFLTyxJQUFLakQsRUFBRSxJQUFJLElBQVgsRUFBa0I7TUFDeEIsSUFBSyxPQUFPRixRQUFQLEtBQW9CLFFBQXpCLEVBQW9DO1FBRW5DO1FBQ0FFLEVBQUUsR0FBR3VFLElBQUw7UUFDQUEsSUFBSSxHQUFHdEIsU0FBUDtNQUNBLENBTEQsTUFLTztRQUVOO1FBQ0FqRCxFQUFFLEdBQUd1RSxJQUFMO1FBQ0FBLElBQUksR0FBR3pFLFFBQVA7UUFDQUEsUUFBUSxHQUFHbUQsU0FBWDtNQUNBO0lBQ0Q7O0lBQ0QsSUFBS2pELEVBQUUsS0FBSyxLQUFaLEVBQW9CO01BQ25CQSxFQUFFLEdBQUdpbEIsV0FBTDtJQUNBLENBRkQsTUFFTyxJQUFLLENBQUNqbEIsRUFBTixFQUFXO01BQ2pCLE9BQU95QixJQUFQO0lBQ0E7O0lBRUQsSUFBSzZqQixHQUFHLEtBQUssQ0FBYixFQUFpQjtNQUNoQkMsTUFBTSxHQUFHdmxCLEVBQVQ7O01BQ0FBLEVBQUUsR0FBRyxZQUFVZ2QsS0FBVixFQUFrQjtRQUV0QjtRQUNBbmQsTUFBTSxHQUFHOGMsR0FBVCxDQUFjSyxLQUFkO1FBQ0EsT0FBT3VJLE1BQU0sQ0FBQzVqQixLQUFQLENBQWMsSUFBZCxFQUFvQkMsU0FBcEIsQ0FBUDtNQUNBLENBTEQsQ0FGZ0IsQ0FTaEI7OztNQUNBNUIsRUFBRSxDQUFDOEYsSUFBSCxHQUFVeWYsTUFBTSxDQUFDemYsSUFBUCxLQUFpQnlmLE1BQU0sQ0FBQ3pmLElBQVAsR0FBY2pHLE1BQU0sQ0FBQ2lHLElBQVAsRUFBL0IsQ0FBVjtJQUNBOztJQUNELE9BQU9yRSxJQUFJLENBQUNILElBQUwsQ0FBVyxZQUFXO01BQzVCekIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhdkUsR0FBYixDQUFrQixJQUFsQixFQUF3QjRNLEtBQXhCLEVBQStCcmxCLEVBQS9CLEVBQW1DdUUsSUFBbkMsRUFBeUN6RSxRQUF6QztJQUNBLENBRk0sQ0FBUDtFQUdBO0VBRUQ7QUFDQTtBQUNBO0FBQ0E7OztFQUNBRCxNQUFNLENBQUNtZCxLQUFQLEdBQWU7SUFFZHZlLE1BQU0sRUFBRSxFQUZNO0lBSWRnYSxHQUFHLEVBQUUsYUFBVWhYLElBQVYsRUFBZ0I0akIsS0FBaEIsRUFBdUI5WSxPQUF2QixFQUFnQ2hJLElBQWhDLEVBQXNDekUsUUFBdEMsRUFBaUQ7TUFDckQsSUFBSW1HLEdBQUo7TUFBQSxJQUFTdWYsTUFBVDtNQUFBLElBQWlCQyxDQUFqQjtNQUFBLElBQW9CQyxXQUFwQjtNQUFBLElBQ0NDLE9BREQ7TUFBQSxJQUNVQyxXQURWO01BQUEsSUFDdUJDLFNBRHZCO01BQUEsSUFFQ0MsUUFGRDtNQUFBLElBRVduaUIsSUFGWDtNQUFBLElBRWlCb2lCLFVBRmpCO01BQUEsSUFFNkJDLFFBRjdCO01BQUEsSUFHQ0MsUUFBUSxHQUFHcG1CLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsQ0FIWixDQURxRCxDQU1yRDs7O01BQ0EsSUFBSyxDQUFDd2tCLFFBQU4sRUFBaUI7UUFDaEI7TUFDQSxDQVRvRCxDQVdyRDs7O01BQ0EsSUFBSzFaLE9BQU8sQ0FBQ0EsT0FBYixFQUF1QjtRQUN0Qm1aLFdBQVcsR0FBR25aLE9BQWQ7UUFDQUEsT0FBTyxHQUFHbVosV0FBVyxDQUFDblosT0FBdEI7UUFDQXpNLFFBQVEsR0FBRzRsQixXQUFXLENBQUM1bEIsUUFBdkI7TUFDQSxDQWhCb0QsQ0FrQnJEOzs7TUFDQSxJQUFLLENBQUN5TSxPQUFPLENBQUN6RyxJQUFkLEVBQXFCO1FBQ3BCeUcsT0FBTyxDQUFDekcsSUFBUixHQUFlakcsTUFBTSxDQUFDaUcsSUFBUCxFQUFmO01BQ0EsQ0FyQm9ELENBdUJyRDs7O01BQ0EsSUFBSyxFQUFHMGYsTUFBTSxHQUFHUyxRQUFRLENBQUNULE1BQXJCLENBQUwsRUFBcUM7UUFDcENBLE1BQU0sR0FBR1MsUUFBUSxDQUFDVCxNQUFULEdBQWtCLEVBQTNCO01BQ0E7O01BQ0QsSUFBSyxFQUFHSSxXQUFXLEdBQUdLLFFBQVEsQ0FBQ0MsTUFBMUIsQ0FBTCxFQUEwQztRQUN6Q04sV0FBVyxHQUFHSyxRQUFRLENBQUNDLE1BQVQsR0FBa0IsVUFBVTloQixDQUFWLEVBQWM7VUFFN0M7VUFDQTtVQUNBLE9BQU8sT0FBT3ZFLE1BQVAsS0FBa0IsV0FBbEIsS0FDSixDQUFDdUUsQ0FBRCxJQUFNdkUsTUFBTSxDQUFDbWQsS0FBUCxDQUFhbUosU0FBYixLQUEyQi9oQixDQUFDLENBQUNULElBRC9CLElBRU45RCxNQUFNLENBQUNtZCxLQUFQLENBQWFvSixRQUFiLENBQXNCemtCLEtBQXRCLENBQTZCaWtCLFdBQVcsQ0FBQ25rQixJQUF6QyxFQUErQ0csU0FBL0MsQ0FGTSxHQUdOcUIsU0FIRDtRQUlBLENBUkQsQ0FEeUMsQ0FXekM7UUFDQTs7O1FBQ0EyaUIsV0FBVyxDQUFDbmtCLElBQVosR0FBbUJBLElBQW5CO01BQ0EsQ0F6Q29ELENBMkNyRDs7O01BQ0E0akIsS0FBSyxHQUFHLENBQUVBLEtBQUssSUFBSSxFQUFYLEVBQWdCOWEsS0FBaEIsQ0FBdUI2TyxTQUF2QixLQUFzQyxDQUFFLEVBQUYsQ0FBOUM7TUFDQXFNLENBQUMsR0FBR0osS0FBSyxDQUFDemtCLE1BQVY7O01BQ0EsT0FBUTZrQixDQUFDLEVBQVQsRUFBYztRQUNieGYsR0FBRyxHQUFHOGUsY0FBYyxDQUFDbmEsSUFBZixDQUFxQnlhLEtBQUssQ0FBRUksQ0FBRixDQUExQixLQUFxQyxFQUEzQztRQUNBOWhCLElBQUksR0FBR3FpQixRQUFRLEdBQUcvZixHQUFHLENBQUUsQ0FBRixDQUFyQjtRQUNBOGYsVUFBVSxHQUFHLENBQUU5ZixHQUFHLENBQUUsQ0FBRixDQUFILElBQVksRUFBZCxFQUFtQkssS0FBbkIsQ0FBMEIsR0FBMUIsRUFBZ0NuRSxJQUFoQyxFQUFiLENBSGEsQ0FLYjs7UUFDQSxJQUFLLENBQUN3QixJQUFOLEVBQWE7VUFDWjtRQUNBLENBUlksQ0FVYjs7O1FBQ0FnaUIsT0FBTyxHQUFHOWxCLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJJLE9BQWIsQ0FBc0JoaUIsSUFBdEIsS0FBZ0MsRUFBMUMsQ0FYYSxDQWFiOztRQUNBQSxJQUFJLEdBQUcsQ0FBRTdELFFBQVEsR0FBRzZsQixPQUFPLENBQUNVLFlBQVgsR0FBMEJWLE9BQU8sQ0FBQ1csUUFBNUMsS0FBMEQzaUIsSUFBakUsQ0FkYSxDQWdCYjs7UUFDQWdpQixPQUFPLEdBQUc5bEIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhMkksT0FBYixDQUFzQmhpQixJQUF0QixLQUFnQyxFQUExQyxDQWpCYSxDQW1CYjs7UUFDQWtpQixTQUFTLEdBQUdobUIsTUFBTSxDQUFDd0MsTUFBUCxDQUFlO1VBQzFCc0IsSUFBSSxFQUFFQSxJQURvQjtVQUUxQnFpQixRQUFRLEVBQUVBLFFBRmdCO1VBRzFCemhCLElBQUksRUFBRUEsSUFIb0I7VUFJMUJnSSxPQUFPLEVBQUVBLE9BSmlCO1VBSzFCekcsSUFBSSxFQUFFeUcsT0FBTyxDQUFDekcsSUFMWTtVQU0xQmhHLFFBQVEsRUFBRUEsUUFOZ0I7VUFPMUJrWCxZQUFZLEVBQUVsWCxRQUFRLElBQUlELE1BQU0sQ0FBQzBQLElBQVAsQ0FBWWhGLEtBQVosQ0FBa0J5TSxZQUFsQixDQUErQjlMLElBQS9CLENBQXFDcEwsUUFBckMsQ0FQQTtVQVExQnltQixTQUFTLEVBQUVSLFVBQVUsQ0FBQ3phLElBQVgsQ0FBaUIsR0FBakI7UUFSZSxDQUFmLEVBU1RvYSxXQVRTLENBQVosQ0FwQmEsQ0ErQmI7O1FBQ0EsSUFBSyxFQUFHSSxRQUFRLEdBQUdOLE1BQU0sQ0FBRTdoQixJQUFGLENBQXBCLENBQUwsRUFBc0M7VUFDckNtaUIsUUFBUSxHQUFHTixNQUFNLENBQUU3aEIsSUFBRixDQUFOLEdBQWlCLEVBQTVCO1VBQ0FtaUIsUUFBUSxDQUFDVSxhQUFULEdBQXlCLENBQXpCLENBRnFDLENBSXJDOztVQUNBLElBQUssQ0FBQ2IsT0FBTyxDQUFDYyxLQUFULElBQ0pkLE9BQU8sQ0FBQ2MsS0FBUixDQUFjM2xCLElBQWQsQ0FBb0JXLElBQXBCLEVBQTBCOEMsSUFBMUIsRUFBZ0N3aEIsVUFBaEMsRUFBNENILFdBQTVDLE1BQThELEtBRC9ELEVBQ3VFO1lBRXRFO1lBQ0EsSUFBS25rQixJQUFJLENBQUNpTSxnQkFBVixFQUE2QjtjQUM1QmpNLElBQUksQ0FBQ2lNLGdCQUFMLENBQXVCL0osSUFBdkIsRUFBNkJpaUIsV0FBN0IsRUFBMEMsS0FBMUM7WUFFQSxDQUhELE1BR08sSUFBS25rQixJQUFJLENBQUNrTSxXQUFWLEVBQXdCO2NBQzlCbE0sSUFBSSxDQUFDa00sV0FBTCxDQUFrQixPQUFPaEssSUFBekIsRUFBK0JpaUIsV0FBL0I7WUFDQTtVQUNEO1FBQ0Q7O1FBRUQsSUFBS0QsT0FBTyxDQUFDbE4sR0FBYixFQUFtQjtVQUNsQmtOLE9BQU8sQ0FBQ2xOLEdBQVIsQ0FBWTNYLElBQVosQ0FBa0JXLElBQWxCLEVBQXdCb2tCLFNBQXhCOztVQUVBLElBQUssQ0FBQ0EsU0FBUyxDQUFDdFosT0FBVixDQUFrQnpHLElBQXhCLEVBQStCO1lBQzlCK2YsU0FBUyxDQUFDdFosT0FBVixDQUFrQnpHLElBQWxCLEdBQXlCeUcsT0FBTyxDQUFDekcsSUFBakM7VUFDQTtRQUNELENBeERZLENBMERiOzs7UUFDQSxJQUFLaEcsUUFBTCxFQUFnQjtVQUNmZ21CLFFBQVEsQ0FBQzFqQixNQUFULENBQWlCMGpCLFFBQVEsQ0FBQ1UsYUFBVCxFQUFqQixFQUEyQyxDQUEzQyxFQUE4Q1gsU0FBOUM7UUFDQSxDQUZELE1BRU87VUFDTkMsUUFBUSxDQUFDem1CLElBQVQsQ0FBZXdtQixTQUFmO1FBQ0EsQ0EvRFksQ0FpRWI7OztRQUNBaG1CLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYXZlLE1BQWIsQ0FBcUJrRixJQUFyQixJQUE4QixJQUE5QjtNQUNBLENBakhvRCxDQW1IckQ7OztNQUNBbEMsSUFBSSxHQUFHLElBQVA7SUFDQSxDQXpIYTtJQTJIZDtJQUNBeVksTUFBTSxFQUFFLGdCQUFVelksSUFBVixFQUFnQjRqQixLQUFoQixFQUF1QjlZLE9BQXZCLEVBQWdDek0sUUFBaEMsRUFBMEM0bUIsV0FBMUMsRUFBd0Q7TUFDL0QsSUFBSXprQixDQUFKO01BQUEsSUFBTzRqQixTQUFQO01BQUEsSUFBa0I1ZixHQUFsQjtNQUFBLElBQ0MwZ0IsU0FERDtNQUFBLElBQ1lsQixDQURaO01BQUEsSUFDZUQsTUFEZjtNQUFBLElBRUNHLE9BRkQ7TUFBQSxJQUVVRyxRQUZWO01BQUEsSUFFb0JuaUIsSUFGcEI7TUFBQSxJQUdDb2lCLFVBSEQ7TUFBQSxJQUdhQyxRQUhiO01BQUEsSUFJQ0MsUUFBUSxHQUFHcG1CLE1BQU0sQ0FBQ2dmLE9BQVAsQ0FBZ0JwZCxJQUFoQixLQUEwQjVCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsQ0FKdEM7O01BTUEsSUFBSyxDQUFDd2tCLFFBQUQsSUFBYSxFQUFHVCxNQUFNLEdBQUdTLFFBQVEsQ0FBQ1QsTUFBckIsQ0FBbEIsRUFBa0Q7UUFDakQ7TUFDQSxDQVQ4RCxDQVcvRDs7O01BQ0FILEtBQUssR0FBRyxDQUFFQSxLQUFLLElBQUksRUFBWCxFQUFnQjlhLEtBQWhCLENBQXVCNk8sU0FBdkIsS0FBc0MsQ0FBRSxFQUFGLENBQTlDO01BQ0FxTSxDQUFDLEdBQUdKLEtBQUssQ0FBQ3prQixNQUFWOztNQUNBLE9BQVE2a0IsQ0FBQyxFQUFULEVBQWM7UUFDYnhmLEdBQUcsR0FBRzhlLGNBQWMsQ0FBQ25hLElBQWYsQ0FBcUJ5YSxLQUFLLENBQUVJLENBQUYsQ0FBMUIsS0FBcUMsRUFBM0M7UUFDQTloQixJQUFJLEdBQUdxaUIsUUFBUSxHQUFHL2YsR0FBRyxDQUFFLENBQUYsQ0FBckI7UUFDQThmLFVBQVUsR0FBRyxDQUFFOWYsR0FBRyxDQUFFLENBQUYsQ0FBSCxJQUFZLEVBQWQsRUFBbUJLLEtBQW5CLENBQTBCLEdBQTFCLEVBQWdDbkUsSUFBaEMsRUFBYixDQUhhLENBS2I7O1FBQ0EsSUFBSyxDQUFDd0IsSUFBTixFQUFhO1VBQ1osS0FBTUEsSUFBTixJQUFjNmhCLE1BQWQsRUFBdUI7WUFDdEIzbEIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhOUMsTUFBYixDQUFxQnpZLElBQXJCLEVBQTJCa0MsSUFBSSxHQUFHMGhCLEtBQUssQ0FBRUksQ0FBRixDQUF2QyxFQUE4Q2xaLE9BQTlDLEVBQXVEek0sUUFBdkQsRUFBaUUsSUFBakU7VUFDQTs7VUFDRDtRQUNBOztRQUVENmxCLE9BQU8sR0FBRzlsQixNQUFNLENBQUNtZCxLQUFQLENBQWEySSxPQUFiLENBQXNCaGlCLElBQXRCLEtBQWdDLEVBQTFDO1FBQ0FBLElBQUksR0FBRyxDQUFFN0QsUUFBUSxHQUFHNmxCLE9BQU8sQ0FBQ1UsWUFBWCxHQUEwQlYsT0FBTyxDQUFDVyxRQUE1QyxLQUEwRDNpQixJQUFqRTtRQUNBbWlCLFFBQVEsR0FBR04sTUFBTSxDQUFFN2hCLElBQUYsQ0FBTixJQUFrQixFQUE3QjtRQUNBc0MsR0FBRyxHQUFHQSxHQUFHLENBQUUsQ0FBRixDQUFILElBQ0wsSUFBSTBDLE1BQUosQ0FBWSxZQUFZb2QsVUFBVSxDQUFDemEsSUFBWCxDQUFpQixlQUFqQixDQUFaLEdBQWlELFNBQTdELENBREQsQ0FoQmEsQ0FtQmI7O1FBQ0FxYixTQUFTLEdBQUcxa0IsQ0FBQyxHQUFHNmpCLFFBQVEsQ0FBQ2xsQixNQUF6Qjs7UUFDQSxPQUFRcUIsQ0FBQyxFQUFULEVBQWM7VUFDYjRqQixTQUFTLEdBQUdDLFFBQVEsQ0FBRTdqQixDQUFGLENBQXBCOztVQUVBLElBQUssQ0FBRXlrQixXQUFXLElBQUlWLFFBQVEsS0FBS0gsU0FBUyxDQUFDRyxRQUF4QyxNQUNGLENBQUN6WixPQUFELElBQVlBLE9BQU8sQ0FBQ3pHLElBQVIsS0FBaUIrZixTQUFTLENBQUMvZixJQURyQyxNQUVGLENBQUNHLEdBQUQsSUFBUUEsR0FBRyxDQUFDaUYsSUFBSixDQUFVMmEsU0FBUyxDQUFDVSxTQUFwQixDQUZOLE1BR0YsQ0FBQ3ptQixRQUFELElBQWFBLFFBQVEsS0FBSytsQixTQUFTLENBQUMvbEIsUUFBcEMsSUFDREEsUUFBUSxLQUFLLElBQWIsSUFBcUIrbEIsU0FBUyxDQUFDL2xCLFFBSjVCLENBQUwsRUFJOEM7WUFDN0NnbUIsUUFBUSxDQUFDMWpCLE1BQVQsQ0FBaUJILENBQWpCLEVBQW9CLENBQXBCOztZQUVBLElBQUs0akIsU0FBUyxDQUFDL2xCLFFBQWYsRUFBMEI7Y0FDekJnbUIsUUFBUSxDQUFDVSxhQUFUO1lBQ0E7O1lBQ0QsSUFBS2IsT0FBTyxDQUFDekwsTUFBYixFQUFzQjtjQUNyQnlMLE9BQU8sQ0FBQ3pMLE1BQVIsQ0FBZXBaLElBQWYsQ0FBcUJXLElBQXJCLEVBQTJCb2tCLFNBQTNCO1lBQ0E7VUFDRDtRQUNELENBdENZLENBd0NiO1FBQ0E7OztRQUNBLElBQUtjLFNBQVMsSUFBSSxDQUFDYixRQUFRLENBQUNsbEIsTUFBNUIsRUFBcUM7VUFDcEMsSUFBSyxDQUFDK2tCLE9BQU8sQ0FBQ2lCLFFBQVQsSUFDSmpCLE9BQU8sQ0FBQ2lCLFFBQVIsQ0FBaUI5bEIsSUFBakIsQ0FBdUJXLElBQXZCLEVBQTZCc2tCLFVBQTdCLEVBQXlDRSxRQUFRLENBQUNDLE1BQWxELE1BQStELEtBRGhFLEVBQ3dFO1lBRXZFcm1CLE1BQU0sQ0FBQ2duQixXQUFQLENBQW9CcGxCLElBQXBCLEVBQTBCa0MsSUFBMUIsRUFBZ0NzaUIsUUFBUSxDQUFDQyxNQUF6QztVQUNBOztVQUVELE9BQU9WLE1BQU0sQ0FBRTdoQixJQUFGLENBQWI7UUFDQTtNQUNELENBakU4RCxDQW1FL0Q7OztNQUNBLElBQUs5RCxNQUFNLENBQUNvRSxhQUFQLENBQXNCdWhCLE1BQXRCLENBQUwsRUFBc0M7UUFDckMsT0FBT1MsUUFBUSxDQUFDQyxNQUFoQixDQURxQyxDQUdyQztRQUNBOztRQUNBcm1CLE1BQU0sQ0FBQ21mLFdBQVAsQ0FBb0J2ZCxJQUFwQixFQUEwQixRQUExQjtNQUNBO0lBQ0QsQ0F2TWE7SUF5TWRxbEIsT0FBTyxFQUFFLGlCQUFVOUosS0FBVixFQUFpQnpZLElBQWpCLEVBQXVCOUMsSUFBdkIsRUFBNkJzbEIsWUFBN0IsRUFBNEM7TUFDcEQsSUFBSWIsTUFBSjtNQUFBLElBQVljLE1BQVo7TUFBQSxJQUFvQnRhLEdBQXBCO01BQUEsSUFDQ3VhLFVBREQ7TUFBQSxJQUNhdEIsT0FEYjtNQUFBLElBQ3NCMWYsR0FEdEI7TUFBQSxJQUMyQnZFLENBRDNCO01BQUEsSUFFQ3dsQixTQUFTLEdBQUcsQ0FBRXpsQixJQUFJLElBQUk1QyxRQUFWLENBRmI7TUFBQSxJQUdDOEUsSUFBSSxHQUFHbEUsTUFBTSxDQUFDcUIsSUFBUCxDQUFha2MsS0FBYixFQUFvQixNQUFwQixJQUErQkEsS0FBSyxDQUFDclosSUFBckMsR0FBNENxWixLQUhwRDtNQUFBLElBSUMrSSxVQUFVLEdBQUd0bUIsTUFBTSxDQUFDcUIsSUFBUCxDQUFha2MsS0FBYixFQUFvQixXQUFwQixJQUFvQ0EsS0FBSyxDQUFDdUosU0FBTixDQUFnQmpnQixLQUFoQixDQUF1QixHQUF2QixDQUFwQyxHQUFtRSxFQUpqRjtNQU1Bb0csR0FBRyxHQUFHekcsR0FBRyxHQUFHeEUsSUFBSSxHQUFHQSxJQUFJLElBQUk1QyxRQUEzQixDQVBvRCxDQVNwRDs7TUFDQSxJQUFLNEMsSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUFsQixJQUF1QjFDLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBOUMsRUFBa0Q7UUFDakQ7TUFDQSxDQVptRCxDQWNwRDs7O01BQ0EsSUFBSzJnQixXQUFXLENBQUM1WixJQUFaLENBQWtCdkgsSUFBSSxHQUFHOUQsTUFBTSxDQUFDbWQsS0FBUCxDQUFhbUosU0FBdEMsQ0FBTCxFQUF5RDtRQUN4RDtNQUNBOztNQUVELElBQUt4aUIsSUFBSSxDQUFDckUsT0FBTCxDQUFjLEdBQWQsSUFBc0IsQ0FBQyxDQUE1QixFQUFnQztRQUUvQjtRQUNBeW1CLFVBQVUsR0FBR3BpQixJQUFJLENBQUMyQyxLQUFMLENBQVksR0FBWixDQUFiO1FBQ0EzQyxJQUFJLEdBQUdvaUIsVUFBVSxDQUFDaGEsS0FBWCxFQUFQO1FBQ0FnYSxVQUFVLENBQUM1akIsSUFBWDtNQUNBOztNQUNENmtCLE1BQU0sR0FBR3JqQixJQUFJLENBQUNyRSxPQUFMLENBQWMsR0FBZCxJQUFzQixDQUF0QixJQUEyQixPQUFPcUUsSUFBM0MsQ0ExQm9ELENBNEJwRDs7TUFDQXFaLEtBQUssR0FBR0EsS0FBSyxDQUFFbmQsTUFBTSxDQUFDcUQsT0FBVCxDQUFMLEdBQ1A4WixLQURPLEdBRVAsSUFBSW5kLE1BQU0sQ0FBQ3NuQixLQUFYLENBQWtCeGpCLElBQWxCLEVBQXdCLFFBQU9xWixLQUFQLE1BQWlCLFFBQWpCLElBQTZCQSxLQUFyRCxDQUZELENBN0JvRCxDQWlDcEQ7O01BQ0FBLEtBQUssQ0FBQ29LLFNBQU4sR0FBa0JMLFlBQVksR0FBRyxDQUFILEdBQU8sQ0FBckM7TUFDQS9KLEtBQUssQ0FBQ3VKLFNBQU4sR0FBa0JSLFVBQVUsQ0FBQ3phLElBQVgsQ0FBaUIsR0FBakIsQ0FBbEI7TUFDQTBSLEtBQUssQ0FBQ3FLLFVBQU4sR0FBbUJySyxLQUFLLENBQUN1SixTQUFOLEdBQ2xCLElBQUk1ZCxNQUFKLENBQVksWUFBWW9kLFVBQVUsQ0FBQ3phLElBQVgsQ0FBaUIsZUFBakIsQ0FBWixHQUFpRCxTQUE3RCxDQURrQixHQUVsQixJQUZELENBcENvRCxDQXdDcEQ7O01BQ0EwUixLQUFLLENBQUNsTSxNQUFOLEdBQWU3TixTQUFmOztNQUNBLElBQUssQ0FBQytaLEtBQUssQ0FBQ3BhLE1BQVosRUFBcUI7UUFDcEJvYSxLQUFLLENBQUNwYSxNQUFOLEdBQWVuQixJQUFmO01BQ0EsQ0E1Q21ELENBOENwRDs7O01BQ0E4QyxJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFSLEdBQ04sQ0FBRXlZLEtBQUYsQ0FETSxHQUVObmQsTUFBTSxDQUFDbUYsU0FBUCxDQUFrQlQsSUFBbEIsRUFBd0IsQ0FBRXlZLEtBQUYsQ0FBeEIsQ0FGRCxDQS9Db0QsQ0FtRHBEOztNQUNBMkksT0FBTyxHQUFHOWxCLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJJLE9BQWIsQ0FBc0JoaUIsSUFBdEIsS0FBZ0MsRUFBMUM7O01BQ0EsSUFBSyxDQUFDb2pCLFlBQUQsSUFBaUJwQixPQUFPLENBQUNtQixPQUF6QixJQUFvQ25CLE9BQU8sQ0FBQ21CLE9BQVIsQ0FBZ0JubEIsS0FBaEIsQ0FBdUJGLElBQXZCLEVBQTZCOEMsSUFBN0IsTUFBd0MsS0FBakYsRUFBeUY7UUFDeEY7TUFDQSxDQXZEbUQsQ0F5RHBEO01BQ0E7OztNQUNBLElBQUssQ0FBQ3dpQixZQUFELElBQWlCLENBQUNwQixPQUFPLENBQUMyQixRQUExQixJQUFzQyxDQUFDem5CLE1BQU0sQ0FBQ2dFLFFBQVAsQ0FBaUJwQyxJQUFqQixDQUE1QyxFQUFzRTtRQUVyRXdsQixVQUFVLEdBQUd0QixPQUFPLENBQUNVLFlBQVIsSUFBd0IxaUIsSUFBckM7O1FBQ0EsSUFBSyxDQUFDbWhCLFdBQVcsQ0FBQzVaLElBQVosQ0FBa0IrYixVQUFVLEdBQUd0akIsSUFBL0IsQ0FBTixFQUE4QztVQUM3QytJLEdBQUcsR0FBR0EsR0FBRyxDQUFDbEIsVUFBVjtRQUNBOztRQUNELE9BQVFrQixHQUFSLEVBQWFBLEdBQUcsR0FBR0EsR0FBRyxDQUFDbEIsVUFBdkIsRUFBb0M7VUFDbkMwYixTQUFTLENBQUM3bkIsSUFBVixDQUFnQnFOLEdBQWhCO1VBQ0F6RyxHQUFHLEdBQUd5RyxHQUFOO1FBQ0EsQ0FUb0UsQ0FXckU7OztRQUNBLElBQUt6RyxHQUFHLE1BQU94RSxJQUFJLENBQUNrSixhQUFMLElBQXNCOUwsUUFBN0IsQ0FBUixFQUFrRDtVQUNqRHFvQixTQUFTLENBQUM3bkIsSUFBVixDQUFnQjRHLEdBQUcsQ0FBQ3VILFdBQUosSUFBbUJ2SCxHQUFHLENBQUNzaEIsWUFBdkIsSUFBdUN2b0IsTUFBdkQ7UUFDQTtNQUNELENBMUVtRCxDQTRFcEQ7OztNQUNBMEMsQ0FBQyxHQUFHLENBQUo7O01BQ0EsT0FBUSxDQUFFZ0wsR0FBRyxHQUFHd2EsU0FBUyxDQUFFeGxCLENBQUMsRUFBSCxDQUFqQixLQUE4QixDQUFDc2IsS0FBSyxDQUFDd0ssb0JBQU4sRUFBdkMsRUFBc0U7UUFFckV4SyxLQUFLLENBQUNyWixJQUFOLEdBQWFqQyxDQUFDLEdBQUcsQ0FBSixHQUNadWxCLFVBRFksR0FFWnRCLE9BQU8sQ0FBQ1csUUFBUixJQUFvQjNpQixJQUZyQixDQUZxRSxDQU1yRTs7UUFDQXVpQixNQUFNLEdBQUcsQ0FBRXJtQixNQUFNLENBQUNrZixLQUFQLENBQWNyUyxHQUFkLEVBQW1CLFFBQW5CLEtBQWlDLEVBQW5DLEVBQXlDc1EsS0FBSyxDQUFDclosSUFBL0MsS0FDUjlELE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3JTLEdBQWQsRUFBbUIsUUFBbkIsQ0FERDs7UUFHQSxJQUFLd1osTUFBTCxFQUFjO1VBQ2JBLE1BQU0sQ0FBQ3ZrQixLQUFQLENBQWMrSyxHQUFkLEVBQW1CbkksSUFBbkI7UUFDQSxDQVpvRSxDQWNyRTs7O1FBQ0EyaEIsTUFBTSxHQUFHYyxNQUFNLElBQUl0YSxHQUFHLENBQUVzYSxNQUFGLENBQXRCOztRQUNBLElBQUtkLE1BQU0sSUFBSUEsTUFBTSxDQUFDdmtCLEtBQWpCLElBQTBCbWMsVUFBVSxDQUFFcFIsR0FBRixDQUF6QyxFQUFtRDtVQUNsRHNRLEtBQUssQ0FBQ2xNLE1BQU4sR0FBZW9WLE1BQU0sQ0FBQ3ZrQixLQUFQLENBQWMrSyxHQUFkLEVBQW1CbkksSUFBbkIsQ0FBZjs7VUFDQSxJQUFLeVksS0FBSyxDQUFDbE0sTUFBTixLQUFpQixLQUF0QixFQUE4QjtZQUM3QmtNLEtBQUssQ0FBQ3lLLGNBQU47VUFDQTtRQUNEO01BQ0Q7O01BQ0R6SyxLQUFLLENBQUNyWixJQUFOLEdBQWFBLElBQWIsQ0FyR29ELENBdUdwRDs7TUFDQSxJQUFLLENBQUNvakIsWUFBRCxJQUFpQixDQUFDL0osS0FBSyxDQUFDMEssa0JBQU4sRUFBdkIsRUFBb0Q7UUFFbkQsSUFDQyxDQUFFLENBQUMvQixPQUFPLENBQUMxQyxRQUFULElBQ0QwQyxPQUFPLENBQUMxQyxRQUFSLENBQWlCdGhCLEtBQWpCLENBQXdCdWxCLFNBQVMsQ0FBQ2hmLEdBQVYsRUFBeEIsRUFBeUMzRCxJQUF6QyxNQUFvRCxLQURyRCxLQUVLdVosVUFBVSxDQUFFcmMsSUFBRixDQUhoQixFQUlFO1VBRUQ7VUFDQTtVQUNBO1VBQ0EsSUFBS3VsQixNQUFNLElBQUl2bEIsSUFBSSxDQUFFa0MsSUFBRixDQUFkLElBQTBCLENBQUM5RCxNQUFNLENBQUNnRSxRQUFQLENBQWlCcEMsSUFBakIsQ0FBaEMsRUFBMEQ7WUFFekQ7WUFDQXdFLEdBQUcsR0FBR3hFLElBQUksQ0FBRXVsQixNQUFGLENBQVY7O1lBRUEsSUFBSy9nQixHQUFMLEVBQVc7Y0FDVnhFLElBQUksQ0FBRXVsQixNQUFGLENBQUosR0FBaUIsSUFBakI7WUFDQSxDQVB3RCxDQVN6RDs7O1lBQ0FubkIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhbUosU0FBYixHQUF5QnhpQixJQUF6Qjs7WUFDQSxJQUFJO2NBQ0hsQyxJQUFJLENBQUVrQyxJQUFGLENBQUo7WUFDQSxDQUZELENBRUUsT0FBUVMsQ0FBUixFQUFZLENBRWI7Y0FDQTtZQUNBOztZQUNEdkUsTUFBTSxDQUFDbWQsS0FBUCxDQUFhbUosU0FBYixHQUF5QmxqQixTQUF6Qjs7WUFFQSxJQUFLZ0QsR0FBTCxFQUFXO2NBQ1Z4RSxJQUFJLENBQUV1bEIsTUFBRixDQUFKLEdBQWlCL2dCLEdBQWpCO1lBQ0E7VUFDRDtRQUNEO01BQ0Q7O01BRUQsT0FBTytXLEtBQUssQ0FBQ2xNLE1BQWI7SUFDQSxDQXhWYTtJQTBWZHNWLFFBQVEsRUFBRSxrQkFBVXBKLEtBQVYsRUFBa0I7TUFFM0I7TUFDQUEsS0FBSyxHQUFHbmQsTUFBTSxDQUFDbWQsS0FBUCxDQUFhMkssR0FBYixDQUFrQjNLLEtBQWxCLENBQVI7O01BRUEsSUFBSXRiLENBQUo7TUFBQSxJQUFPTyxDQUFQO01BQUEsSUFBVWQsR0FBVjtNQUFBLElBQWUyUSxPQUFmO01BQUEsSUFBd0IrVCxTQUF4QjtNQUFBLElBQ0MrQixZQUFZLEdBQUcsRUFEaEI7TUFBQSxJQUVDNWhCLElBQUksR0FBRzdHLE1BQUssQ0FBQzJCLElBQU4sQ0FBWWMsU0FBWixDQUZSO01BQUEsSUFHQ2trQixRQUFRLEdBQUcsQ0FBRWptQixNQUFNLENBQUNrZixLQUFQLENBQWMsSUFBZCxFQUFvQixRQUFwQixLQUFrQyxFQUFwQyxFQUEwQy9CLEtBQUssQ0FBQ3JaLElBQWhELEtBQTBELEVBSHRFO01BQUEsSUFJQ2dpQixPQUFPLEdBQUc5bEIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhMkksT0FBYixDQUFzQjNJLEtBQUssQ0FBQ3JaLElBQTVCLEtBQXNDLEVBSmpELENBTDJCLENBVzNCOzs7TUFDQXFDLElBQUksQ0FBRSxDQUFGLENBQUosR0FBWWdYLEtBQVo7TUFDQUEsS0FBSyxDQUFDNkssY0FBTixHQUF1QixJQUF2QixDQWIyQixDQWUzQjs7TUFDQSxJQUFLbEMsT0FBTyxDQUFDbUMsV0FBUixJQUF1Qm5DLE9BQU8sQ0FBQ21DLFdBQVIsQ0FBb0JobkIsSUFBcEIsQ0FBMEIsSUFBMUIsRUFBZ0NrYyxLQUFoQyxNQUE0QyxLQUF4RSxFQUFnRjtRQUMvRTtNQUNBLENBbEIwQixDQW9CM0I7OztNQUNBNEssWUFBWSxHQUFHL25CLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYThJLFFBQWIsQ0FBc0JobEIsSUFBdEIsQ0FBNEIsSUFBNUIsRUFBa0NrYyxLQUFsQyxFQUF5QzhJLFFBQXpDLENBQWYsQ0FyQjJCLENBdUIzQjs7TUFDQXBrQixDQUFDLEdBQUcsQ0FBSjs7TUFDQSxPQUFRLENBQUVvUSxPQUFPLEdBQUc4VixZQUFZLENBQUVsbUIsQ0FBQyxFQUFILENBQXhCLEtBQXFDLENBQUNzYixLQUFLLENBQUN3SyxvQkFBTixFQUE5QyxFQUE2RTtRQUM1RXhLLEtBQUssQ0FBQytLLGFBQU4sR0FBc0JqVyxPQUFPLENBQUNyUSxJQUE5QjtRQUVBUSxDQUFDLEdBQUcsQ0FBSjs7UUFDQSxPQUFRLENBQUU0akIsU0FBUyxHQUFHL1QsT0FBTyxDQUFDZ1UsUUFBUixDQUFrQjdqQixDQUFDLEVBQW5CLENBQWQsS0FDUCxDQUFDK2EsS0FBSyxDQUFDZ0wsNkJBQU4sRUFERixFQUMwQztVQUV6QztVQUNBO1VBQ0EsSUFBSyxDQUFDaEwsS0FBSyxDQUFDcUssVUFBUCxJQUFxQnJLLEtBQUssQ0FBQ3FLLFVBQU4sQ0FBaUJuYyxJQUFqQixDQUF1QjJhLFNBQVMsQ0FBQ1UsU0FBakMsQ0FBMUIsRUFBeUU7WUFFeEV2SixLQUFLLENBQUM2SSxTQUFOLEdBQWtCQSxTQUFsQjtZQUNBN0ksS0FBSyxDQUFDelksSUFBTixHQUFhc2hCLFNBQVMsQ0FBQ3RoQixJQUF2QjtZQUVBcEQsR0FBRyxHQUFHLENBQUUsQ0FBRXRCLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJJLE9BQWIsQ0FBc0JFLFNBQVMsQ0FBQ0csUUFBaEMsS0FBOEMsRUFBaEQsRUFBcURFLE1BQXJELElBQ1BMLFNBQVMsQ0FBQ3RaLE9BREwsRUFDZTVLLEtBRGYsQ0FDc0JtUSxPQUFPLENBQUNyUSxJQUQ5QixFQUNvQ3VFLElBRHBDLENBQU47O1lBR0EsSUFBSzdFLEdBQUcsS0FBSzhCLFNBQWIsRUFBeUI7Y0FDeEIsSUFBSyxDQUFFK1osS0FBSyxDQUFDbE0sTUFBTixHQUFlM1AsR0FBakIsTUFBMkIsS0FBaEMsRUFBd0M7Z0JBQ3ZDNmIsS0FBSyxDQUFDeUssY0FBTjtnQkFDQXpLLEtBQUssQ0FBQ2lMLGVBQU47Y0FDQTtZQUNEO1VBQ0Q7UUFDRDtNQUNELENBbEQwQixDQW9EM0I7OztNQUNBLElBQUt0QyxPQUFPLENBQUN1QyxZQUFiLEVBQTRCO1FBQzNCdkMsT0FBTyxDQUFDdUMsWUFBUixDQUFxQnBuQixJQUFyQixDQUEyQixJQUEzQixFQUFpQ2tjLEtBQWpDO01BQ0E7O01BRUQsT0FBT0EsS0FBSyxDQUFDbE0sTUFBYjtJQUNBLENBcFphO0lBc1pkZ1YsUUFBUSxFQUFFLGtCQUFVOUksS0FBVixFQUFpQjhJLFNBQWpCLEVBQTRCO01BQ3JDLElBQUlwa0IsQ0FBSjtNQUFBLElBQU9nRSxPQUFQO01BQUEsSUFBZ0J5aUIsR0FBaEI7TUFBQSxJQUFxQnRDLFNBQXJCO01BQUEsSUFDQytCLFlBQVksR0FBRyxFQURoQjtNQUFBLElBRUNwQixhQUFhLEdBQUdWLFNBQVEsQ0FBQ1UsYUFGMUI7TUFBQSxJQUdDOVosR0FBRyxHQUFHc1EsS0FBSyxDQUFDcGEsTUFIYixDQURxQyxDQU1yQztNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O01BQ0EsSUFBSzRqQixhQUFhLElBQUk5WixHQUFHLENBQUN2SSxRQUFyQixLQUNGNlksS0FBSyxDQUFDclosSUFBTixLQUFlLE9BQWYsSUFBMEJ5a0IsS0FBSyxDQUFFcEwsS0FBSyxDQUFDcUwsTUFBUixDQUEvQixJQUFtRHJMLEtBQUssQ0FBQ3FMLE1BQU4sR0FBZSxDQURoRSxDQUFMLEVBQzJFO1FBRTFFO1FBQ0EsT0FBUTNiLEdBQUcsSUFBSSxJQUFmLEVBQXFCQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ2xCLFVBQUosSUFBa0IsSUFBN0MsRUFBb0Q7VUFDbkQ7VUFFQTtVQUNBO1VBQ0EsSUFBS2tCLEdBQUcsQ0FBQ3ZJLFFBQUosS0FBaUIsQ0FBakIsS0FBd0J1SSxHQUFHLENBQUNnRyxRQUFKLEtBQWlCLElBQWpCLElBQXlCc0ssS0FBSyxDQUFDclosSUFBTixLQUFlLE9BQWhFLENBQUwsRUFBaUY7WUFDaEYrQixPQUFPLEdBQUcsRUFBVjs7WUFDQSxLQUFNaEUsQ0FBQyxHQUFHLENBQVYsRUFBYUEsQ0FBQyxHQUFHOGtCLGFBQWpCLEVBQWdDOWtCLENBQUMsRUFBakMsRUFBc0M7Y0FDckNta0IsU0FBUyxHQUFHQyxTQUFRLENBQUVwa0IsQ0FBRixDQUFwQixDQURxQyxDQUdyQzs7Y0FDQXltQixHQUFHLEdBQUd0QyxTQUFTLENBQUMvbEIsUUFBVixHQUFxQixHQUEzQjs7Y0FFQSxJQUFLNEYsT0FBTyxDQUFFeWlCLEdBQUYsQ0FBUCxLQUFtQmxsQixTQUF4QixFQUFvQztnQkFDbkN5QyxPQUFPLENBQUV5aUIsR0FBRixDQUFQLEdBQWlCdEMsU0FBUyxDQUFDN08sWUFBVixHQUNoQm5YLE1BQU0sQ0FBRXNvQixHQUFGLEVBQU8sSUFBUCxDQUFOLENBQW9CNVAsS0FBcEIsQ0FBMkI3TCxHQUEzQixJQUFtQyxDQUFDLENBRHBCLEdBRWhCN00sTUFBTSxDQUFDb08sSUFBUCxDQUFha2EsR0FBYixFQUFrQixJQUFsQixFQUF3QixJQUF4QixFQUE4QixDQUFFemIsR0FBRixDQUE5QixFQUF3QzlMLE1BRnpDO2NBR0E7O2NBQ0QsSUFBSzhFLE9BQU8sQ0FBRXlpQixHQUFGLENBQVosRUFBc0I7Z0JBQ3JCemlCLE9BQU8sQ0FBQ3JHLElBQVIsQ0FBY3dtQixTQUFkO2NBQ0E7WUFDRDs7WUFDRCxJQUFLbmdCLE9BQU8sQ0FBQzlFLE1BQWIsRUFBc0I7Y0FDckJnbkIsWUFBWSxDQUFDdm9CLElBQWIsQ0FBbUI7Z0JBQUVvQyxJQUFJLEVBQUVpTCxHQUFSO2dCQUFhb1osUUFBUSxFQUFFcGdCO2NBQXZCLENBQW5CO1lBQ0E7VUFDRDtRQUNEO01BQ0QsQ0EzQ29DLENBNkNyQzs7O01BQ0EsSUFBSzhnQixhQUFhLEdBQUdWLFNBQVEsQ0FBQ2xsQixNQUE5QixFQUF1QztRQUN0Q2duQixZQUFZLENBQUN2b0IsSUFBYixDQUFtQjtVQUFFb0MsSUFBSSxFQUFFLElBQVI7VUFBY3FrQixRQUFRLEVBQUVBLFNBQVEsQ0FBQzNtQixLQUFULENBQWdCcW5CLGFBQWhCO1FBQXhCLENBQW5CO01BQ0E7O01BRUQsT0FBT29CLFlBQVA7SUFDQSxDQXpjYTtJQTJjZEQsR0FBRyxFQUFFLGFBQVUzSyxLQUFWLEVBQWtCO01BQ3RCLElBQUtBLEtBQUssQ0FBRW5kLE1BQU0sQ0FBQ3FELE9BQVQsQ0FBVixFQUErQjtRQUM5QixPQUFPOFosS0FBUDtNQUNBLENBSHFCLENBS3RCOzs7TUFDQSxJQUFJdGIsQ0FBSjtNQUFBLElBQU8yZSxJQUFQO01BQUEsSUFBYTdkLElBQWI7TUFBQSxJQUNDbUIsSUFBSSxHQUFHcVosS0FBSyxDQUFDclosSUFEZDtNQUFBLElBRUMya0IsYUFBYSxHQUFHdEwsS0FGakI7TUFBQSxJQUdDdUwsT0FBTyxHQUFHLEtBQUtDLFFBQUwsQ0FBZTdrQixJQUFmLENBSFg7O01BS0EsSUFBSyxDQUFDNGtCLE9BQU4sRUFBZ0I7UUFDZixLQUFLQyxRQUFMLENBQWU3a0IsSUFBZixJQUF3QjRrQixPQUFPLEdBQzlCMUQsV0FBVyxDQUFDM1osSUFBWixDQUFrQnZILElBQWxCLElBQTJCLEtBQUs4a0IsVUFBaEMsR0FDQTdELFNBQVMsQ0FBQzFaLElBQVYsQ0FBZ0J2SCxJQUFoQixJQUF5QixLQUFLK2tCLFFBQTlCLEdBQ0EsRUFIRDtNQUlBOztNQUNEbG1CLElBQUksR0FBRytsQixPQUFPLENBQUNJLEtBQVIsR0FBZ0IsS0FBS0EsS0FBTCxDQUFXdnBCLE1BQVgsQ0FBbUJtcEIsT0FBTyxDQUFDSSxLQUEzQixDQUFoQixHQUFxRCxLQUFLQSxLQUFqRTtNQUVBM0wsS0FBSyxHQUFHLElBQUluZCxNQUFNLENBQUNzbkIsS0FBWCxDQUFrQm1CLGFBQWxCLENBQVI7TUFFQTVtQixDQUFDLEdBQUdjLElBQUksQ0FBQzVCLE1BQVQ7O01BQ0EsT0FBUWMsQ0FBQyxFQUFULEVBQWM7UUFDYjJlLElBQUksR0FBRzdkLElBQUksQ0FBRWQsQ0FBRixDQUFYO1FBQ0FzYixLQUFLLENBQUVxRCxJQUFGLENBQUwsR0FBZ0JpSSxhQUFhLENBQUVqSSxJQUFGLENBQTdCO01BQ0EsQ0F6QnFCLENBMkJ0QjtNQUNBOzs7TUFDQSxJQUFLLENBQUNyRCxLQUFLLENBQUNwYSxNQUFaLEVBQXFCO1FBQ3BCb2EsS0FBSyxDQUFDcGEsTUFBTixHQUFlMGxCLGFBQWEsQ0FBQ00sVUFBZCxJQUE0Qi9wQixRQUEzQztNQUNBLENBL0JxQixDQWlDdEI7TUFDQTs7O01BQ0EsSUFBS21lLEtBQUssQ0FBQ3BhLE1BQU4sQ0FBYXVCLFFBQWIsS0FBMEIsQ0FBL0IsRUFBbUM7UUFDbEM2WSxLQUFLLENBQUNwYSxNQUFOLEdBQWVvYSxLQUFLLENBQUNwYSxNQUFOLENBQWE0SSxVQUE1QjtNQUNBLENBckNxQixDQXVDdEI7TUFDQTs7O01BQ0F3UixLQUFLLENBQUM2TCxPQUFOLEdBQWdCLENBQUMsQ0FBQzdMLEtBQUssQ0FBQzZMLE9BQXhCO01BRUEsT0FBT04sT0FBTyxDQUFDcmEsTUFBUixHQUFpQnFhLE9BQU8sQ0FBQ3JhLE1BQVIsQ0FBZ0I4TyxLQUFoQixFQUF1QnNMLGFBQXZCLENBQWpCLEdBQTBEdEwsS0FBakU7SUFDQSxDQXZmYTtJQXlmZDtJQUNBMkwsS0FBSyxFQUFFLENBQUUsdUVBQ1IsNERBRE0sRUFDeURyaUIsS0FEekQsQ0FDZ0UsR0FEaEUsQ0ExZk87SUE2ZmRraUIsUUFBUSxFQUFFLEVBN2ZJO0lBK2ZkRSxRQUFRLEVBQUU7TUFDVEMsS0FBSyxFQUFFLDRCQUE0QnJpQixLQUE1QixDQUFtQyxHQUFuQyxDQURFO01BRVQ0SCxNQUFNLEVBQUUsZ0JBQVU4TyxLQUFWLEVBQWlCOEwsUUFBakIsRUFBNEI7UUFFbkM7UUFDQSxJQUFLOUwsS0FBSyxDQUFDK0wsS0FBTixJQUFlLElBQXBCLEVBQTJCO1VBQzFCL0wsS0FBSyxDQUFDK0wsS0FBTixHQUFjRCxRQUFRLENBQUNFLFFBQVQsSUFBcUIsSUFBckIsR0FBNEJGLFFBQVEsQ0FBQ0UsUUFBckMsR0FBZ0RGLFFBQVEsQ0FBQ0csT0FBdkU7UUFDQTs7UUFFRCxPQUFPak0sS0FBUDtNQUNBO0lBVlEsQ0EvZkk7SUE0Z0JkeUwsVUFBVSxFQUFFO01BQ1hFLEtBQUssRUFBRSxDQUFFLGdFQUNSLHVDQURNLEVBQ29DcmlCLEtBRHBDLENBQzJDLEdBRDNDLENBREk7TUFHWDRILE1BQU0sRUFBRSxnQkFBVThPLEtBQVYsRUFBaUI4TCxRQUFqQixFQUE0QjtRQUNuQyxJQUFJdkwsSUFBSjtRQUFBLElBQVUyTCxRQUFWO1FBQUEsSUFBb0IzYixHQUFwQjtRQUFBLElBQ0M4YSxNQUFNLEdBQUdTLFFBQVEsQ0FBQ1QsTUFEbkI7UUFBQSxJQUVDYyxXQUFXLEdBQUdMLFFBQVEsQ0FBQ0ssV0FGeEIsQ0FEbUMsQ0FLbkM7O1FBQ0EsSUFBS25NLEtBQUssQ0FBQ29NLEtBQU4sSUFBZSxJQUFmLElBQXVCTixRQUFRLENBQUNPLE9BQVQsSUFBb0IsSUFBaEQsRUFBdUQ7VUFDdERILFFBQVEsR0FBR2xNLEtBQUssQ0FBQ3BhLE1BQU4sQ0FBYStILGFBQWIsSUFBOEI5TCxRQUF6QztVQUNBME8sR0FBRyxHQUFHMmIsUUFBUSxDQUFDL2IsZUFBZjtVQUNBb1EsSUFBSSxHQUFHMkwsUUFBUSxDQUFDM0wsSUFBaEI7VUFFQVAsS0FBSyxDQUFDb00sS0FBTixHQUFjTixRQUFRLENBQUNPLE9BQVQsSUFDWDliLEdBQUcsSUFBSUEsR0FBRyxDQUFDK2IsVUFBWCxJQUF5Qi9MLElBQUksSUFBSUEsSUFBSSxDQUFDK0wsVUFBdEMsSUFBb0QsQ0FEekMsS0FFWC9iLEdBQUcsSUFBSUEsR0FBRyxDQUFDZ2MsVUFBWCxJQUF5QmhNLElBQUksSUFBSUEsSUFBSSxDQUFDZ00sVUFBdEMsSUFBb0QsQ0FGekMsQ0FBZDtVQUdBdk0sS0FBSyxDQUFDd00sS0FBTixHQUFjVixRQUFRLENBQUNXLE9BQVQsSUFDWGxjLEdBQUcsSUFBSUEsR0FBRyxDQUFDbWMsU0FBWCxJQUF5Qm5NLElBQUksSUFBSUEsSUFBSSxDQUFDbU0sU0FBdEMsSUFBb0QsQ0FEekMsS0FFWG5jLEdBQUcsSUFBSUEsR0FBRyxDQUFDb2MsU0FBWCxJQUF5QnBNLElBQUksSUFBSUEsSUFBSSxDQUFDb00sU0FBdEMsSUFBb0QsQ0FGekMsQ0FBZDtRQUdBLENBakJrQyxDQW1CbkM7OztRQUNBLElBQUssQ0FBQzNNLEtBQUssQ0FBQzRNLGFBQVAsSUFBd0JULFdBQTdCLEVBQTJDO1VBQzFDbk0sS0FBSyxDQUFDNE0sYUFBTixHQUFzQlQsV0FBVyxLQUFLbk0sS0FBSyxDQUFDcGEsTUFBdEIsR0FDckJrbUIsUUFBUSxDQUFDZSxTQURZLEdBRXJCVixXQUZEO1FBR0EsQ0F4QmtDLENBMEJuQztRQUNBOzs7UUFDQSxJQUFLLENBQUNuTSxLQUFLLENBQUMrTCxLQUFQLElBQWdCVixNQUFNLEtBQUtwbEIsU0FBaEMsRUFBNEM7VUFDM0MrWixLQUFLLENBQUMrTCxLQUFOLEdBQWdCVixNQUFNLEdBQUcsQ0FBVCxHQUFhLENBQWIsR0FBbUJBLE1BQU0sR0FBRyxDQUFULEdBQWEsQ0FBYixHQUFtQkEsTUFBTSxHQUFHLENBQVQsR0FBYSxDQUFiLEdBQWlCLENBQXZFO1FBQ0E7O1FBRUQsT0FBT3JMLEtBQVA7TUFDQTtJQXBDVSxDQTVnQkU7SUFtakJkMkksT0FBTyxFQUFFO01BQ1JtRSxJQUFJLEVBQUU7UUFFTDtRQUNBeEMsUUFBUSxFQUFFO01BSEwsQ0FERTtNQU1SeUMsS0FBSyxFQUFFO1FBRU47UUFDQWpELE9BQU8sRUFBRSxtQkFBVztVQUNuQixJQUFLLFNBQVM1QixpQkFBaUIsRUFBMUIsSUFBZ0MsS0FBSzZFLEtBQTFDLEVBQWtEO1lBQ2pELElBQUk7Y0FDSCxLQUFLQSxLQUFMO2NBQ0EsT0FBTyxLQUFQO1lBQ0EsQ0FIRCxDQUdFLE9BQVEzbEIsQ0FBUixFQUFZLENBRWI7Y0FDQTtjQUNBO1lBQ0E7VUFDRDtRQUNELENBZks7UUFnQk5paUIsWUFBWSxFQUFFO01BaEJSLENBTkM7TUF3QlIyRCxJQUFJLEVBQUU7UUFDTGxELE9BQU8sRUFBRSxtQkFBVztVQUNuQixJQUFLLFNBQVM1QixpQkFBaUIsRUFBMUIsSUFBZ0MsS0FBSzhFLElBQTFDLEVBQWlEO1lBQ2hELEtBQUtBLElBQUw7WUFDQSxPQUFPLEtBQVA7VUFDQTtRQUNELENBTkk7UUFPTDNELFlBQVksRUFBRTtNQVBULENBeEJFO01BaUNSNEQsS0FBSyxFQUFFO1FBRU47UUFDQW5ELE9BQU8sRUFBRSxtQkFBVztVQUNuQixJQUFLam5CLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUIsSUFBakIsRUFBdUIsT0FBdkIsS0FBb0MsS0FBS2pCLElBQUwsS0FBYyxVQUFsRCxJQUFnRSxLQUFLc21CLEtBQTFFLEVBQWtGO1lBQ2pGLEtBQUtBLEtBQUw7WUFDQSxPQUFPLEtBQVA7VUFDQTtRQUNELENBUks7UUFVTjtRQUNBaEgsUUFBUSxFQUFFLGtCQUFVakcsS0FBVixFQUFrQjtVQUMzQixPQUFPbmQsTUFBTSxDQUFDK0UsUUFBUCxDQUFpQm9ZLEtBQUssQ0FBQ3BhLE1BQXZCLEVBQStCLEdBQS9CLENBQVA7UUFDQTtNQWJLLENBakNDO01BaURSc25CLFlBQVksRUFBRTtRQUNiaEMsWUFBWSxFQUFFLHNCQUFVbEwsS0FBVixFQUFrQjtVQUUvQjtVQUNBO1VBQ0EsSUFBS0EsS0FBSyxDQUFDbE0sTUFBTixLQUFpQjdOLFNBQWpCLElBQThCK1osS0FBSyxDQUFDc0wsYUFBekMsRUFBeUQ7WUFDeER0TCxLQUFLLENBQUNzTCxhQUFOLENBQW9CNkIsV0FBcEIsR0FBa0NuTixLQUFLLENBQUNsTSxNQUF4QztVQUNBO1FBQ0Q7TUFSWTtJQWpETixDQW5qQks7SUFnbkJkO0lBQ0FzWixRQUFRLEVBQUUsa0JBQVV6bUIsSUFBVixFQUFnQmxDLElBQWhCLEVBQXNCdWIsS0FBdEIsRUFBOEI7TUFDdkMsSUFBSTVZLENBQUMsR0FBR3ZFLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FDUCxJQUFJeEMsTUFBTSxDQUFDc25CLEtBQVgsRUFETyxFQUVQbkssS0FGTyxFQUdQO1FBQ0NyWixJQUFJLEVBQUVBLElBRFA7UUFFQzBtQixXQUFXLEVBQUUsSUFGZCxDQUlDO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O01BWEQsQ0FITyxDQUFSO01Ba0JBeHFCLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYThKLE9BQWIsQ0FBc0IxaUIsQ0FBdEIsRUFBeUIsSUFBekIsRUFBK0IzQyxJQUEvQjs7TUFFQSxJQUFLMkMsQ0FBQyxDQUFDc2pCLGtCQUFGLEVBQUwsRUFBOEI7UUFDN0IxSyxLQUFLLENBQUN5SyxjQUFOO01BQ0E7SUFDRDtFQXpvQmEsQ0FBZjtFQTRvQkE1bkIsTUFBTSxDQUFDZ25CLFdBQVAsR0FBcUJob0IsUUFBUSxDQUFDZ2UsbUJBQVQsR0FDcEIsVUFBVXBiLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQnVpQixNQUF0QixFQUErQjtJQUU5QjtJQUNBLElBQUt6a0IsSUFBSSxDQUFDb2IsbUJBQVYsRUFBZ0M7TUFDL0JwYixJQUFJLENBQUNvYixtQkFBTCxDQUEwQmxaLElBQTFCLEVBQWdDdWlCLE1BQWhDO0lBQ0E7RUFDRCxDQVBtQixHQVFwQixVQUFVemtCLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQnVpQixNQUF0QixFQUErQjtJQUM5QixJQUFJempCLElBQUksR0FBRyxPQUFPa0IsSUFBbEI7O0lBRUEsSUFBS2xDLElBQUksQ0FBQ3NiLFdBQVYsRUFBd0I7TUFFdkI7TUFDQTtNQUNBO01BQ0EsSUFBSyxPQUFPdGIsSUFBSSxDQUFFZ0IsSUFBRixDQUFYLEtBQXdCLFdBQTdCLEVBQTJDO1FBQzFDaEIsSUFBSSxDQUFFZ0IsSUFBRixDQUFKLEdBQWUsSUFBZjtNQUNBOztNQUVEaEIsSUFBSSxDQUFDc2IsV0FBTCxDQUFrQnRhLElBQWxCLEVBQXdCeWpCLE1BQXhCO0lBQ0E7RUFDRCxDQXRCRjs7RUF3QkFybUIsTUFBTSxDQUFDc25CLEtBQVAsR0FBZSxVQUFVN2tCLEdBQVYsRUFBZXFtQixLQUFmLEVBQXVCO0lBRXJDO0lBQ0EsSUFBSyxFQUFHLGdCQUFnQjlvQixNQUFNLENBQUNzbkIsS0FBMUIsQ0FBTCxFQUF5QztNQUN4QyxPQUFPLElBQUl0bkIsTUFBTSxDQUFDc25CLEtBQVgsQ0FBa0I3a0IsR0FBbEIsRUFBdUJxbUIsS0FBdkIsQ0FBUDtJQUNBLENBTG9DLENBT3JDOzs7SUFDQSxJQUFLcm1CLEdBQUcsSUFBSUEsR0FBRyxDQUFDcUIsSUFBaEIsRUFBdUI7TUFDdEIsS0FBSzJrQixhQUFMLEdBQXFCaG1CLEdBQXJCO01BQ0EsS0FBS3FCLElBQUwsR0FBWXJCLEdBQUcsQ0FBQ3FCLElBQWhCLENBRnNCLENBSXRCO01BQ0E7O01BQ0EsS0FBSytqQixrQkFBTCxHQUEwQnBsQixHQUFHLENBQUNnb0IsZ0JBQUosSUFDeEJob0IsR0FBRyxDQUFDZ29CLGdCQUFKLEtBQXlCcm5CLFNBQXpCLElBRUE7TUFDQVgsR0FBRyxDQUFDNm5CLFdBQUosS0FBb0IsS0FKSSxHQUt6Qm5GLFVBTHlCLEdBTXpCQyxXQU5ELENBTnNCLENBY3ZCO0lBQ0MsQ0FmRCxNQWVPO01BQ04sS0FBS3RoQixJQUFMLEdBQVlyQixHQUFaO0lBQ0EsQ0F6Qm9DLENBMkJyQzs7O0lBQ0EsSUFBS3FtQixLQUFMLEVBQWE7TUFDWjlvQixNQUFNLENBQUN3QyxNQUFQLENBQWUsSUFBZixFQUFxQnNtQixLQUFyQjtJQUNBLENBOUJvQyxDQWdDckM7OztJQUNBLEtBQUs0QixTQUFMLEdBQWlCam9CLEdBQUcsSUFBSUEsR0FBRyxDQUFDaW9CLFNBQVgsSUFBd0IxcUIsTUFBTSxDQUFDcUcsR0FBUCxFQUF6QyxDQWpDcUMsQ0FtQ3JDOztJQUNBLEtBQU1yRyxNQUFNLENBQUNxRCxPQUFiLElBQXlCLElBQXpCO0VBQ0EsQ0FyQ0QsQ0F0Mks4RSxDQTY0SzlFO0VBQ0E7OztFQUNBckQsTUFBTSxDQUFDc25CLEtBQVAsQ0FBYTFtQixTQUFiLEdBQXlCO0lBQ3hCRSxXQUFXLEVBQUVkLE1BQU0sQ0FBQ3NuQixLQURJO0lBRXhCTyxrQkFBa0IsRUFBRXpDLFdBRkk7SUFHeEJ1QyxvQkFBb0IsRUFBRXZDLFdBSEU7SUFJeEIrQyw2QkFBNkIsRUFBRS9DLFdBSlA7SUFNeEJ3QyxjQUFjLEVBQUUsMEJBQVc7TUFDMUIsSUFBSXJqQixDQUFDLEdBQUcsS0FBS2trQixhQUFiO01BRUEsS0FBS1osa0JBQUwsR0FBMEIxQyxVQUExQjs7TUFDQSxJQUFLLENBQUM1Z0IsQ0FBTixFQUFVO1FBQ1Q7TUFDQSxDQU55QixDQVExQjs7O01BQ0EsSUFBS0EsQ0FBQyxDQUFDcWpCLGNBQVAsRUFBd0I7UUFDdkJyakIsQ0FBQyxDQUFDcWpCLGNBQUYsR0FEdUIsQ0FHeEI7UUFDQTtNQUNDLENBTEQsTUFLTztRQUNOcmpCLENBQUMsQ0FBQytsQixXQUFGLEdBQWdCLEtBQWhCO01BQ0E7SUFDRCxDQXZCdUI7SUF3QnhCbEMsZUFBZSxFQUFFLDJCQUFXO01BQzNCLElBQUk3akIsQ0FBQyxHQUFHLEtBQUtra0IsYUFBYjtNQUVBLEtBQUtkLG9CQUFMLEdBQTRCeEMsVUFBNUI7O01BRUEsSUFBSyxDQUFDNWdCLENBQUQsSUFBTSxLQUFLaW1CLFdBQWhCLEVBQThCO1FBQzdCO01BQ0EsQ0FQMEIsQ0FTM0I7OztNQUNBLElBQUtqbUIsQ0FBQyxDQUFDNmpCLGVBQVAsRUFBeUI7UUFDeEI3akIsQ0FBQyxDQUFDNmpCLGVBQUY7TUFDQSxDQVowQixDQWMzQjtNQUNBOzs7TUFDQTdqQixDQUFDLENBQUNvbUIsWUFBRixHQUFpQixJQUFqQjtJQUNBLENBekN1QjtJQTBDeEJDLHdCQUF3QixFQUFFLG9DQUFXO01BQ3BDLElBQUlybUIsQ0FBQyxHQUFHLEtBQUtra0IsYUFBYjtNQUVBLEtBQUtOLDZCQUFMLEdBQXFDaEQsVUFBckM7O01BRUEsSUFBSzVnQixDQUFDLElBQUlBLENBQUMsQ0FBQ3FtQix3QkFBWixFQUF1QztRQUN0Q3JtQixDQUFDLENBQUNxbUIsd0JBQUY7TUFDQTs7TUFFRCxLQUFLeEMsZUFBTDtJQUNBO0VBcER1QixDQUF6QixDQS80SzhFLENBczhLOUU7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUFDQXBvQixNQUFNLENBQUN5QixJQUFQLENBQWE7SUFDWm9wQixVQUFVLEVBQUUsV0FEQTtJQUVaQyxVQUFVLEVBQUUsVUFGQTtJQUdaQyxZQUFZLEVBQUUsYUFIRjtJQUlaQyxZQUFZLEVBQUU7RUFKRixDQUFiLEVBS0csVUFBVUMsSUFBVixFQUFnQm5ELEdBQWhCLEVBQXNCO0lBQ3hCOW5CLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJJLE9BQWIsQ0FBc0JtRixJQUF0QixJQUErQjtNQUM5QnpFLFlBQVksRUFBRXNCLEdBRGdCO01BRTlCckIsUUFBUSxFQUFFcUIsR0FGb0I7TUFJOUJ6QixNQUFNLEVBQUUsZ0JBQVVsSixLQUFWLEVBQWtCO1FBQ3pCLElBQUk3YixHQUFKO1FBQUEsSUFDQ3lCLE1BQU0sR0FBRyxJQURWO1FBQUEsSUFFQ21vQixPQUFPLEdBQUcvTixLQUFLLENBQUM0TSxhQUZqQjtRQUFBLElBR0MvRCxTQUFTLEdBQUc3SSxLQUFLLENBQUM2SSxTQUhuQixDQUR5QixDQU16QjtRQUNBOztRQUNBLElBQUssQ0FBQ2tGLE9BQUQsSUFBY0EsT0FBTyxLQUFLbm9CLE1BQVosSUFBc0IsQ0FBQy9DLE1BQU0sQ0FBQ3lILFFBQVAsQ0FBaUIxRSxNQUFqQixFQUF5Qm1vQixPQUF6QixDQUExQyxFQUFpRjtVQUNoRi9OLEtBQUssQ0FBQ3JaLElBQU4sR0FBYWtpQixTQUFTLENBQUNHLFFBQXZCO1VBQ0E3a0IsR0FBRyxHQUFHMGtCLFNBQVMsQ0FBQ3RaLE9BQVYsQ0FBa0I1SyxLQUFsQixDQUF5QixJQUF6QixFQUErQkMsU0FBL0IsQ0FBTjtVQUNBb2IsS0FBSyxDQUFDclosSUFBTixHQUFhZ2tCLEdBQWI7UUFDQTs7UUFDRCxPQUFPeG1CLEdBQVA7TUFDQTtJQWxCNkIsQ0FBL0I7RUFvQkEsQ0ExQkQsRUE5OEs4RSxDQTArSzlFOztFQUNBLElBQUssQ0FBQ3hCLE9BQU8sQ0FBQ3dULE1BQWQsRUFBdUI7SUFFdEJ0VCxNQUFNLENBQUNtZCxLQUFQLENBQWEySSxPQUFiLENBQXFCeFMsTUFBckIsR0FBOEI7TUFDN0JzVCxLQUFLLEVBQUUsaUJBQVc7UUFFakI7UUFDQSxJQUFLNW1CLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUIsSUFBakIsRUFBdUIsTUFBdkIsQ0FBTCxFQUF1QztVQUN0QyxPQUFPLEtBQVA7UUFDQSxDQUxnQixDQU9qQjs7O1FBQ0EvRSxNQUFNLENBQUNtZCxLQUFQLENBQWF2RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLGdDQUF4QixFQUEwRCxVQUFVclUsQ0FBVixFQUFjO1VBRXZFO1VBQ0EsSUFBSTNDLElBQUksR0FBRzJDLENBQUMsQ0FBQ3hCLE1BQWI7VUFBQSxJQUNDb29CLElBQUksR0FBR25yQixNQUFNLENBQUMrRSxRQUFQLENBQWlCbkQsSUFBakIsRUFBdUIsT0FBdkIsS0FBb0M1QixNQUFNLENBQUMrRSxRQUFQLENBQWlCbkQsSUFBakIsRUFBdUIsUUFBdkIsQ0FBcEMsR0FFTjtVQUNBO1VBQ0E7VUFDQTtVQUNBNUIsTUFBTSxDQUFDd2dCLElBQVAsQ0FBYTVlLElBQWIsRUFBbUIsTUFBbkIsQ0FOTSxHQU9Od0IsU0FSRjs7VUFVQSxJQUFLK25CLElBQUksSUFBSSxDQUFDbnJCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY2lNLElBQWQsRUFBb0IsUUFBcEIsQ0FBZCxFQUErQztZQUM5Q25yQixNQUFNLENBQUNtZCxLQUFQLENBQWF2RSxHQUFiLENBQWtCdVMsSUFBbEIsRUFBd0IsZ0JBQXhCLEVBQTBDLFVBQVVoTyxLQUFWLEVBQWtCO2NBQzNEQSxLQUFLLENBQUNpTyxhQUFOLEdBQXNCLElBQXRCO1lBQ0EsQ0FGRDs7WUFHQXByQixNQUFNLENBQUNrZixLQUFQLENBQWNpTSxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLElBQTlCO1VBQ0E7UUFDRCxDQW5CRCxFQVJpQixDQTZCakI7TUFDQSxDQS9CNEI7TUFpQzdCOUMsWUFBWSxFQUFFLHNCQUFVbEwsS0FBVixFQUFrQjtRQUUvQjtRQUNBLElBQUtBLEtBQUssQ0FBQ2lPLGFBQVgsRUFBMkI7VUFDMUIsT0FBT2pPLEtBQUssQ0FBQ2lPLGFBQWI7O1VBQ0EsSUFBSyxLQUFLemYsVUFBTCxJQUFtQixDQUFDd1IsS0FBSyxDQUFDb0ssU0FBL0IsRUFBMkM7WUFDMUN2bkIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhb04sUUFBYixDQUF1QixRQUF2QixFQUFpQyxLQUFLNWUsVUFBdEMsRUFBa0R3UixLQUFsRDtVQUNBO1FBQ0Q7TUFDRCxDQTFDNEI7TUE0QzdCNEosUUFBUSxFQUFFLG9CQUFXO1FBRXBCO1FBQ0EsSUFBSy9tQixNQUFNLENBQUMrRSxRQUFQLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLENBQUwsRUFBdUM7VUFDdEMsT0FBTyxLQUFQO1FBQ0EsQ0FMbUIsQ0FPcEI7OztRQUNBL0UsTUFBTSxDQUFDbWQsS0FBUCxDQUFhOUMsTUFBYixDQUFxQixJQUFyQixFQUEyQixVQUEzQjtNQUNBO0lBckQ0QixDQUE5QjtFQXVEQSxDQXBpTDZFLENBc2lMOUU7OztFQUNBLElBQUssQ0FBQ3ZhLE9BQU8sQ0FBQzhrQixNQUFkLEVBQXVCO0lBRXRCNWtCLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJJLE9BQWIsQ0FBcUJsQixNQUFyQixHQUE4QjtNQUU3QmdDLEtBQUssRUFBRSxpQkFBVztRQUVqQixJQUFLOUIsVUFBVSxDQUFDelosSUFBWCxDQUFpQixLQUFLdEcsUUFBdEIsQ0FBTCxFQUF3QztVQUV2QztVQUNBO1VBQ0E7VUFDQSxJQUFLLEtBQUtqQixJQUFMLEtBQWMsVUFBZCxJQUE0QixLQUFLQSxJQUFMLEtBQWMsT0FBL0MsRUFBeUQ7WUFDeEQ5RCxNQUFNLENBQUNtZCxLQUFQLENBQWF2RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLHdCQUF4QixFQUFrRCxVQUFVdUUsS0FBVixFQUFrQjtjQUNuRSxJQUFLQSxLQUFLLENBQUNzTCxhQUFOLENBQW9CNEMsWUFBcEIsS0FBcUMsU0FBMUMsRUFBc0Q7Z0JBQ3JELEtBQUtDLFlBQUwsR0FBb0IsSUFBcEI7Y0FDQTtZQUNELENBSkQ7WUFLQXRyQixNQUFNLENBQUNtZCxLQUFQLENBQWF2RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLGVBQXhCLEVBQXlDLFVBQVV1RSxLQUFWLEVBQWtCO2NBQzFELElBQUssS0FBS21PLFlBQUwsSUFBcUIsQ0FBQ25PLEtBQUssQ0FBQ29LLFNBQWpDLEVBQTZDO2dCQUM1QyxLQUFLK0QsWUFBTCxHQUFvQixLQUFwQjtjQUNBLENBSHlELENBSzFEOzs7Y0FDQXRyQixNQUFNLENBQUNtZCxLQUFQLENBQWFvTixRQUFiLENBQXVCLFFBQXZCLEVBQWlDLElBQWpDLEVBQXVDcE4sS0FBdkM7WUFDQSxDQVBEO1VBUUE7O1VBQ0QsT0FBTyxLQUFQO1FBQ0EsQ0F2QmdCLENBeUJqQjs7O1FBQ0FuZCxNQUFNLENBQUNtZCxLQUFQLENBQWF2RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLHdCQUF4QixFQUFrRCxVQUFVclUsQ0FBVixFQUFjO1VBQy9ELElBQUkzQyxJQUFJLEdBQUcyQyxDQUFDLENBQUN4QixNQUFiOztVQUVBLElBQUsraEIsVUFBVSxDQUFDelosSUFBWCxDQUFpQnpKLElBQUksQ0FBQ21ELFFBQXRCLEtBQW9DLENBQUMvRSxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9CLFFBQXBCLENBQTFDLEVBQTJFO1lBQzFFNUIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhdkUsR0FBYixDQUFrQmhYLElBQWxCLEVBQXdCLGdCQUF4QixFQUEwQyxVQUFVdWIsS0FBVixFQUFrQjtjQUMzRCxJQUFLLEtBQUt4UixVQUFMLElBQW1CLENBQUN3UixLQUFLLENBQUNxTixXQUExQixJQUF5QyxDQUFDck4sS0FBSyxDQUFDb0ssU0FBckQsRUFBaUU7Z0JBQ2hFdm5CLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYW9OLFFBQWIsQ0FBdUIsUUFBdkIsRUFBaUMsS0FBSzVlLFVBQXRDLEVBQWtEd1IsS0FBbEQ7Y0FDQTtZQUNELENBSkQ7O1lBS0FuZCxNQUFNLENBQUNrZixLQUFQLENBQWN0ZCxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLElBQTlCO1VBQ0E7UUFDRCxDQVhEO01BWUEsQ0F4QzRCO01BMEM3QnlrQixNQUFNLEVBQUUsZ0JBQVVsSixLQUFWLEVBQWtCO1FBQ3pCLElBQUl2YixJQUFJLEdBQUd1YixLQUFLLENBQUNwYSxNQUFqQixDQUR5QixDQUd6Qjs7UUFDQSxJQUFLLFNBQVNuQixJQUFULElBQWlCdWIsS0FBSyxDQUFDcU4sV0FBdkIsSUFBc0NyTixLQUFLLENBQUNvSyxTQUE1QyxJQUNGM2xCLElBQUksQ0FBQ2tDLElBQUwsS0FBYyxPQUFkLElBQXlCbEMsSUFBSSxDQUFDa0MsSUFBTCxLQUFjLFVBRDFDLEVBQ3lEO1VBRXhELE9BQU9xWixLQUFLLENBQUM2SSxTQUFOLENBQWdCdFosT0FBaEIsQ0FBd0I1SyxLQUF4QixDQUErQixJQUEvQixFQUFxQ0MsU0FBckMsQ0FBUDtRQUNBO01BQ0QsQ0FuRDRCO01BcUQ3QmdsQixRQUFRLEVBQUUsb0JBQVc7UUFDcEIvbUIsTUFBTSxDQUFDbWQsS0FBUCxDQUFhOUMsTUFBYixDQUFxQixJQUFyQixFQUEyQixVQUEzQjtRQUVBLE9BQU8sQ0FBQ3lLLFVBQVUsQ0FBQ3paLElBQVgsQ0FBaUIsS0FBS3RHLFFBQXRCLENBQVI7TUFDQTtJQXpENEIsQ0FBOUI7RUEyREEsQ0FwbUw2RSxDQXNtTDlFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztFQUNBLElBQUssQ0FBQ2pGLE9BQU8sQ0FBQytrQixPQUFkLEVBQXdCO0lBQ3ZCN2tCLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYTtNQUFFeW9CLEtBQUssRUFBRSxTQUFUO01BQW9CQyxJQUFJLEVBQUU7SUFBMUIsQ0FBYixFQUFxRCxVQUFVYyxJQUFWLEVBQWdCbkQsR0FBaEIsRUFBc0I7TUFFMUU7TUFDQSxJQUFJcGIsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVXlRLEtBQVYsRUFBa0I7UUFDL0JuZCxNQUFNLENBQUNtZCxLQUFQLENBQWFvTixRQUFiLENBQXVCekMsR0FBdkIsRUFBNEIzSyxLQUFLLENBQUNwYSxNQUFsQyxFQUEwQy9DLE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTJLLEdBQWIsQ0FBa0IzSyxLQUFsQixDQUExQztNQUNBLENBRkQ7O01BSUFuZCxNQUFNLENBQUNtZCxLQUFQLENBQWEySSxPQUFiLENBQXNCZ0MsR0FBdEIsSUFBOEI7UUFDN0JsQixLQUFLLEVBQUUsaUJBQVc7VUFDakIsSUFBSWxaLEdBQUcsR0FBRyxLQUFLNUMsYUFBTCxJQUFzQixJQUFoQztVQUFBLElBQ0N5Z0IsUUFBUSxHQUFHdnJCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3hSLEdBQWQsRUFBbUJvYSxHQUFuQixDQURaOztVQUdBLElBQUssQ0FBQ3lELFFBQU4sRUFBaUI7WUFDaEI3ZCxHQUFHLENBQUNHLGdCQUFKLENBQXNCb2QsSUFBdEIsRUFBNEJ2ZSxPQUE1QixFQUFxQyxJQUFyQztVQUNBOztVQUNEMU0sTUFBTSxDQUFDa2YsS0FBUCxDQUFjeFIsR0FBZCxFQUFtQm9hLEdBQW5CLEVBQXdCLENBQUV5RCxRQUFRLElBQUksQ0FBZCxJQUFvQixDQUE1QztRQUNBLENBVDRCO1FBVTdCeEUsUUFBUSxFQUFFLG9CQUFXO1VBQ3BCLElBQUlyWixHQUFHLEdBQUcsS0FBSzVDLGFBQUwsSUFBc0IsSUFBaEM7VUFBQSxJQUNDeWdCLFFBQVEsR0FBR3ZyQixNQUFNLENBQUNrZixLQUFQLENBQWN4UixHQUFkLEVBQW1Cb2EsR0FBbkIsSUFBMkIsQ0FEdkM7O1VBR0EsSUFBSyxDQUFDeUQsUUFBTixFQUFpQjtZQUNoQjdkLEdBQUcsQ0FBQ3NQLG1CQUFKLENBQXlCaU8sSUFBekIsRUFBK0J2ZSxPQUEvQixFQUF3QyxJQUF4Qzs7WUFDQTFNLE1BQU0sQ0FBQ21mLFdBQVAsQ0FBb0J6UixHQUFwQixFQUF5Qm9hLEdBQXpCO1VBQ0EsQ0FIRCxNQUdPO1lBQ045bkIsTUFBTSxDQUFDa2YsS0FBUCxDQUFjeFIsR0FBZCxFQUFtQm9hLEdBQW5CLEVBQXdCeUQsUUFBeEI7VUFDQTtRQUNEO01BcEI0QixDQUE5QjtJQXNCQSxDQTdCRDtFQThCQTs7RUFFRHZyQixNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFFakIraUIsRUFBRSxFQUFFLFlBQVVDLEtBQVYsRUFBaUJ2bEIsUUFBakIsRUFBMkJ5RSxJQUEzQixFQUFpQ3ZFLEVBQWpDLEVBQXNDO01BQ3pDLE9BQU9vbEIsR0FBRSxDQUFFLElBQUYsRUFBUUMsS0FBUixFQUFldmxCLFFBQWYsRUFBeUJ5RSxJQUF6QixFQUErQnZFLEVBQS9CLENBQVQ7SUFDQSxDQUpnQjtJQUtqQnNsQixHQUFHLEVBQUUsYUFBVUQsS0FBVixFQUFpQnZsQixRQUFqQixFQUEyQnlFLElBQTNCLEVBQWlDdkUsRUFBakMsRUFBc0M7TUFDMUMsT0FBT29sQixHQUFFLENBQUUsSUFBRixFQUFRQyxLQUFSLEVBQWV2bEIsUUFBZixFQUF5QnlFLElBQXpCLEVBQStCdkUsRUFBL0IsRUFBbUMsQ0FBbkMsQ0FBVDtJQUNBLENBUGdCO0lBUWpCMmMsR0FBRyxFQUFFLGFBQVUwSSxLQUFWLEVBQWlCdmxCLFFBQWpCLEVBQTJCRSxFQUEzQixFQUFnQztNQUNwQyxJQUFJNmxCLFNBQUosRUFBZWxpQixJQUFmOztNQUNBLElBQUswaEIsS0FBSyxJQUFJQSxLQUFLLENBQUNvQyxjQUFmLElBQWlDcEMsS0FBSyxDQUFDUSxTQUE1QyxFQUF3RDtRQUV2RDtRQUNBQSxTQUFTLEdBQUdSLEtBQUssQ0FBQ1EsU0FBbEI7UUFDQWhtQixNQUFNLENBQUV3bEIsS0FBSyxDQUFDd0MsY0FBUixDQUFOLENBQStCbEwsR0FBL0IsQ0FDQ2tKLFNBQVMsQ0FBQ1UsU0FBVixHQUNDVixTQUFTLENBQUNHLFFBQVYsR0FBcUIsR0FBckIsR0FBMkJILFNBQVMsQ0FBQ1UsU0FEdEMsR0FFQ1YsU0FBUyxDQUFDRyxRQUhaLEVBSUNILFNBQVMsQ0FBQy9sQixRQUpYLEVBS0MrbEIsU0FBUyxDQUFDdFosT0FMWDtRQU9BLE9BQU8sSUFBUDtNQUNBOztNQUNELElBQUssUUFBTzhZLEtBQVAsTUFBaUIsUUFBdEIsRUFBaUM7UUFFaEM7UUFDQSxLQUFNMWhCLElBQU4sSUFBYzBoQixLQUFkLEVBQXNCO1VBQ3JCLEtBQUsxSSxHQUFMLENBQVVoWixJQUFWLEVBQWdCN0QsUUFBaEIsRUFBMEJ1bEIsS0FBSyxDQUFFMWhCLElBQUYsQ0FBL0I7UUFDQTs7UUFDRCxPQUFPLElBQVA7TUFDQTs7TUFDRCxJQUFLN0QsUUFBUSxLQUFLLEtBQWIsSUFBc0IsT0FBT0EsUUFBUCxLQUFvQixVQUEvQyxFQUE0RDtRQUUzRDtRQUNBRSxFQUFFLEdBQUdGLFFBQUw7UUFDQUEsUUFBUSxHQUFHbUQsU0FBWDtNQUNBOztNQUNELElBQUtqRCxFQUFFLEtBQUssS0FBWixFQUFvQjtRQUNuQkEsRUFBRSxHQUFHaWxCLFdBQUw7TUFDQTs7TUFDRCxPQUFPLEtBQUszakIsSUFBTCxDQUFXLFlBQVc7UUFDNUJ6QixNQUFNLENBQUNtZCxLQUFQLENBQWE5QyxNQUFiLENBQXFCLElBQXJCLEVBQTJCbUwsS0FBM0IsRUFBa0NybEIsRUFBbEMsRUFBc0NGLFFBQXRDO01BQ0EsQ0FGTSxDQUFQO0lBR0EsQ0EzQ2dCO0lBNkNqQmduQixPQUFPLEVBQUUsaUJBQVVuakIsSUFBVixFQUFnQlksSUFBaEIsRUFBdUI7TUFDL0IsT0FBTyxLQUFLakQsSUFBTCxDQUFXLFlBQVc7UUFDNUJ6QixNQUFNLENBQUNtZCxLQUFQLENBQWE4SixPQUFiLENBQXNCbmpCLElBQXRCLEVBQTRCWSxJQUE1QixFQUFrQyxJQUFsQztNQUNBLENBRk0sQ0FBUDtJQUdBLENBakRnQjtJQWtEakJtWSxjQUFjLEVBQUUsd0JBQVUvWSxJQUFWLEVBQWdCWSxJQUFoQixFQUF1QjtNQUN0QyxJQUFJOUMsSUFBSSxHQUFHLEtBQU0sQ0FBTixDQUFYOztNQUNBLElBQUtBLElBQUwsRUFBWTtRQUNYLE9BQU81QixNQUFNLENBQUNtZCxLQUFQLENBQWE4SixPQUFiLENBQXNCbmpCLElBQXRCLEVBQTRCWSxJQUE1QixFQUFrQzlDLElBQWxDLEVBQXdDLElBQXhDLENBQVA7TUFDQTtJQUNEO0VBdkRnQixDQUFsQjtFQTJEQSxJQUFJNHBCLGFBQWEsR0FBRyw0QkFBcEI7RUFBQSxJQUNDQyxZQUFZLEdBQUcsSUFBSTNpQixNQUFKLENBQVksU0FBUzhZLFNBQVQsR0FBcUIsVUFBakMsRUFBNkMsR0FBN0MsQ0FEaEI7RUFBQSxJQUVDOEosU0FBUyxHQUFHLDBFQUZiO0VBQUEsSUFJQztFQUNBO0VBQ0E7RUFDQUMsWUFBWSxHQUFHLHVCQVBoQjtFQUFBLElBU0M7RUFDQUMsUUFBUSxHQUFHLG1DQVZaO0VBQUEsSUFXQ0MsaUJBQWlCLEdBQUcsYUFYckI7RUFBQSxJQVlDQyxZQUFZLEdBQUcsMENBWmhCO0VBQUEsSUFhQ0MsWUFBWSxHQUFHbEssa0JBQWtCLENBQUU3aUIsUUFBRixDQWJsQztFQUFBLElBY0NndEIsV0FBVyxHQUFHRCxZQUFZLENBQUMvZCxXQUFiLENBQTBCaFAsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQUExQixDQWRmLENBMXNMOEUsQ0EwdEw5RTtFQUNBOztFQUNBLFNBQVMyZixrQkFBVCxDQUE2QnJxQixJQUE3QixFQUFtQ3NxQixPQUFuQyxFQUE2QztJQUM1QyxPQUFPbHNCLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJuRCxJQUFqQixFQUF1QixPQUF2QixLQUNONUIsTUFBTSxDQUFDK0UsUUFBUCxDQUFpQm1uQixPQUFPLENBQUM1bkIsUUFBUixLQUFxQixFQUFyQixHQUEwQjRuQixPQUExQixHQUFvQ0EsT0FBTyxDQUFDOWIsVUFBN0QsRUFBeUUsSUFBekUsQ0FETSxHQUdOeE8sSUFBSSxDQUFDc0osb0JBQUwsQ0FBMkIsT0FBM0IsRUFBc0MsQ0FBdEMsS0FDQ3RKLElBQUksQ0FBQ29NLFdBQUwsQ0FBa0JwTSxJQUFJLENBQUNrSixhQUFMLENBQW1Cd0IsYUFBbkIsQ0FBa0MsT0FBbEMsQ0FBbEIsQ0FKSyxHQUtOMUssSUFMRDtFQU1BLENBbnVMNkUsQ0FxdUw5RTs7O0VBQ0EsU0FBU3VxQixhQUFULENBQXdCdnFCLElBQXhCLEVBQStCO0lBQzlCQSxJQUFJLENBQUNrQyxJQUFMLEdBQVksQ0FBRTlELE1BQU0sQ0FBQ29PLElBQVAsQ0FBWXdCLElBQVosQ0FBa0JoTyxJQUFsQixFQUF3QixNQUF4QixNQUFxQyxJQUF2QyxJQUFnRCxHQUFoRCxHQUFzREEsSUFBSSxDQUFDa0MsSUFBdkU7SUFDQSxPQUFPbEMsSUFBUDtFQUNBOztFQUNELFNBQVN3cUIsYUFBVCxDQUF3QnhxQixJQUF4QixFQUErQjtJQUM5QixJQUFJOEksS0FBSyxHQUFHbWhCLGlCQUFpQixDQUFDOWdCLElBQWxCLENBQXdCbkosSUFBSSxDQUFDa0MsSUFBN0IsQ0FBWjs7SUFDQSxJQUFLNEcsS0FBTCxFQUFhO01BQ1o5SSxJQUFJLENBQUNrQyxJQUFMLEdBQVk0RyxLQUFLLENBQUUsQ0FBRixDQUFqQjtJQUNBLENBRkQsTUFFTztNQUNOOUksSUFBSSxDQUFDa0ssZUFBTCxDQUFzQixNQUF0QjtJQUNBOztJQUNELE9BQU9sSyxJQUFQO0VBQ0E7O0VBRUQsU0FBU3lxQixjQUFULENBQXlCNXBCLEdBQXpCLEVBQThCNnBCLElBQTlCLEVBQXFDO0lBQ3BDLElBQUtBLElBQUksQ0FBQ2hvQixRQUFMLEtBQWtCLENBQWxCLElBQXVCLENBQUN0RSxNQUFNLENBQUNnZixPQUFQLENBQWdCdmMsR0FBaEIsQ0FBN0IsRUFBcUQ7TUFDcEQ7SUFDQTs7SUFFRCxJQUFJcUIsSUFBSjtJQUFBLElBQVVqQyxDQUFWO0lBQUEsSUFBYTJXLENBQWI7SUFBQSxJQUNDK1QsT0FBTyxHQUFHdnNCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3pjLEdBQWQsQ0FEWDtJQUFBLElBRUMrcEIsT0FBTyxHQUFHeHNCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY29OLElBQWQsRUFBb0JDLE9BQXBCLENBRlg7SUFBQSxJQUdDNUcsTUFBTSxHQUFHNEcsT0FBTyxDQUFDNUcsTUFIbEI7O0lBS0EsSUFBS0EsTUFBTCxFQUFjO01BQ2IsT0FBTzZHLE9BQU8sQ0FBQ25HLE1BQWY7TUFDQW1HLE9BQU8sQ0FBQzdHLE1BQVIsR0FBaUIsRUFBakI7O01BRUEsS0FBTTdoQixJQUFOLElBQWM2aEIsTUFBZCxFQUF1QjtRQUN0QixLQUFNOWpCLENBQUMsR0FBRyxDQUFKLEVBQU8yVyxDQUFDLEdBQUdtTixNQUFNLENBQUU3aEIsSUFBRixDQUFOLENBQWUvQyxNQUFoQyxFQUF3Q2MsQ0FBQyxHQUFHMlcsQ0FBNUMsRUFBK0MzVyxDQUFDLEVBQWhELEVBQXFEO1VBQ3BEN0IsTUFBTSxDQUFDbWQsS0FBUCxDQUFhdkUsR0FBYixDQUFrQjBULElBQWxCLEVBQXdCeG9CLElBQXhCLEVBQThCNmhCLE1BQU0sQ0FBRTdoQixJQUFGLENBQU4sQ0FBZ0JqQyxDQUFoQixDQUE5QjtRQUNBO01BQ0Q7SUFDRCxDQW5CbUMsQ0FxQnBDOzs7SUFDQSxJQUFLMnFCLE9BQU8sQ0FBQzluQixJQUFiLEVBQW9CO01BQ25COG5CLE9BQU8sQ0FBQzluQixJQUFSLEdBQWUxRSxNQUFNLENBQUN3QyxNQUFQLENBQWUsRUFBZixFQUFtQmdxQixPQUFPLENBQUM5bkIsSUFBM0IsQ0FBZjtJQUNBO0VBQ0Q7O0VBRUQsU0FBUytuQixrQkFBVCxDQUE2QmhxQixHQUE3QixFQUFrQzZwQixJQUFsQyxFQUF5QztJQUN4QyxJQUFJdm5CLFFBQUosRUFBY1IsQ0FBZCxFQUFpQkcsSUFBakIsQ0FEd0MsQ0FHeEM7O0lBQ0EsSUFBSzRuQixJQUFJLENBQUNob0IsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtNQUMxQjtJQUNBOztJQUVEUyxRQUFRLEdBQUd1bkIsSUFBSSxDQUFDdm5CLFFBQUwsQ0FBY0MsV0FBZCxFQUFYLENBUndDLENBVXhDOztJQUNBLElBQUssQ0FBQ2xGLE9BQU8sQ0FBQzRpQixZQUFULElBQXlCNEosSUFBSSxDQUFFdHNCLE1BQU0sQ0FBQ3FELE9BQVQsQ0FBbEMsRUFBdUQ7TUFDdERxQixJQUFJLEdBQUcxRSxNQUFNLENBQUNrZixLQUFQLENBQWNvTixJQUFkLENBQVA7O01BRUEsS0FBTS9uQixDQUFOLElBQVdHLElBQUksQ0FBQ2loQixNQUFoQixFQUF5QjtRQUN4QjNsQixNQUFNLENBQUNnbkIsV0FBUCxDQUFvQnNGLElBQXBCLEVBQTBCL25CLENBQTFCLEVBQTZCRyxJQUFJLENBQUMyaEIsTUFBbEM7TUFDQSxDQUxxRCxDQU90RDs7O01BQ0FpRyxJQUFJLENBQUN4Z0IsZUFBTCxDQUFzQjlMLE1BQU0sQ0FBQ3FELE9BQTdCO0lBQ0EsQ0FwQnVDLENBc0J4Qzs7O0lBQ0EsSUFBSzBCLFFBQVEsS0FBSyxRQUFiLElBQXlCdW5CLElBQUksQ0FBQ3BuQixJQUFMLEtBQWN6QyxHQUFHLENBQUN5QyxJQUFoRCxFQUF1RDtNQUN0RGluQixhQUFhLENBQUVHLElBQUYsQ0FBYixDQUFzQnBuQixJQUF0QixHQUE2QnpDLEdBQUcsQ0FBQ3lDLElBQWpDO01BQ0FrbkIsYUFBYSxDQUFFRSxJQUFGLENBQWIsQ0FGc0QsQ0FJdkQ7TUFDQTtJQUNDLENBTkQsTUFNTyxJQUFLdm5CLFFBQVEsS0FBSyxRQUFsQixFQUE2QjtNQUNuQyxJQUFLdW5CLElBQUksQ0FBQzNnQixVQUFWLEVBQXVCO1FBQ3RCMmdCLElBQUksQ0FBQ2hLLFNBQUwsR0FBaUI3ZixHQUFHLENBQUM2ZixTQUFyQjtNQUNBLENBSGtDLENBS25DO01BQ0E7TUFDQTtNQUNBOzs7TUFDQSxJQUFLeGlCLE9BQU8sQ0FBQ3NpQixVQUFSLElBQXdCM2YsR0FBRyxDQUFDZ00sU0FBSixJQUFpQixDQUFDek8sTUFBTSxDQUFDMkUsSUFBUCxDQUFhMm5CLElBQUksQ0FBQzdkLFNBQWxCLENBQS9DLEVBQWlGO1FBQ2hGNmQsSUFBSSxDQUFDN2QsU0FBTCxHQUFpQmhNLEdBQUcsQ0FBQ2dNLFNBQXJCO01BQ0E7SUFFRCxDQWJNLE1BYUEsSUFBSzFKLFFBQVEsS0FBSyxPQUFiLElBQXdCeWMsY0FBYyxDQUFDblcsSUFBZixDQUFxQjVJLEdBQUcsQ0FBQ3FCLElBQXpCLENBQTdCLEVBQStEO01BRXJFO01BQ0E7TUFDQTtNQUVBd29CLElBQUksQ0FBQ3JJLGNBQUwsR0FBc0JxSSxJQUFJLENBQUN4WixPQUFMLEdBQWVyUSxHQUFHLENBQUNxUSxPQUF6QyxDQU5xRSxDQVFyRTtNQUNBOztNQUNBLElBQUt3WixJQUFJLENBQUN0bUIsS0FBTCxLQUFldkQsR0FBRyxDQUFDdUQsS0FBeEIsRUFBZ0M7UUFDL0JzbUIsSUFBSSxDQUFDdG1CLEtBQUwsR0FBYXZELEdBQUcsQ0FBQ3VELEtBQWpCO01BQ0EsQ0Fab0UsQ0FjdEU7TUFDQTs7SUFDQyxDQWhCTSxNQWdCQSxJQUFLakIsUUFBUSxLQUFLLFFBQWxCLEVBQTZCO01BQ25DdW5CLElBQUksQ0FBQ0ksZUFBTCxHQUF1QkosSUFBSSxDQUFDdlosUUFBTCxHQUFnQnRRLEdBQUcsQ0FBQ2lxQixlQUEzQyxDQURtQyxDQUdwQztNQUNBO0lBQ0MsQ0FMTSxNQUtBLElBQUszbkIsUUFBUSxLQUFLLE9BQWIsSUFBd0JBLFFBQVEsS0FBSyxVQUExQyxFQUF1RDtNQUM3RHVuQixJQUFJLENBQUM1VixZQUFMLEdBQW9CalUsR0FBRyxDQUFDaVUsWUFBeEI7SUFDQTtFQUNEOztFQUVELFNBQVNpVyxRQUFULENBQW1CQyxVQUFuQixFQUErQnptQixJQUEvQixFQUFxQ3pFLFFBQXJDLEVBQStDMmlCLE9BQS9DLEVBQXlEO0lBRXhEO0lBQ0FsZSxJQUFJLEdBQUc1RyxNQUFNLENBQUN1QyxLQUFQLENBQWMsRUFBZCxFQUFrQnFFLElBQWxCLENBQVA7SUFFQSxJQUFJbkUsS0FBSjtJQUFBLElBQVd1TCxJQUFYO0lBQUEsSUFBaUJzZixVQUFqQjtJQUFBLElBQ0MxSSxPQUREO0lBQUEsSUFDVXpXLEdBRFY7SUFBQSxJQUNlc1UsUUFEZjtJQUFBLElBRUNuZ0IsQ0FBQyxHQUFHLENBRkw7SUFBQSxJQUdDMlcsQ0FBQyxHQUFHb1UsVUFBVSxDQUFDN3JCLE1BSGhCO0lBQUEsSUFJQytyQixRQUFRLEdBQUd0VSxDQUFDLEdBQUcsQ0FKaEI7SUFBQSxJQUtDeFMsS0FBSyxHQUFHRyxJQUFJLENBQUUsQ0FBRixDQUxiO0lBQUEsSUFNQ2xELFVBQVUsR0FBR2pELE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUIrQyxLQUFuQixDQU5kLENBTHdELENBYXhEOztJQUNBLElBQUsvQyxVQUFVLElBQ1h1VixDQUFDLEdBQUcsQ0FBSixJQUFTLE9BQU94UyxLQUFQLEtBQWlCLFFBQTFCLElBQ0QsQ0FBQ2xHLE9BQU8sQ0FBQzJpQixVQURSLElBQ3NCbUosUUFBUSxDQUFDdmdCLElBQVQsQ0FBZXJGLEtBQWYsQ0FGMUIsRUFFcUQ7TUFDcEQsT0FBTzRtQixVQUFVLENBQUNuckIsSUFBWCxDQUFpQixVQUFVaVgsS0FBVixFQUFrQjtRQUN6QyxJQUFJakIsSUFBSSxHQUFHbVYsVUFBVSxDQUFDM3FCLEVBQVgsQ0FBZXlXLEtBQWYsQ0FBWDs7UUFDQSxJQUFLelYsVUFBTCxFQUFrQjtVQUNqQmtELElBQUksQ0FBRSxDQUFGLENBQUosR0FBWUgsS0FBSyxDQUFDL0UsSUFBTixDQUFZLElBQVosRUFBa0J5WCxLQUFsQixFQUF5QmpCLElBQUksQ0FBQ3NWLElBQUwsRUFBekIsQ0FBWjtRQUNBOztRQUNESixRQUFRLENBQUVsVixJQUFGLEVBQVF0UixJQUFSLEVBQWN6RSxRQUFkLEVBQXdCMmlCLE9BQXhCLENBQVI7TUFDQSxDQU5NLENBQVA7SUFPQTs7SUFFRCxJQUFLN0wsQ0FBTCxFQUFTO01BQ1J3SixRQUFRLEdBQUdrQyxhQUFhLENBQUUvZCxJQUFGLEVBQVF5bUIsVUFBVSxDQUFFLENBQUYsQ0FBVixDQUFnQjloQixhQUF4QixFQUF1QyxLQUF2QyxFQUE4QzhoQixVQUE5QyxFQUEwRHZJLE9BQTFELENBQXhCO01BQ0FyaUIsS0FBSyxHQUFHZ2dCLFFBQVEsQ0FBQzVSLFVBQWpCOztNQUVBLElBQUs0UixRQUFRLENBQUM1WCxVQUFULENBQW9CckosTUFBcEIsS0FBK0IsQ0FBcEMsRUFBd0M7UUFDdkNpaEIsUUFBUSxHQUFHaGdCLEtBQVg7TUFDQSxDQU5PLENBUVI7OztNQUNBLElBQUtBLEtBQUssSUFBSXFpQixPQUFkLEVBQXdCO1FBQ3ZCRixPQUFPLEdBQUdua0IsTUFBTSxDQUFDMkIsR0FBUCxDQUFZK2hCLE1BQU0sQ0FBRTFCLFFBQUYsRUFBWSxRQUFaLENBQWxCLEVBQTBDbUssYUFBMUMsQ0FBVjtRQUNBVSxVQUFVLEdBQUcxSSxPQUFPLENBQUNwakIsTUFBckIsQ0FGdUIsQ0FJdkI7UUFDQTtRQUNBOztRQUNBLE9BQVFjLENBQUMsR0FBRzJXLENBQVosRUFBZTNXLENBQUMsRUFBaEIsRUFBcUI7VUFDcEIwTCxJQUFJLEdBQUd5VSxRQUFQOztVQUVBLElBQUtuZ0IsQ0FBQyxLQUFLaXJCLFFBQVgsRUFBc0I7WUFDckJ2ZixJQUFJLEdBQUd2TixNQUFNLENBQUM4QyxLQUFQLENBQWN5SyxJQUFkLEVBQW9CLElBQXBCLEVBQTBCLElBQTFCLENBQVAsQ0FEcUIsQ0FHckI7O1lBQ0EsSUFBS3NmLFVBQUwsRUFBa0I7Y0FFakI7Y0FDQTtjQUNBN3NCLE1BQU0sQ0FBQ3VCLEtBQVAsQ0FBYzRpQixPQUFkLEVBQXVCVCxNQUFNLENBQUVuVyxJQUFGLEVBQVEsUUFBUixDQUE3QjtZQUNBO1VBQ0Q7O1VBRUQ3TCxRQUFRLENBQUNULElBQVQsQ0FBZTJyQixVQUFVLENBQUUvcUIsQ0FBRixDQUF6QixFQUFnQzBMLElBQWhDLEVBQXNDMUwsQ0FBdEM7UUFDQTs7UUFFRCxJQUFLZ3JCLFVBQUwsRUFBa0I7VUFDakJuZixHQUFHLEdBQUd5VyxPQUFPLENBQUVBLE9BQU8sQ0FBQ3BqQixNQUFSLEdBQWlCLENBQW5CLENBQVAsQ0FBOEIrSixhQUFwQyxDQURpQixDQUdqQjs7VUFDQTlLLE1BQU0sQ0FBQzJCLEdBQVAsQ0FBWXdpQixPQUFaLEVBQXFCaUksYUFBckIsRUFKaUIsQ0FNakI7O1VBQ0EsS0FBTXZxQixDQUFDLEdBQUcsQ0FBVixFQUFhQSxDQUFDLEdBQUdnckIsVUFBakIsRUFBNkJockIsQ0FBQyxFQUE5QixFQUFtQztZQUNsQzBMLElBQUksR0FBRzRXLE9BQU8sQ0FBRXRpQixDQUFGLENBQWQ7O1lBQ0EsSUFBSzZmLFdBQVcsQ0FBQ3JXLElBQVosQ0FBa0JrQyxJQUFJLENBQUN6SixJQUFMLElBQWEsRUFBL0IsS0FDSixDQUFDOUQsTUFBTSxDQUFDa2YsS0FBUCxDQUFjM1IsSUFBZCxFQUFvQixZQUFwQixDQURHLElBRUp2TixNQUFNLENBQUN5SCxRQUFQLENBQWlCaUcsR0FBakIsRUFBc0JILElBQXRCLENBRkQsRUFFZ0M7Y0FFL0IsSUFBS0EsSUFBSSxDQUFDOUssR0FBVixFQUFnQjtnQkFFZjtnQkFDQSxJQUFLekMsTUFBTSxDQUFDZ3RCLFFBQVosRUFBdUI7a0JBQ3RCaHRCLE1BQU0sQ0FBQ2d0QixRQUFQLENBQWlCemYsSUFBSSxDQUFDOUssR0FBdEI7Z0JBQ0E7Y0FDRCxDQU5ELE1BTU87Z0JBQ056QyxNQUFNLENBQUN5RSxVQUFQLENBQ0MsQ0FBRThJLElBQUksQ0FBQ3JJLElBQUwsSUFBYXFJLElBQUksQ0FBQzRDLFdBQWxCLElBQWlDNUMsSUFBSSxDQUFDa0IsU0FBdEMsSUFBbUQsRUFBckQsRUFDRWpMLE9BREYsQ0FDV3NvQixZQURYLEVBQ3lCLEVBRHpCLENBREQ7Y0FJQTtZQUNEO1VBQ0Q7UUFDRCxDQXBEc0IsQ0FzRHZCOzs7UUFDQTlKLFFBQVEsR0FBR2hnQixLQUFLLEdBQUcsSUFBbkI7TUFDQTtJQUNEOztJQUVELE9BQU80cUIsVUFBUDtFQUNBOztFQUVELFNBQVN2UyxPQUFULENBQWlCelksSUFBakIsRUFBdUIzQixRQUF2QixFQUFpQ2d0QixRQUFqQyxFQUE0QztJQUMzQyxJQUFJMWYsSUFBSjtJQUFBLElBQ0NsTSxLQUFLLEdBQUdwQixRQUFRLEdBQUdELE1BQU0sQ0FBQ3FPLE1BQVAsQ0FBZXBPLFFBQWYsRUFBeUIyQixJQUF6QixDQUFILEdBQXFDQSxJQUR0RDtJQUFBLElBRUNDLENBQUMsR0FBRyxDQUZMOztJQUlBLE9BQVEsQ0FBRTBMLElBQUksR0FBR2xNLEtBQUssQ0FBRVEsQ0FBRixDQUFkLEtBQXlCLElBQWpDLEVBQXVDQSxDQUFDLEVBQXhDLEVBQTZDO01BRTVDLElBQUssQ0FBQ29yQixRQUFELElBQWExZixJQUFJLENBQUNqSixRQUFMLEtBQWtCLENBQXBDLEVBQXdDO1FBQ3ZDdEUsTUFBTSxDQUFDK2UsU0FBUCxDQUFrQjJFLE1BQU0sQ0FBRW5XLElBQUYsQ0FBeEI7TUFDQTs7TUFFRCxJQUFLQSxJQUFJLENBQUM1QixVQUFWLEVBQXVCO1FBQ3RCLElBQUtzaEIsUUFBUSxJQUFJanRCLE1BQU0sQ0FBQ3lILFFBQVAsQ0FBaUI4RixJQUFJLENBQUN6QyxhQUF0QixFQUFxQ3lDLElBQXJDLENBQWpCLEVBQStEO1VBQzlEcVcsYUFBYSxDQUFFRixNQUFNLENBQUVuVyxJQUFGLEVBQVEsUUFBUixDQUFSLENBQWI7UUFDQTs7UUFDREEsSUFBSSxDQUFDNUIsVUFBTCxDQUFnQlksV0FBaEIsQ0FBNkJnQixJQUE3QjtNQUNBO0lBQ0Q7O0lBRUQsT0FBTzNMLElBQVA7RUFDQTs7RUFFRDVCLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZTtJQUNka2lCLGFBQWEsRUFBRSx1QkFBVXFJLElBQVYsRUFBaUI7TUFDL0IsT0FBT0EsSUFBSSxDQUFDdnBCLE9BQUwsQ0FBY2tvQixTQUFkLEVBQXlCLFdBQXpCLENBQVA7SUFDQSxDQUhhO0lBS2Q1b0IsS0FBSyxFQUFFLGVBQVVsQixJQUFWLEVBQWdCc3JCLGFBQWhCLEVBQStCQyxpQkFBL0IsRUFBbUQ7TUFDekQsSUFBSUMsWUFBSjtNQUFBLElBQWtCN2YsSUFBbEI7TUFBQSxJQUF3QnpLLEtBQXhCO01BQUEsSUFBK0JqQixDQUEvQjtNQUFBLElBQWtDd3JCLFdBQWxDO01BQUEsSUFDQ0MsTUFBTSxHQUFHdHRCLE1BQU0sQ0FBQ3lILFFBQVAsQ0FBaUI3RixJQUFJLENBQUNrSixhQUF0QixFQUFxQ2xKLElBQXJDLENBRFY7O01BR0EsSUFBSzlCLE9BQU8sQ0FBQ3NpQixVQUFSLElBQXNCcGlCLE1BQU0sQ0FBQzRXLFFBQVAsQ0FBaUJoVixJQUFqQixDQUF0QixJQUNKLENBQUM2cEIsWUFBWSxDQUFDcGdCLElBQWIsQ0FBbUIsTUFBTXpKLElBQUksQ0FBQ21ELFFBQVgsR0FBc0IsR0FBekMsQ0FERixFQUNtRDtRQUVsRGpDLEtBQUssR0FBR2xCLElBQUksQ0FBQ3lnQixTQUFMLENBQWdCLElBQWhCLENBQVIsQ0FGa0QsQ0FJbkQ7TUFDQyxDQU5ELE1BTU87UUFDTjJKLFdBQVcsQ0FBQ3ZkLFNBQVosR0FBd0I3TSxJQUFJLENBQUMwZ0IsU0FBN0I7UUFDQTBKLFdBQVcsQ0FBQ3pmLFdBQVosQ0FBeUJ6SixLQUFLLEdBQUdrcEIsV0FBVyxDQUFDNWIsVUFBN0M7TUFDQTs7TUFFRCxJQUFLLENBQUUsQ0FBQ3RRLE9BQU8sQ0FBQzRpQixZQUFULElBQXlCLENBQUM1aUIsT0FBTyxDQUFDMGlCLGNBQXBDLE1BQ0Q1Z0IsSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUFsQixJQUF1QjFDLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsRUFEeEMsS0FDZ0QsQ0FBQ3RFLE1BQU0sQ0FBQzRXLFFBQVAsQ0FBaUJoVixJQUFqQixDQUR0RCxFQUNnRjtRQUUvRTtRQUNBd3JCLFlBQVksR0FBRzFKLE1BQU0sQ0FBRTVnQixLQUFGLENBQXJCO1FBQ0F1cUIsV0FBVyxHQUFHM0osTUFBTSxDQUFFOWhCLElBQUYsQ0FBcEIsQ0FKK0UsQ0FNL0U7O1FBQ0EsS0FBTUMsQ0FBQyxHQUFHLENBQVYsRUFBYSxDQUFFMEwsSUFBSSxHQUFHOGYsV0FBVyxDQUFFeHJCLENBQUYsQ0FBcEIsS0FBK0IsSUFBNUMsRUFBa0QsRUFBRUEsQ0FBcEQsRUFBd0Q7VUFFdkQ7VUFDQSxJQUFLdXJCLFlBQVksQ0FBRXZyQixDQUFGLENBQWpCLEVBQXlCO1lBQ3hCNHFCLGtCQUFrQixDQUFFbGYsSUFBRixFQUFRNmYsWUFBWSxDQUFFdnJCLENBQUYsQ0FBcEIsQ0FBbEI7VUFDQTtRQUNEO01BQ0QsQ0E5QndELENBZ0N6RDs7O01BQ0EsSUFBS3FyQixhQUFMLEVBQXFCO1FBQ3BCLElBQUtDLGlCQUFMLEVBQXlCO1VBQ3hCRSxXQUFXLEdBQUdBLFdBQVcsSUFBSTNKLE1BQU0sQ0FBRTloQixJQUFGLENBQW5DO1VBQ0F3ckIsWUFBWSxHQUFHQSxZQUFZLElBQUkxSixNQUFNLENBQUU1Z0IsS0FBRixDQUFyQzs7VUFFQSxLQUFNakIsQ0FBQyxHQUFHLENBQVYsRUFBYSxDQUFFMEwsSUFBSSxHQUFHOGYsV0FBVyxDQUFFeHJCLENBQUYsQ0FBcEIsS0FBK0IsSUFBNUMsRUFBa0RBLENBQUMsRUFBbkQsRUFBd0Q7WUFDdkR3cUIsY0FBYyxDQUFFOWUsSUFBRixFQUFRNmYsWUFBWSxDQUFFdnJCLENBQUYsQ0FBcEIsQ0FBZDtVQUNBO1FBQ0QsQ0FQRCxNQU9PO1VBQ053cUIsY0FBYyxDQUFFenFCLElBQUYsRUFBUWtCLEtBQVIsQ0FBZDtRQUNBO01BQ0QsQ0E1Q3dELENBOEN6RDs7O01BQ0FzcUIsWUFBWSxHQUFHMUosTUFBTSxDQUFFNWdCLEtBQUYsRUFBUyxRQUFULENBQXJCOztNQUNBLElBQUtzcUIsWUFBWSxDQUFDcnNCLE1BQWIsR0FBc0IsQ0FBM0IsRUFBK0I7UUFDOUI2aUIsYUFBYSxDQUFFd0osWUFBRixFQUFnQixDQUFDRSxNQUFELElBQVc1SixNQUFNLENBQUU5aEIsSUFBRixFQUFRLFFBQVIsQ0FBakMsQ0FBYjtNQUNBOztNQUVEd3JCLFlBQVksR0FBR0MsV0FBVyxHQUFHOWYsSUFBSSxHQUFHLElBQXBDLENBcER5RCxDQXNEekQ7O01BQ0EsT0FBT3pLLEtBQVA7SUFDQSxDQTdEYTtJQStEZGljLFNBQVMsRUFBRSxtQkFBVTFkLEtBQVY7SUFBaUI7SUFBZWtzQixlQUFoQyxFQUFrRDtNQUM1RCxJQUFJM3JCLElBQUo7TUFBQSxJQUFVa0MsSUFBVjtNQUFBLElBQWdCbUgsRUFBaEI7TUFBQSxJQUFvQnZHLElBQXBCO01BQUEsSUFDQzdDLENBQUMsR0FBRyxDQURMO01BQUEsSUFFQzhjLFdBQVcsR0FBRzNlLE1BQU0sQ0FBQ3FELE9BRnRCO01BQUEsSUFHQzJJLEtBQUssR0FBR2hNLE1BQU0sQ0FBQ2dNLEtBSGhCO01BQUEsSUFJQ3JELFVBQVUsR0FBRzdJLE9BQU8sQ0FBQzZJLFVBSnRCO01BQUEsSUFLQ21kLE9BQU8sR0FBRzlsQixNQUFNLENBQUNtZCxLQUFQLENBQWEySSxPQUx4Qjs7TUFPQSxPQUFRLENBQUVsa0IsSUFBSSxHQUFHUCxLQUFLLENBQUVRLENBQUYsQ0FBZCxLQUF5QixJQUFqQyxFQUF1Q0EsQ0FBQyxFQUF4QyxFQUE2QztRQUM1QyxJQUFLMHJCLGVBQWUsSUFBSXRQLFVBQVUsQ0FBRXJjLElBQUYsQ0FBbEMsRUFBNkM7VUFFNUNxSixFQUFFLEdBQUdySixJQUFJLENBQUUrYyxXQUFGLENBQVQ7VUFDQWphLElBQUksR0FBR3VHLEVBQUUsSUFBSWUsS0FBSyxDQUFFZixFQUFGLENBQWxCOztVQUVBLElBQUt2RyxJQUFMLEVBQVk7WUFDWCxJQUFLQSxJQUFJLENBQUNpaEIsTUFBVixFQUFtQjtjQUNsQixLQUFNN2hCLElBQU4sSUFBY1ksSUFBSSxDQUFDaWhCLE1BQW5CLEVBQTRCO2dCQUMzQixJQUFLRyxPQUFPLENBQUVoaUIsSUFBRixDQUFaLEVBQXVCO2tCQUN0QjlELE1BQU0sQ0FBQ21kLEtBQVAsQ0FBYTlDLE1BQWIsQ0FBcUJ6WSxJQUFyQixFQUEyQmtDLElBQTNCLEVBRHNCLENBR3ZCO2dCQUNDLENBSkQsTUFJTztrQkFDTjlELE1BQU0sQ0FBQ2duQixXQUFQLENBQW9CcGxCLElBQXBCLEVBQTBCa0MsSUFBMUIsRUFBZ0NZLElBQUksQ0FBQzJoQixNQUFyQztnQkFDQTtjQUNEO1lBQ0QsQ0FYVSxDQWFYOzs7WUFDQSxJQUFLcmEsS0FBSyxDQUFFZixFQUFGLENBQVYsRUFBbUI7Y0FFbEIsT0FBT2UsS0FBSyxDQUFFZixFQUFGLENBQVosQ0FGa0IsQ0FJbEI7Y0FDQTtjQUNBO2NBQ0E7O2NBQ0EsSUFBSyxDQUFDdEMsVUFBRCxJQUFlLE9BQU8vRyxJQUFJLENBQUNrSyxlQUFaLEtBQWdDLFdBQXBELEVBQWtFO2dCQUNqRWxLLElBQUksQ0FBQ2tLLGVBQUwsQ0FBc0I2UyxXQUF0QixFQURpRSxDQUdsRTtnQkFDQTtnQkFDQTtjQUNDLENBTkQsTUFNTztnQkFDTi9jLElBQUksQ0FBRStjLFdBQUYsQ0FBSixHQUFzQnZiLFNBQXRCO2NBQ0E7O2NBRUQvRCxVQUFVLENBQUNHLElBQVgsQ0FBaUJ5TCxFQUFqQjtZQUNBO1VBQ0Q7UUFDRDtNQUNEO0lBQ0Q7RUFsSGEsQ0FBZjtFQXFIQWpMLE1BQU0sQ0FBQ0csRUFBUCxDQUFVcUMsTUFBVixDQUFrQjtJQUVqQjtJQUNBbXFCLFFBQVEsRUFBRUEsUUFITztJQUtqQjVQLE1BQU0sRUFBRSxnQkFBVTljLFFBQVYsRUFBcUI7TUFDNUIsT0FBT29hLE9BQU0sQ0FBRSxJQUFGLEVBQVFwYSxRQUFSLEVBQWtCLElBQWxCLENBQWI7SUFDQSxDQVBnQjtJQVNqQm9hLE1BQU0sRUFBRSxnQkFBVXBhLFFBQVYsRUFBcUI7TUFDNUIsT0FBT29hLE9BQU0sQ0FBRSxJQUFGLEVBQVFwYSxRQUFSLENBQWI7SUFDQSxDQVhnQjtJQWFqQmlGLElBQUksRUFBRSxjQUFVYyxLQUFWLEVBQWtCO01BQ3ZCLE9BQU9tYixNQUFNLENBQUUsSUFBRixFQUFRLFVBQVVuYixLQUFWLEVBQWtCO1FBQ3RDLE9BQU9BLEtBQUssS0FBSzVDLFNBQVYsR0FDTnBELE1BQU0sQ0FBQ2tGLElBQVAsQ0FBYSxJQUFiLENBRE0sR0FFTixLQUFLb1YsS0FBTCxHQUFha1QsTUFBYixDQUNDLENBQUUsS0FBTSxDQUFOLEtBQWEsS0FBTSxDQUFOLEVBQVUxaUIsYUFBdkIsSUFBd0M5TCxRQUExQyxFQUFxRHlsQixjQUFyRCxDQUFxRXplLEtBQXJFLENBREQsQ0FGRDtNQUtBLENBTlksRUFNVixJQU5VLEVBTUpBLEtBTkksRUFNR2pFLFNBQVMsQ0FBQ2hCLE1BTmIsQ0FBYjtJQU9BLENBckJnQjtJQXVCakJ5c0IsTUFBTSxFQUFFLGtCQUFXO01BQ2xCLE9BQU9iLFFBQVEsQ0FBRSxJQUFGLEVBQVE1cUIsU0FBUixFQUFtQixVQUFVSCxJQUFWLEVBQWlCO1FBQ2xELElBQUssS0FBSzBDLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUIsS0FBS0EsUUFBTCxLQUFrQixFQUF6QyxJQUErQyxLQUFLQSxRQUFMLEtBQWtCLENBQXRFLEVBQTBFO1VBQ3pFLElBQUl2QixNQUFNLEdBQUdrcEIsa0JBQWtCLENBQUUsSUFBRixFQUFRcnFCLElBQVIsQ0FBL0I7VUFDQW1CLE1BQU0sQ0FBQ2lMLFdBQVAsQ0FBb0JwTSxJQUFwQjtRQUNBO01BQ0QsQ0FMYyxDQUFmO0lBTUEsQ0E5QmdCO0lBZ0NqQjZyQixPQUFPLEVBQUUsbUJBQVc7TUFDbkIsT0FBT2QsUUFBUSxDQUFFLElBQUYsRUFBUTVxQixTQUFSLEVBQW1CLFVBQVVILElBQVYsRUFBaUI7UUFDbEQsSUFBSyxLQUFLMEMsUUFBTCxLQUFrQixDQUFsQixJQUF1QixLQUFLQSxRQUFMLEtBQWtCLEVBQXpDLElBQStDLEtBQUtBLFFBQUwsS0FBa0IsQ0FBdEUsRUFBMEU7VUFDekUsSUFBSXZCLE1BQU0sR0FBR2twQixrQkFBa0IsQ0FBRSxJQUFGLEVBQVFycUIsSUFBUixDQUEvQjtVQUNBbUIsTUFBTSxDQUFDMnFCLFlBQVAsQ0FBcUI5ckIsSUFBckIsRUFBMkJtQixNQUFNLENBQUNxTixVQUFsQztRQUNBO01BQ0QsQ0FMYyxDQUFmO0lBTUEsQ0F2Q2dCO0lBeUNqQnVkLE1BQU0sRUFBRSxrQkFBVztNQUNsQixPQUFPaEIsUUFBUSxDQUFFLElBQUYsRUFBUTVxQixTQUFSLEVBQW1CLFVBQVVILElBQVYsRUFBaUI7UUFDbEQsSUFBSyxLQUFLK0osVUFBVixFQUF1QjtVQUN0QixLQUFLQSxVQUFMLENBQWdCK2hCLFlBQWhCLENBQThCOXJCLElBQTlCLEVBQW9DLElBQXBDO1FBQ0E7TUFDRCxDQUpjLENBQWY7SUFLQSxDQS9DZ0I7SUFpRGpCZ3NCLEtBQUssRUFBRSxpQkFBVztNQUNqQixPQUFPakIsUUFBUSxDQUFFLElBQUYsRUFBUTVxQixTQUFSLEVBQW1CLFVBQVVILElBQVYsRUFBaUI7UUFDbEQsSUFBSyxLQUFLK0osVUFBVixFQUF1QjtVQUN0QixLQUFLQSxVQUFMLENBQWdCK2hCLFlBQWhCLENBQThCOXJCLElBQTlCLEVBQW9DLEtBQUtvTCxXQUF6QztRQUNBO01BQ0QsQ0FKYyxDQUFmO0lBS0EsQ0F2RGdCO0lBeURqQnNOLEtBQUssRUFBRSxpQkFBVztNQUNqQixJQUFJMVksSUFBSjtNQUFBLElBQ0NDLENBQUMsR0FBRyxDQURMOztNQUdBLE9BQVEsQ0FBRUQsSUFBSSxHQUFHLEtBQU1DLENBQU4sQ0FBVCxLQUF3QixJQUFoQyxFQUFzQ0EsQ0FBQyxFQUF2QyxFQUE0QztRQUUzQztRQUNBLElBQUtELElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7VUFDMUJ0RSxNQUFNLENBQUMrZSxTQUFQLENBQWtCMkUsTUFBTSxDQUFFOWhCLElBQUYsRUFBUSxLQUFSLENBQXhCO1FBQ0EsQ0FMMEMsQ0FPM0M7OztRQUNBLE9BQVFBLElBQUksQ0FBQ3dPLFVBQWIsRUFBMEI7VUFDekJ4TyxJQUFJLENBQUMySyxXQUFMLENBQWtCM0ssSUFBSSxDQUFDd08sVUFBdkI7UUFDQSxDQVYwQyxDQVkzQztRQUNBOzs7UUFDQSxJQUFLeE8sSUFBSSxDQUFDaUIsT0FBTCxJQUFnQjdDLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJuRCxJQUFqQixFQUF1QixRQUF2QixDQUFyQixFQUF5RDtVQUN4REEsSUFBSSxDQUFDaUIsT0FBTCxDQUFhOUIsTUFBYixHQUFzQixDQUF0QjtRQUNBO01BQ0Q7O01BRUQsT0FBTyxJQUFQO0lBQ0EsQ0FqRmdCO0lBbUZqQitCLEtBQUssRUFBRSxlQUFVb3FCLGFBQVYsRUFBeUJDLGlCQUF6QixFQUE2QztNQUNuREQsYUFBYSxHQUFHQSxhQUFhLElBQUksSUFBakIsR0FBd0IsS0FBeEIsR0FBZ0NBLGFBQWhEO01BQ0FDLGlCQUFpQixHQUFHQSxpQkFBaUIsSUFBSSxJQUFyQixHQUE0QkQsYUFBNUIsR0FBNENDLGlCQUFoRTtNQUVBLE9BQU8sS0FBS3hyQixHQUFMLENBQVUsWUFBVztRQUMzQixPQUFPM0IsTUFBTSxDQUFDOEMsS0FBUCxDQUFjLElBQWQsRUFBb0JvcUIsYUFBcEIsRUFBbUNDLGlCQUFuQyxDQUFQO01BQ0EsQ0FGTSxDQUFQO0lBR0EsQ0ExRmdCO0lBNEZqQkosSUFBSSxFQUFFLGNBQVUvbUIsS0FBVixFQUFrQjtNQUN2QixPQUFPbWIsTUFBTSxDQUFFLElBQUYsRUFBUSxVQUFVbmIsS0FBVixFQUFrQjtRQUN0QyxJQUFJcEUsSUFBSSxHQUFHLEtBQU0sQ0FBTixLQUFhLEVBQXhCO1FBQUEsSUFDQ0MsQ0FBQyxHQUFHLENBREw7UUFBQSxJQUVDMlcsQ0FBQyxHQUFHLEtBQUt6WCxNQUZWOztRQUlBLElBQUtpRixLQUFLLEtBQUs1QyxTQUFmLEVBQTJCO1VBQzFCLE9BQU94QixJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxCLEdBQ04xQyxJQUFJLENBQUM2TSxTQUFMLENBQWVqTCxPQUFmLENBQXdCZ29CLGFBQXhCLEVBQXVDLEVBQXZDLENBRE0sR0FFTnBvQixTQUZEO1FBR0EsQ0FUcUMsQ0FXdEM7OztRQUNBLElBQUssT0FBTzRDLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsQ0FBQzJsQixZQUFZLENBQUN0Z0IsSUFBYixDQUFtQnJGLEtBQW5CLENBQTlCLEtBQ0ZsRyxPQUFPLENBQUNxaUIsYUFBUixJQUF5QixDQUFDc0osWUFBWSxDQUFDcGdCLElBQWIsQ0FBbUJyRixLQUFuQixDQUR4QixNQUVGbEcsT0FBTyxDQUFDbWlCLGlCQUFSLElBQTZCLENBQUNOLGtCQUFrQixDQUFDdFcsSUFBbkIsQ0FBeUJyRixLQUF6QixDQUY1QixLQUdKLENBQUMyYyxPQUFPLENBQUUsQ0FBRWxCLFFBQVEsQ0FBQzFXLElBQVQsQ0FBZS9FLEtBQWYsS0FBMEIsQ0FBRSxFQUFGLEVBQU0sRUFBTixDQUE1QixFQUEwQyxDQUExQyxFQUE4Q2hCLFdBQTlDLEVBQUYsQ0FIVCxFQUcyRTtVQUUxRWdCLEtBQUssR0FBR2hHLE1BQU0sQ0FBQzBrQixhQUFQLENBQXNCMWUsS0FBdEIsQ0FBUjs7VUFFQSxJQUFJO1lBQ0gsT0FBUW5FLENBQUMsR0FBRzJXLENBQVosRUFBZTNXLENBQUMsRUFBaEIsRUFBcUI7Y0FFcEI7Y0FDQUQsSUFBSSxHQUFHLEtBQU1DLENBQU4sS0FBYSxFQUFwQjs7Y0FDQSxJQUFLRCxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO2dCQUMxQnRFLE1BQU0sQ0FBQytlLFNBQVAsQ0FBa0IyRSxNQUFNLENBQUU5aEIsSUFBRixFQUFRLEtBQVIsQ0FBeEI7Z0JBQ0FBLElBQUksQ0FBQzZNLFNBQUwsR0FBaUJ6SSxLQUFqQjtjQUNBO1lBQ0Q7O1lBRURwRSxJQUFJLEdBQUcsQ0FBUCxDQVhHLENBYUo7VUFDQyxDQWRELENBY0UsT0FBUTJDLENBQVIsRUFBWSxDQUFFO1FBQ2hCOztRQUVELElBQUszQyxJQUFMLEVBQVk7VUFDWCxLQUFLMFksS0FBTCxHQUFha1QsTUFBYixDQUFxQnhuQixLQUFyQjtRQUNBO01BQ0QsQ0F2Q1ksRUF1Q1YsSUF2Q1UsRUF1Q0pBLEtBdkNJLEVBdUNHakUsU0FBUyxDQUFDaEIsTUF2Q2IsQ0FBYjtJQXdDQSxDQXJJZ0I7SUF1SWpCOHNCLFdBQVcsRUFBRSx1QkFBVztNQUN2QixJQUFJeEosT0FBTyxHQUFHLEVBQWQsQ0FEdUIsQ0FHdkI7O01BQ0EsT0FBT3NJLFFBQVEsQ0FBRSxJQUFGLEVBQVE1cUIsU0FBUixFQUFtQixVQUFVSCxJQUFWLEVBQWlCO1FBQ2xELElBQUk2TCxNQUFNLEdBQUcsS0FBSzlCLFVBQWxCOztRQUVBLElBQUszTCxNQUFNLENBQUN1RixPQUFQLENBQWdCLElBQWhCLEVBQXNCOGUsT0FBdEIsSUFBa0MsQ0FBdkMsRUFBMkM7VUFDMUNya0IsTUFBTSxDQUFDK2UsU0FBUCxDQUFrQjJFLE1BQU0sQ0FBRSxJQUFGLENBQXhCOztVQUNBLElBQUtqVyxNQUFMLEVBQWM7WUFDYkEsTUFBTSxDQUFDcWdCLFlBQVAsQ0FBcUJsc0IsSUFBckIsRUFBMkIsSUFBM0I7VUFDQTtRQUNELENBUmlELENBVW5EOztNQUNDLENBWGMsRUFXWnlpQixPQVhZLENBQWY7SUFZQTtFQXZKZ0IsQ0FBbEI7RUEwSkFya0IsTUFBTSxDQUFDeUIsSUFBUCxDQUFhO0lBQ1pzc0IsUUFBUSxFQUFFLFFBREU7SUFFWkMsU0FBUyxFQUFFLFNBRkM7SUFHWk4sWUFBWSxFQUFFLFFBSEY7SUFJWk8sV0FBVyxFQUFFLE9BSkQ7SUFLWkMsVUFBVSxFQUFFO0VBTEEsQ0FBYixFQU1HLFVBQVV0ckIsSUFBVixFQUFnQnFtQixRQUFoQixFQUEyQjtJQUM3QmpwQixNQUFNLENBQUNHLEVBQVAsQ0FBV3lDLElBQVgsSUFBb0IsVUFBVTNDLFFBQVYsRUFBcUI7TUFDeEMsSUFBSW9CLEtBQUo7TUFBQSxJQUNDUSxDQUFDLEdBQUcsQ0FETDtNQUFBLElBRUNQLEdBQUcsR0FBRyxFQUZQO01BQUEsSUFHQzZzQixNQUFNLEdBQUdudUIsTUFBTSxDQUFFQyxRQUFGLENBSGhCO01BQUEsSUFJQ2lDLElBQUksR0FBR2lzQixNQUFNLENBQUNwdEIsTUFBUCxHQUFnQixDQUp4Qjs7TUFNQSxPQUFRYyxDQUFDLElBQUlLLElBQWIsRUFBbUJMLENBQUMsRUFBcEIsRUFBeUI7UUFDeEJSLEtBQUssR0FBR1EsQ0FBQyxLQUFLSyxJQUFOLEdBQWEsSUFBYixHQUFvQixLQUFLWSxLQUFMLENBQVksSUFBWixDQUE1QjtRQUNBOUMsTUFBTSxDQUFFbXVCLE1BQU0sQ0FBRXRzQixDQUFGLENBQVIsQ0FBTixDQUF1Qm9uQixRQUF2QixFQUFtQzVuQixLQUFuQyxFQUZ3QixDQUl4Qjs7UUFDQTdCLElBQUksQ0FBQ3NDLEtBQUwsQ0FBWVIsR0FBWixFQUFpQkQsS0FBSyxDQUFDSCxHQUFOLEVBQWpCO01BQ0E7O01BRUQsT0FBTyxLQUFLRSxTQUFMLENBQWdCRSxHQUFoQixDQUFQO0lBQ0EsQ0FoQkQ7RUFpQkEsQ0F4QkQ7RUEyQkEsSUFBSThzQixNQUFKO0VBQUEsSUFDQ0MsV0FBVyxHQUFHO0lBRWI7SUFDQTtJQUNBQyxJQUFJLEVBQUUsT0FKTztJQUtiQyxJQUFJLEVBQUU7RUFMTyxDQURmO0VBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUVBOztFQUNBLFNBQVNDLGFBQVQsQ0FBd0I1ckIsSUFBeEIsRUFBOEI4SyxHQUE5QixFQUFvQztJQUNuQyxJQUFJOUwsSUFBSSxHQUFHNUIsTUFBTSxDQUFFME4sR0FBRyxDQUFDcEIsYUFBSixDQUFtQjFKLElBQW5CLENBQUYsQ0FBTixDQUFvQ21yQixRQUFwQyxDQUE4Q3JnQixHQUFHLENBQUNnUSxJQUFsRCxDQUFYO0lBQUEsSUFFQytRLE9BQU8sR0FBR3p1QixNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBSSxDQUFFLENBQUYsQ0FBaEIsRUFBdUIsU0FBdkIsQ0FGWCxDQURtQyxDQUtuQztJQUNBOztJQUNBQSxJQUFJLENBQUNtYixNQUFMO0lBRUEsT0FBTzBSLE9BQVA7RUFDQTtFQUVEO0FBQ0E7QUFDQTtBQUNBOzs7RUFDQSxTQUFTQyxjQUFULENBQXlCM3BCLFFBQXpCLEVBQW9DO0lBQ25DLElBQUkySSxHQUFHLEdBQUcxTyxRQUFWO0lBQUEsSUFDQ3l2QixPQUFPLEdBQUdKLFdBQVcsQ0FBRXRwQixRQUFGLENBRHRCOztJQUdBLElBQUssQ0FBQzBwQixPQUFOLEVBQWdCO01BQ2ZBLE9BQU8sR0FBR0QsYUFBYSxDQUFFenBCLFFBQUYsRUFBWTJJLEdBQVosQ0FBdkIsQ0FEZSxDQUdmOztNQUNBLElBQUsrZ0IsT0FBTyxLQUFLLE1BQVosSUFBc0IsQ0FBQ0EsT0FBNUIsRUFBc0M7UUFFckM7UUFDQUwsTUFBTSxHQUFHLENBQUVBLE1BQU0sSUFBSXB1QixNQUFNLENBQUUsZ0RBQUYsQ0FBbEIsRUFDUCt0QixRQURPLENBQ0dyZ0IsR0FBRyxDQUFDSixlQURQLENBQVQsQ0FIcUMsQ0FNckM7O1FBQ0FJLEdBQUcsR0FBRyxDQUFFMGdCLE1BQU0sQ0FBRSxDQUFGLENBQU4sQ0FBWS9VLGFBQVosSUFBNkIrVSxNQUFNLENBQUUsQ0FBRixDQUFOLENBQVloVixlQUEzQyxFQUE2RHBhLFFBQW5FLENBUHFDLENBU3JDOztRQUNBME8sR0FBRyxDQUFDaWhCLEtBQUo7UUFDQWpoQixHQUFHLENBQUNraEIsS0FBSjtRQUVBSCxPQUFPLEdBQUdELGFBQWEsQ0FBRXpwQixRQUFGLEVBQVkySSxHQUFaLENBQXZCO1FBQ0EwZ0IsTUFBTSxDQUFDclIsTUFBUDtNQUNBLENBbkJjLENBcUJmOzs7TUFDQXNSLFdBQVcsQ0FBRXRwQixRQUFGLENBQVgsR0FBMEIwcEIsT0FBMUI7SUFDQTs7SUFFRCxPQUFPQSxPQUFQO0VBQ0E7O0VBQ0QsSUFBSUksT0FBTyxHQUFLLFNBQWhCO0VBRUEsSUFBSUMsU0FBUyxHQUFHLElBQUlobUIsTUFBSixDQUFZLE9BQU9rWCxJQUFQLEdBQWMsaUJBQTFCLEVBQTZDLEdBQTdDLENBQWhCOztFQUVBLElBQUkrTyxJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFVbnRCLElBQVYsRUFBZ0JpQixPQUFoQixFQUF5Qm5CLFFBQXpCLEVBQW1DeUUsSUFBbkMsRUFBMEM7SUFDcEQsSUFBSTdFLEdBQUo7SUFBQSxJQUFTc0IsSUFBVDtJQUFBLElBQ0Nvc0IsR0FBRyxHQUFHLEVBRFAsQ0FEb0QsQ0FJcEQ7O0lBQ0EsS0FBTXBzQixJQUFOLElBQWNDLE9BQWQsRUFBd0I7TUFDdkJtc0IsR0FBRyxDQUFFcHNCLElBQUYsQ0FBSCxHQUFjaEIsSUFBSSxDQUFDZ2MsS0FBTCxDQUFZaGIsSUFBWixDQUFkO01BQ0FoQixJQUFJLENBQUNnYyxLQUFMLENBQVloYixJQUFaLElBQXFCQyxPQUFPLENBQUVELElBQUYsQ0FBNUI7SUFDQTs7SUFFRHRCLEdBQUcsR0FBR0ksUUFBUSxDQUFDSSxLQUFULENBQWdCRixJQUFoQixFQUFzQnVFLElBQUksSUFBSSxFQUE5QixDQUFOLENBVm9ELENBWXBEOztJQUNBLEtBQU12RCxJQUFOLElBQWNDLE9BQWQsRUFBd0I7TUFDdkJqQixJQUFJLENBQUNnYyxLQUFMLENBQVloYixJQUFaLElBQXFCb3NCLEdBQUcsQ0FBRXBzQixJQUFGLENBQXhCO0lBQ0E7O0lBRUQsT0FBT3RCLEdBQVA7RUFDQSxDQWxCRDs7RUFxQkEsSUFBSWdNLGVBQWUsR0FBR3RPLFFBQVEsQ0FBQ3NPLGVBQS9COztFQUlBLENBQUUsWUFBVztJQUNaLElBQUkyaEIsZ0JBQUo7SUFBQSxJQUFzQkMsbUJBQXRCO0lBQUEsSUFBMkNDLG9CQUEzQztJQUFBLElBQ0NDLHdCQUREO0lBQUEsSUFDMkJDLHNCQUQzQjtJQUFBLElBQ21EQyxxQkFEbkQ7SUFBQSxJQUVDM1IsU0FBUyxHQUFHM2UsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQUZiO0lBQUEsSUFHQ0QsR0FBRyxHQUFHck4sUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQUhQLENBRFksQ0FNWjs7SUFDQSxJQUFLLENBQUNELEdBQUcsQ0FBQ3VSLEtBQVYsRUFBa0I7TUFDakI7SUFDQTs7SUFFRHZSLEdBQUcsQ0FBQ3VSLEtBQUosQ0FBVUMsT0FBVixHQUFvQix1QkFBcEIsQ0FYWSxDQWFaO0lBQ0E7O0lBQ0EvZCxPQUFPLENBQUN5dkIsT0FBUixHQUFrQmxqQixHQUFHLENBQUN1UixLQUFKLENBQVUyUixPQUFWLEtBQXNCLEtBQXhDLENBZlksQ0FpQlo7SUFDQTs7SUFDQXp2QixPQUFPLENBQUMwdkIsUUFBUixHQUFtQixDQUFDLENBQUNuakIsR0FBRyxDQUFDdVIsS0FBSixDQUFVNFIsUUFBL0I7SUFFQW5qQixHQUFHLENBQUN1UixLQUFKLENBQVU2UixjQUFWLEdBQTJCLGFBQTNCO0lBQ0FwakIsR0FBRyxDQUFDZ1csU0FBSixDQUFlLElBQWYsRUFBc0J6RSxLQUF0QixDQUE0QjZSLGNBQTVCLEdBQTZDLEVBQTdDO0lBQ0EzdkIsT0FBTyxDQUFDNHZCLGVBQVIsR0FBMEJyakIsR0FBRyxDQUFDdVIsS0FBSixDQUFVNlIsY0FBVixLQUE2QixhQUF2RDtJQUVBOVIsU0FBUyxHQUFHM2UsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixLQUF4QixDQUFaO0lBQ0FxUixTQUFTLENBQUNDLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLG9EQUN6Qiw0Q0FERDtJQUVBeFIsR0FBRyxDQUFDb0MsU0FBSixHQUFnQixFQUFoQjtJQUNBa1AsU0FBUyxDQUFDM1AsV0FBVixDQUF1QjNCLEdBQXZCLEVBN0JZLENBK0JaO0lBQ0E7O0lBQ0F2TSxPQUFPLENBQUM2dkIsU0FBUixHQUFvQnRqQixHQUFHLENBQUN1UixLQUFKLENBQVUrUixTQUFWLEtBQXdCLEVBQXhCLElBQThCdGpCLEdBQUcsQ0FBQ3VSLEtBQUosQ0FBVWdTLFlBQVYsS0FBMkIsRUFBekQsSUFDbkJ2akIsR0FBRyxDQUFDdVIsS0FBSixDQUFVaVMsZUFBVixLQUE4QixFQUQvQjtJQUdBN3ZCLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZTFDLE9BQWYsRUFBd0I7TUFDdkJnd0IscUJBQXFCLEVBQUUsaUNBQVc7UUFDakMsSUFBS2IsZ0JBQWdCLElBQUksSUFBekIsRUFBZ0M7VUFDL0JjLGlCQUFpQjtRQUNqQjs7UUFDRCxPQUFPWCx3QkFBUDtNQUNBLENBTnNCO01BUXZCWSxpQkFBaUIsRUFBRSw2QkFBVztRQUU3QjtRQUNBO1FBQ0EsSUFBS2YsZ0JBQWdCLElBQUksSUFBekIsRUFBZ0M7VUFDL0JjLGlCQUFpQjtRQUNqQjs7UUFDRCxPQUFPWixvQkFBUDtNQUNBLENBaEJzQjtNQWtCdkJjLGdCQUFnQixFQUFFLDRCQUFXO1FBRTVCO1FBQ0EsSUFBS2hCLGdCQUFnQixJQUFJLElBQXpCLEVBQWdDO1VBQy9CYyxpQkFBaUI7UUFDakI7O1FBQ0QsT0FBT2IsbUJBQVA7TUFDQSxDQXpCc0I7TUEyQnZCZ0IsYUFBYSxFQUFFLHlCQUFXO1FBQ3pCLElBQUtqQixnQkFBZ0IsSUFBSSxJQUF6QixFQUFnQztVQUMvQmMsaUJBQWlCO1FBQ2pCOztRQUNELE9BQU9kLGdCQUFQO01BQ0EsQ0FoQ3NCO01Ba0N2QmtCLG1CQUFtQixFQUFFLCtCQUFXO1FBRS9CO1FBQ0EsSUFBS2xCLGdCQUFnQixJQUFJLElBQXpCLEVBQWdDO1VBQy9CYyxpQkFBaUI7UUFDakI7O1FBQ0QsT0FBT1Ysc0JBQVA7TUFDQSxDQXpDc0I7TUEyQ3ZCZSxrQkFBa0IsRUFBRSw4QkFBVztRQUU5QjtRQUNBLElBQUtuQixnQkFBZ0IsSUFBSSxJQUF6QixFQUFnQztVQUMvQmMsaUJBQWlCO1FBQ2pCOztRQUNELE9BQU9ULHFCQUFQO01BQ0E7SUFsRHNCLENBQXhCOztJQXFEQSxTQUFTUyxpQkFBVCxHQUE2QjtNQUM1QixJQUFJN1gsUUFBSjtNQUFBLElBQWNtWSxRQUFkO01BQUEsSUFDQy9pQixlQUFlLEdBQUd0TyxRQUFRLENBQUNzTyxlQUQ1QixDQUQ0QixDQUk1Qjs7TUFDQUEsZUFBZSxDQUFDVSxXQUFoQixDQUE2QjJQLFNBQTdCO01BRUF0UixHQUFHLENBQUN1UixLQUFKLENBQVVDLE9BQVYsR0FFQztNQUNBO01BQ0EseURBQ0Esa0NBREEsR0FFQSxxQ0FGQSxHQUdBLGtCQVBELENBUDRCLENBZ0I1QjtNQUNBOztNQUNBb1IsZ0JBQWdCLEdBQUdFLG9CQUFvQixHQUFHRyxxQkFBcUIsR0FBRyxLQUFsRTtNQUNBSixtQkFBbUIsR0FBR0csc0JBQXNCLEdBQUcsSUFBL0MsQ0FuQjRCLENBcUI1Qjs7TUFDQSxJQUFLbHdCLE1BQU0sQ0FBQ214QixnQkFBWixFQUErQjtRQUM5QkQsUUFBUSxHQUFHbHhCLE1BQU0sQ0FBQ214QixnQkFBUCxDQUF5QmprQixHQUF6QixDQUFYO1FBQ0E0aUIsZ0JBQWdCLEdBQUcsQ0FBRW9CLFFBQVEsSUFBSSxFQUFkLEVBQW1CemlCLEdBQW5CLEtBQTJCLElBQTlDO1FBQ0EwaEIscUJBQXFCLEdBQUcsQ0FBRWUsUUFBUSxJQUFJLEVBQWQsRUFBbUJFLFVBQW5CLEtBQWtDLEtBQTFEO1FBQ0FwQixvQkFBb0IsR0FBRyxDQUFFa0IsUUFBUSxJQUFJO1VBQUV0USxLQUFLLEVBQUU7UUFBVCxDQUFkLEVBQWlDQSxLQUFqQyxLQUEyQyxLQUFsRSxDQUo4QixDQU05QjtRQUNBOztRQUNBMVQsR0FBRyxDQUFDdVIsS0FBSixDQUFVNFMsV0FBVixHQUF3QixLQUF4QjtRQUNBdEIsbUJBQW1CLEdBQUcsQ0FBRW1CLFFBQVEsSUFBSTtVQUFFRyxXQUFXLEVBQUU7UUFBZixDQUFkLEVBQXVDQSxXQUF2QyxLQUF1RCxLQUE3RSxDQVQ4QixDQVc5QjtRQUNBO1FBQ0E7UUFDQTs7UUFDQXRZLFFBQVEsR0FBRzdMLEdBQUcsQ0FBQzJCLFdBQUosQ0FBaUJoUCxRQUFRLENBQUNzTixhQUFULENBQXdCLEtBQXhCLENBQWpCLENBQVgsQ0FmOEIsQ0FpQjlCOztRQUNBNEwsUUFBUSxDQUFDMEYsS0FBVCxDQUFlQyxPQUFmLEdBQXlCeFIsR0FBRyxDQUFDdVIsS0FBSixDQUFVQyxPQUFWLEdBRXhCO1FBQ0E7UUFDQSxnRUFDQSxrRUFMRDtRQU1BM0YsUUFBUSxDQUFDMEYsS0FBVCxDQUFlNFMsV0FBZixHQUE2QnRZLFFBQVEsQ0FBQzBGLEtBQVQsQ0FBZW1DLEtBQWYsR0FBdUIsR0FBcEQ7UUFDQTFULEdBQUcsQ0FBQ3VSLEtBQUosQ0FBVW1DLEtBQVYsR0FBa0IsS0FBbEI7UUFFQXNQLHNCQUFzQixHQUNyQixDQUFDbHJCLFVBQVUsQ0FBRSxDQUFFaEYsTUFBTSxDQUFDbXhCLGdCQUFQLENBQXlCcFksUUFBekIsS0FBdUMsRUFBekMsRUFBOENzWSxXQUFoRCxDQURaO1FBR0Fua0IsR0FBRyxDQUFDRSxXQUFKLENBQWlCMkwsUUFBakI7TUFDQSxDQXJEMkIsQ0F1RDVCO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7OztNQUNBN0wsR0FBRyxDQUFDdVIsS0FBSixDQUFVNlEsT0FBVixHQUFvQixNQUFwQjtNQUNBVyx3QkFBd0IsR0FBRy9pQixHQUFHLENBQUNva0IsY0FBSixHQUFxQjF2QixNQUFyQixLQUFnQyxDQUEzRDs7TUFDQSxJQUFLcXVCLHdCQUFMLEVBQWdDO1FBQy9CL2lCLEdBQUcsQ0FBQ3VSLEtBQUosQ0FBVTZRLE9BQVYsR0FBb0IsRUFBcEI7UUFDQXBpQixHQUFHLENBQUNvQyxTQUFKLEdBQWdCLDZDQUFoQjtRQUNBeUosUUFBUSxHQUFHN0wsR0FBRyxDQUFDbkIsb0JBQUosQ0FBMEIsSUFBMUIsQ0FBWDtRQUNBZ04sUUFBUSxDQUFFLENBQUYsQ0FBUixDQUFjMEYsS0FBZCxDQUFvQkMsT0FBcEIsR0FBOEIsMENBQTlCO1FBQ0F1Uix3QkFBd0IsR0FBR2xYLFFBQVEsQ0FBRSxDQUFGLENBQVIsQ0FBY3dZLFlBQWQsS0FBK0IsQ0FBMUQ7O1FBQ0EsSUFBS3RCLHdCQUFMLEVBQWdDO1VBQy9CbFgsUUFBUSxDQUFFLENBQUYsQ0FBUixDQUFjMEYsS0FBZCxDQUFvQjZRLE9BQXBCLEdBQThCLEVBQTlCO1VBQ0F2VyxRQUFRLENBQUUsQ0FBRixDQUFSLENBQWMwRixLQUFkLENBQW9CNlEsT0FBcEIsR0FBOEIsTUFBOUI7VUFDQVcsd0JBQXdCLEdBQUdsWCxRQUFRLENBQUUsQ0FBRixDQUFSLENBQWN3WSxZQUFkLEtBQStCLENBQTFEO1FBQ0E7TUFDRCxDQTVFMkIsQ0E4RTVCOzs7TUFDQXBqQixlQUFlLENBQUNmLFdBQWhCLENBQTZCb1IsU0FBN0I7SUFDQTtFQUVELENBM0tEOztFQThLQSxJQUFJZ1QsU0FBSjtFQUFBLElBQWVDLE1BQWY7RUFBQSxJQUNDQyxTQUFTLEdBQUcsMkJBRGI7O0VBR0EsSUFBSzF4QixNQUFNLENBQUNteEIsZ0JBQVosRUFBK0I7SUFDOUJLLFNBQVMsR0FBRyxtQkFBVS91QixJQUFWLEVBQWlCO01BRTVCO01BQ0E7TUFDQTtNQUNBLElBQUlrdkIsSUFBSSxHQUFHbHZCLElBQUksQ0FBQ2tKLGFBQUwsQ0FBbUI2QyxXQUE5Qjs7TUFFQSxJQUFLLENBQUNtakIsSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ0MsTUFBcEIsRUFBNkI7UUFDNUJELElBQUksR0FBRzN4QixNQUFQO01BQ0E7O01BRUQsT0FBTzJ4QixJQUFJLENBQUNSLGdCQUFMLENBQXVCMXVCLElBQXZCLENBQVA7SUFDQSxDQVpEOztJQWNBZ3ZCLE1BQU0sR0FBRyxnQkFBVWh2QixJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0JvdUIsUUFBdEIsRUFBaUM7TUFDekMsSUFBSWpSLEtBQUo7TUFBQSxJQUFXa1IsUUFBWDtNQUFBLElBQXFCQyxRQUFyQjtNQUFBLElBQStCNXZCLEdBQS9CO01BQUEsSUFDQ3NjLEtBQUssR0FBR2hjLElBQUksQ0FBQ2djLEtBRGQ7TUFHQW9ULFFBQVEsR0FBR0EsUUFBUSxJQUFJTCxTQUFTLENBQUUvdUIsSUFBRixDQUFoQyxDQUp5QyxDQU16Qzs7TUFDQU4sR0FBRyxHQUFHMHZCLFFBQVEsR0FBR0EsUUFBUSxDQUFDRyxnQkFBVCxDQUEyQnZ1QixJQUEzQixLQUFxQ291QixRQUFRLENBQUVwdUIsSUFBRixDQUFoRCxHQUEyRFEsU0FBekUsQ0FQeUMsQ0FTekM7TUFDQTtNQUNBOztNQUNBLElBQUssQ0FBRTlCLEdBQUcsS0FBSyxFQUFSLElBQWNBLEdBQUcsS0FBSzhCLFNBQXhCLEtBQXVDLENBQUNwRCxNQUFNLENBQUN5SCxRQUFQLENBQWlCN0YsSUFBSSxDQUFDa0osYUFBdEIsRUFBcUNsSixJQUFyQyxDQUE3QyxFQUEyRjtRQUMxRk4sR0FBRyxHQUFHdEIsTUFBTSxDQUFDNGQsS0FBUCxDQUFjaGMsSUFBZCxFQUFvQmdCLElBQXBCLENBQU47TUFDQTs7TUFFRCxJQUFLb3VCLFFBQUwsRUFBZ0I7UUFFZjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUssQ0FBQ2x4QixPQUFPLENBQUNtd0IsZ0JBQVIsRUFBRCxJQUErQm5CLFNBQVMsQ0FBQ3pqQixJQUFWLENBQWdCL0osR0FBaEIsQ0FBL0IsSUFBd0R1dEIsT0FBTyxDQUFDeGpCLElBQVIsQ0FBY3pJLElBQWQsQ0FBN0QsRUFBb0Y7VUFFbkY7VUFDQW1kLEtBQUssR0FBR25DLEtBQUssQ0FBQ21DLEtBQWQ7VUFDQWtSLFFBQVEsR0FBR3JULEtBQUssQ0FBQ3FULFFBQWpCO1VBQ0FDLFFBQVEsR0FBR3RULEtBQUssQ0FBQ3NULFFBQWpCLENBTG1GLENBT25GOztVQUNBdFQsS0FBSyxDQUFDcVQsUUFBTixHQUFpQnJULEtBQUssQ0FBQ3NULFFBQU4sR0FBaUJ0VCxLQUFLLENBQUNtQyxLQUFOLEdBQWN6ZSxHQUFoRDtVQUNBQSxHQUFHLEdBQUcwdkIsUUFBUSxDQUFDalIsS0FBZixDQVRtRixDQVduRjs7VUFDQW5DLEtBQUssQ0FBQ21DLEtBQU4sR0FBY0EsS0FBZDtVQUNBbkMsS0FBSyxDQUFDcVQsUUFBTixHQUFpQkEsUUFBakI7VUFDQXJULEtBQUssQ0FBQ3NULFFBQU4sR0FBaUJBLFFBQWpCO1FBQ0E7TUFDRCxDQXpDd0MsQ0EyQ3pDO01BQ0E7OztNQUNBLE9BQU81dkIsR0FBRyxLQUFLOEIsU0FBUixHQUNOOUIsR0FETSxHQUVOQSxHQUFHLEdBQUcsRUFGUDtJQUdBLENBaEREO0VBaURBLENBaEVELE1BZ0VPLElBQUtnTSxlQUFlLENBQUM4akIsWUFBckIsRUFBb0M7SUFDMUNULFNBQVMsR0FBRyxtQkFBVS91QixJQUFWLEVBQWlCO01BQzVCLE9BQU9BLElBQUksQ0FBQ3d2QixZQUFaO0lBQ0EsQ0FGRDs7SUFJQVIsTUFBTSxHQUFHLGdCQUFVaHZCLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQm91QixRQUF0QixFQUFpQztNQUN6QyxJQUFJSyxJQUFKO01BQUEsSUFBVUMsRUFBVjtNQUFBLElBQWNDLE1BQWQ7TUFBQSxJQUFzQmp3QixHQUF0QjtNQUFBLElBQ0NzYyxLQUFLLEdBQUdoYyxJQUFJLENBQUNnYyxLQURkO01BR0FvVCxRQUFRLEdBQUdBLFFBQVEsSUFBSUwsU0FBUyxDQUFFL3VCLElBQUYsQ0FBaEM7TUFDQU4sR0FBRyxHQUFHMHZCLFFBQVEsR0FBR0EsUUFBUSxDQUFFcHVCLElBQUYsQ0FBWCxHQUFzQlEsU0FBcEMsQ0FMeUMsQ0FPekM7TUFDQTs7TUFDQSxJQUFLOUIsR0FBRyxJQUFJLElBQVAsSUFBZXNjLEtBQWYsSUFBd0JBLEtBQUssQ0FBRWhiLElBQUYsQ0FBbEMsRUFBNkM7UUFDNUN0QixHQUFHLEdBQUdzYyxLQUFLLENBQUVoYixJQUFGLENBQVg7TUFDQSxDQVh3QyxDQWF6QztNQUNBO01BRUE7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7TUFDQSxJQUFLa3NCLFNBQVMsQ0FBQ3pqQixJQUFWLENBQWdCL0osR0FBaEIsS0FBeUIsQ0FBQ3V2QixTQUFTLENBQUN4bEIsSUFBVixDQUFnQnpJLElBQWhCLENBQS9CLEVBQXdEO1FBRXZEO1FBQ0F5dUIsSUFBSSxHQUFHelQsS0FBSyxDQUFDeVQsSUFBYjtRQUNBQyxFQUFFLEdBQUcxdkIsSUFBSSxDQUFDNHZCLFlBQVY7UUFDQUQsTUFBTSxHQUFHRCxFQUFFLElBQUlBLEVBQUUsQ0FBQ0QsSUFBbEIsQ0FMdUQsQ0FPdkQ7O1FBQ0EsSUFBS0UsTUFBTCxFQUFjO1VBQ2JELEVBQUUsQ0FBQ0QsSUFBSCxHQUFVenZCLElBQUksQ0FBQ3d2QixZQUFMLENBQWtCQyxJQUE1QjtRQUNBOztRQUNEelQsS0FBSyxDQUFDeVQsSUFBTixHQUFhenVCLElBQUksS0FBSyxVQUFULEdBQXNCLEtBQXRCLEdBQThCdEIsR0FBM0M7UUFDQUEsR0FBRyxHQUFHc2MsS0FBSyxDQUFDNlQsU0FBTixHQUFrQixJQUF4QixDQVp1RCxDQWN2RDs7UUFDQTdULEtBQUssQ0FBQ3lULElBQU4sR0FBYUEsSUFBYjs7UUFDQSxJQUFLRSxNQUFMLEVBQWM7VUFDYkQsRUFBRSxDQUFDRCxJQUFILEdBQVVFLE1BQVY7UUFDQTtNQUNELENBekN3QyxDQTJDekM7TUFDQTs7O01BQ0EsT0FBT2p3QixHQUFHLEtBQUs4QixTQUFSLEdBQ045QixHQURNLEdBRU5BLEdBQUcsR0FBRyxFQUFOLElBQVksTUFGYjtJQUdBLENBaEREO0VBaURBOztFQUtELFNBQVNvd0IsWUFBVCxDQUF1QkMsV0FBdkIsRUFBb0NDLE1BQXBDLEVBQTZDO0lBRTVDO0lBQ0EsT0FBTztNQUNOMXdCLEdBQUcsRUFBRSxlQUFXO1FBQ2YsSUFBS3l3QixXQUFXLEVBQWhCLEVBQXFCO1VBRXBCO1VBQ0E7VUFDQSxPQUFPLEtBQUt6d0IsR0FBWjtVQUNBO1FBQ0EsQ0FQYyxDQVNmOzs7UUFDQSxPQUFPLENBQUUsS0FBS0EsR0FBTCxHQUFXMHdCLE1BQWIsRUFBc0I5dkIsS0FBdEIsQ0FBNkIsSUFBN0IsRUFBbUNDLFNBQW5DLENBQVA7TUFDQTtJQVpLLENBQVA7RUFjQTs7RUFHRCxJQUVFOHZCLE1BQU0sR0FBRyxpQkFGWDtFQUFBLElBR0NDLFFBQVEsR0FBRyx3QkFIWjtFQUFBLElBS0M7RUFDQTtFQUNBO0VBQ0E7RUFDQUMsWUFBWSxHQUFHLDJCQVRoQjtFQUFBLElBVUNDLFNBQVMsR0FBRyxJQUFJbHBCLE1BQUosQ0FBWSxPQUFPa1gsSUFBUCxHQUFjLFFBQTFCLEVBQW9DLEdBQXBDLENBVmI7RUFBQSxJQVlDaVMsT0FBTyxHQUFHO0lBQUVDLFFBQVEsRUFBRSxVQUFaO0lBQXdCQyxVQUFVLEVBQUUsUUFBcEM7SUFBOEMxRCxPQUFPLEVBQUU7RUFBdkQsQ0FaWDtFQUFBLElBYUMyRCxrQkFBa0IsR0FBRztJQUNwQkMsYUFBYSxFQUFFLEdBREs7SUFFcEJDLFVBQVUsRUFBRTtFQUZRLENBYnRCO0VBQUEsSUFrQkNDLFdBQVcsR0FBRyxDQUFFLFFBQUYsRUFBWSxHQUFaLEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLENBbEJmO0VBQUEsSUFtQkNDLFVBQVUsR0FBR3h6QixRQUFRLENBQUNzTixhQUFULENBQXdCLEtBQXhCLEVBQWdDc1IsS0FuQjlDLENBaHBOOEUsQ0FzcU45RTs7RUFDQSxTQUFTNlUsY0FBVCxDQUF5Qjd2QixJQUF6QixFQUFnQztJQUUvQjtJQUNBLElBQUtBLElBQUksSUFBSTR2QixVQUFiLEVBQTBCO01BQ3pCLE9BQU81dkIsSUFBUDtJQUNBLENBTDhCLENBTy9COzs7SUFDQSxJQUFJOHZCLE9BQU8sR0FBRzl2QixJQUFJLENBQUNnVixNQUFMLENBQWEsQ0FBYixFQUFpQmpYLFdBQWpCLEtBQWlDaUMsSUFBSSxDQUFDdEQsS0FBTCxDQUFZLENBQVosQ0FBL0M7SUFBQSxJQUNDdUMsQ0FBQyxHQUFHMHdCLFdBQVcsQ0FBQ3h4QixNQURqQjs7SUFHQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztNQUNiZSxJQUFJLEdBQUcydkIsV0FBVyxDQUFFMXdCLENBQUYsQ0FBWCxHQUFtQjZ3QixPQUExQjs7TUFDQSxJQUFLOXZCLElBQUksSUFBSTR2QixVQUFiLEVBQTBCO1FBQ3pCLE9BQU81dkIsSUFBUDtNQUNBO0lBQ0Q7RUFDRDs7RUFFRCxTQUFTK3ZCLFFBQVQsQ0FBbUJoakIsUUFBbkIsRUFBNkJpakIsSUFBN0IsRUFBb0M7SUFDbkMsSUFBSW5FLE9BQUo7SUFBQSxJQUFhN3NCLElBQWI7SUFBQSxJQUFtQml4QixNQUFuQjtJQUFBLElBQ0MzVyxNQUFNLEdBQUcsRUFEVjtJQUFBLElBRUN4RCxLQUFLLEdBQUcsQ0FGVDtJQUFBLElBR0MzWCxNQUFNLEdBQUc0TyxRQUFRLENBQUM1TyxNQUhuQjs7SUFLQSxPQUFRMlgsS0FBSyxHQUFHM1gsTUFBaEIsRUFBd0IyWCxLQUFLLEVBQTdCLEVBQWtDO01BQ2pDOVcsSUFBSSxHQUFHK04sUUFBUSxDQUFFK0ksS0FBRixDQUFmOztNQUNBLElBQUssQ0FBQzlXLElBQUksQ0FBQ2djLEtBQVgsRUFBbUI7UUFDbEI7TUFDQTs7TUFFRDFCLE1BQU0sQ0FBRXhELEtBQUYsQ0FBTixHQUFrQjFZLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsRUFBb0IsWUFBcEIsQ0FBbEI7TUFDQTZzQixPQUFPLEdBQUc3c0IsSUFBSSxDQUFDZ2MsS0FBTCxDQUFXNlEsT0FBckI7O01BQ0EsSUFBS21FLElBQUwsRUFBWTtRQUVYO1FBQ0E7UUFDQSxJQUFLLENBQUMxVyxNQUFNLENBQUV4RCxLQUFGLENBQVAsSUFBb0IrVixPQUFPLEtBQUssTUFBckMsRUFBOEM7VUFDN0M3c0IsSUFBSSxDQUFDZ2MsS0FBTCxDQUFXNlEsT0FBWCxHQUFxQixFQUFyQjtRQUNBLENBTlUsQ0FRWDtRQUNBO1FBQ0E7OztRQUNBLElBQUs3c0IsSUFBSSxDQUFDZ2MsS0FBTCxDQUFXNlEsT0FBWCxLQUF1QixFQUF2QixJQUE2QnJPLFFBQVEsQ0FBRXhlLElBQUYsQ0FBMUMsRUFBcUQ7VUFDcERzYSxNQUFNLENBQUV4RCxLQUFGLENBQU4sR0FDQzFZLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsRUFBb0IsWUFBcEIsRUFBa0M4c0IsY0FBYyxDQUFFOXNCLElBQUksQ0FBQ21ELFFBQVAsQ0FBaEQsQ0FERDtRQUVBO01BQ0QsQ0FmRCxNQWVPO1FBQ044dEIsTUFBTSxHQUFHelMsUUFBUSxDQUFFeGUsSUFBRixDQUFqQjs7UUFFQSxJQUFLNnNCLE9BQU8sSUFBSUEsT0FBTyxLQUFLLE1BQXZCLElBQWlDLENBQUNvRSxNQUF2QyxFQUFnRDtVQUMvQzd5QixNQUFNLENBQUNrZixLQUFQLENBQ0N0ZCxJQURELEVBRUMsWUFGRCxFQUdDaXhCLE1BQU0sR0FBR3BFLE9BQUgsR0FBYXp1QixNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQixTQUFsQixDQUhwQjtRQUtBO01BQ0Q7SUFDRCxDQXhDa0MsQ0EwQ25DO0lBQ0E7OztJQUNBLEtBQU04VyxLQUFLLEdBQUcsQ0FBZCxFQUFpQkEsS0FBSyxHQUFHM1gsTUFBekIsRUFBaUMyWCxLQUFLLEVBQXRDLEVBQTJDO01BQzFDOVcsSUFBSSxHQUFHK04sUUFBUSxDQUFFK0ksS0FBRixDQUFmOztNQUNBLElBQUssQ0FBQzlXLElBQUksQ0FBQ2djLEtBQVgsRUFBbUI7UUFDbEI7TUFDQTs7TUFDRCxJQUFLLENBQUNnVixJQUFELElBQVNoeEIsSUFBSSxDQUFDZ2MsS0FBTCxDQUFXNlEsT0FBWCxLQUF1QixNQUFoQyxJQUEwQzdzQixJQUFJLENBQUNnYyxLQUFMLENBQVc2USxPQUFYLEtBQXVCLEVBQXRFLEVBQTJFO1FBQzFFN3NCLElBQUksQ0FBQ2djLEtBQUwsQ0FBVzZRLE9BQVgsR0FBcUJtRSxJQUFJLEdBQUcxVyxNQUFNLENBQUV4RCxLQUFGLENBQU4sSUFBbUIsRUFBdEIsR0FBMkIsTUFBcEQ7TUFDQTtJQUNEOztJQUVELE9BQU8vSSxRQUFQO0VBQ0E7O0VBRUQsU0FBU21qQixpQkFBVCxDQUE0Qmx4QixJQUE1QixFQUFrQ29FLEtBQWxDLEVBQXlDK3NCLFFBQXpDLEVBQW9EO0lBQ25ELElBQUlsdEIsT0FBTyxHQUFHbXNCLFNBQVMsQ0FBQ2puQixJQUFWLENBQWdCL0UsS0FBaEIsQ0FBZDtJQUNBLE9BQU9ILE9BQU8sR0FFYjtJQUNBdkMsSUFBSSxDQUFDa0MsR0FBTCxDQUFVLENBQVYsRUFBYUssT0FBTyxDQUFFLENBQUYsQ0FBUCxJQUFpQmt0QixRQUFRLElBQUksQ0FBN0IsQ0FBYixLQUFvRGx0QixPQUFPLENBQUUsQ0FBRixDQUFQLElBQWdCLElBQXBFLENBSGEsR0FJYkcsS0FKRDtFQUtBOztFQUVELFNBQVNndEIsb0JBQVQsQ0FBK0JweEIsSUFBL0IsRUFBcUNnQixJQUFyQyxFQUEyQ3F3QixLQUEzQyxFQUFrREMsV0FBbEQsRUFBK0RDLE1BQS9ELEVBQXdFO0lBQ3ZFLElBQUl0eEIsQ0FBQyxHQUFHb3hCLEtBQUssTUFBT0MsV0FBVyxHQUFHLFFBQUgsR0FBYyxTQUFoQyxDQUFMLEdBRVA7SUFDQSxDQUhPLEdBS1A7SUFDQXR3QixJQUFJLEtBQUssT0FBVCxHQUFtQixDQUFuQixHQUF1QixDQU54QjtJQUFBLElBUUNpTixHQUFHLEdBQUcsQ0FSUDs7SUFVQSxPQUFRaE8sQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxJQUFJLENBQXBCLEVBQXdCO01BRXZCO01BQ0EsSUFBS294QixLQUFLLEtBQUssUUFBZixFQUEwQjtRQUN6QnBqQixHQUFHLElBQUk3UCxNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQnF4QixLQUFLLEdBQUc5UyxTQUFTLENBQUV0ZSxDQUFGLENBQW5DLEVBQTBDLElBQTFDLEVBQWdEc3hCLE1BQWhELENBQVA7TUFDQTs7TUFFRCxJQUFLRCxXQUFMLEVBQW1CO1FBRWxCO1FBQ0EsSUFBS0QsS0FBSyxLQUFLLFNBQWYsRUFBMkI7VUFDMUJwakIsR0FBRyxJQUFJN1AsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsWUFBWXVlLFNBQVMsQ0FBRXRlLENBQUYsQ0FBdkMsRUFBOEMsSUFBOUMsRUFBb0RzeEIsTUFBcEQsQ0FBUDtRQUNBLENBTGlCLENBT2xCOzs7UUFDQSxJQUFLRixLQUFLLEtBQUssUUFBZixFQUEwQjtVQUN6QnBqQixHQUFHLElBQUk3UCxNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQixXQUFXdWUsU0FBUyxDQUFFdGUsQ0FBRixDQUFwQixHQUE0QixPQUE5QyxFQUF1RCxJQUF2RCxFQUE2RHN4QixNQUE3RCxDQUFQO1FBQ0E7TUFDRCxDQVhELE1BV087UUFFTjtRQUNBdGpCLEdBQUcsSUFBSTdQLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFlBQVl1ZSxTQUFTLENBQUV0ZSxDQUFGLENBQXZDLEVBQThDLElBQTlDLEVBQW9Ec3hCLE1BQXBELENBQVAsQ0FITSxDQUtOOztRQUNBLElBQUtGLEtBQUssS0FBSyxTQUFmLEVBQTJCO1VBQzFCcGpCLEdBQUcsSUFBSTdQLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFdBQVd1ZSxTQUFTLENBQUV0ZSxDQUFGLENBQXBCLEdBQTRCLE9BQTlDLEVBQXVELElBQXZELEVBQTZEc3hCLE1BQTdELENBQVA7UUFDQTtNQUNEO0lBQ0Q7O0lBRUQsT0FBT3RqQixHQUFQO0VBQ0E7O0VBRUQsU0FBU3VqQixnQkFBVCxDQUEyQnh4QixJQUEzQixFQUFpQ2dCLElBQWpDLEVBQXVDcXdCLEtBQXZDLEVBQStDO0lBRTlDO0lBQ0EsSUFBSUksZ0JBQWdCLEdBQUcsSUFBdkI7SUFBQSxJQUNDeGpCLEdBQUcsR0FBR2pOLElBQUksS0FBSyxPQUFULEdBQW1CaEIsSUFBSSxDQUFDbWMsV0FBeEIsR0FBc0NuYyxJQUFJLENBQUM4dUIsWUFEbEQ7SUFBQSxJQUVDeUMsTUFBTSxHQUFHeEMsU0FBUyxDQUFFL3VCLElBQUYsQ0FGbkI7SUFBQSxJQUdDc3hCLFdBQVcsR0FBR3B6QixPQUFPLENBQUM2dkIsU0FBUixJQUNiM3ZCLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFdBQWxCLEVBQStCLEtBQS9CLEVBQXNDdXhCLE1BQXRDLE1BQW1ELFlBSnJELENBSDhDLENBUzlDO0lBQ0E7SUFDQTs7SUFDQSxJQUFLbjBCLFFBQVEsQ0FBQ3MwQixtQkFBVCxJQUFnQ24wQixNQUFNLENBQUN5TyxHQUFQLEtBQWV6TyxNQUFwRCxFQUE2RDtNQUU1RDtNQUNBO01BQ0E7TUFDQSxJQUFLeUMsSUFBSSxDQUFDNnVCLGNBQUwsR0FBc0IxdkIsTUFBM0IsRUFBb0M7UUFDbkM4TyxHQUFHLEdBQUd2TSxJQUFJLENBQUNpd0IsS0FBTCxDQUFZM3hCLElBQUksQ0FBQzR4QixxQkFBTCxHQUE4QjV3QixJQUE5QixJQUF1QyxHQUFuRCxDQUFOO01BQ0E7SUFDRCxDQXBCNkMsQ0FzQjlDO0lBQ0E7SUFDQTs7O0lBQ0EsSUFBS2lOLEdBQUcsSUFBSSxDQUFQLElBQVlBLEdBQUcsSUFBSSxJQUF4QixFQUErQjtNQUU5QjtNQUNBQSxHQUFHLEdBQUcrZ0IsTUFBTSxDQUFFaHZCLElBQUYsRUFBUWdCLElBQVIsRUFBY3V3QixNQUFkLENBQVo7O01BQ0EsSUFBS3RqQixHQUFHLEdBQUcsQ0FBTixJQUFXQSxHQUFHLElBQUksSUFBdkIsRUFBOEI7UUFDN0JBLEdBQUcsR0FBR2pPLElBQUksQ0FBQ2djLEtBQUwsQ0FBWWhiLElBQVosQ0FBTjtNQUNBLENBTjZCLENBUTlCOzs7TUFDQSxJQUFLa3NCLFNBQVMsQ0FBQ3pqQixJQUFWLENBQWdCd0UsR0FBaEIsQ0FBTCxFQUE2QjtRQUM1QixPQUFPQSxHQUFQO01BQ0EsQ0FYNkIsQ0FhOUI7TUFDQTs7O01BQ0F3akIsZ0JBQWdCLEdBQUdILFdBQVcsS0FDM0JwekIsT0FBTyxDQUFDa3dCLGlCQUFSLE1BQStCbmdCLEdBQUcsS0FBS2pPLElBQUksQ0FBQ2djLEtBQUwsQ0FBWWhiLElBQVosQ0FEWixDQUE5QixDQWY4QixDQWtCOUI7O01BQ0FpTixHQUFHLEdBQUcxTCxVQUFVLENBQUUwTCxHQUFGLENBQVYsSUFBcUIsQ0FBM0I7SUFDQSxDQTdDNkMsQ0ErQzlDOzs7SUFDQSxPQUFTQSxHQUFHLEdBQ1htakIsb0JBQW9CLENBQ25CcHhCLElBRG1CLEVBRW5CZ0IsSUFGbUIsRUFHbkJxd0IsS0FBSyxLQUFNQyxXQUFXLEdBQUcsUUFBSCxHQUFjLFNBQS9CLENBSGMsRUFJbkJHLGdCQUptQixFQUtuQkYsTUFMbUIsQ0FEZCxHQVFILElBUko7RUFTQTs7RUFFRG56QixNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFFZDtJQUNBO0lBQ0FpeEIsUUFBUSxFQUFFO01BQ1RsRSxPQUFPLEVBQUU7UUFDUnJ1QixHQUFHLEVBQUUsYUFBVVUsSUFBVixFQUFnQm92QixRQUFoQixFQUEyQjtVQUMvQixJQUFLQSxRQUFMLEVBQWdCO1lBRWY7WUFDQSxJQUFJMXZCLEdBQUcsR0FBR3N2QixNQUFNLENBQUVodkIsSUFBRixFQUFRLFNBQVIsQ0FBaEI7WUFDQSxPQUFPTixHQUFHLEtBQUssRUFBUixHQUFhLEdBQWIsR0FBbUJBLEdBQTFCO1VBQ0E7UUFDRDtNQVJPO0lBREEsQ0FKSTtJQWlCZDtJQUNBMmYsU0FBUyxFQUFFO01BQ1YsMkJBQTJCLElBRGpCO01BRVYsZUFBZSxJQUZMO01BR1YsZUFBZSxJQUhMO01BSVYsWUFBWSxJQUpGO01BS1YsY0FBYyxJQUxKO01BTVYsY0FBYyxJQU5KO01BT1YsY0FBYyxJQVBKO01BUVYsV0FBVyxJQVJEO01BU1YsU0FBUyxJQVRDO01BVVYsV0FBVyxJQVZEO01BV1YsVUFBVSxJQVhBO01BWVYsVUFBVSxJQVpBO01BYVYsUUFBUTtJQWJFLENBbEJHO0lBa0NkO0lBQ0E7SUFDQXlTLFFBQVEsRUFBRTtNQUVUO01BQ0EsU0FBUzV6QixPQUFPLENBQUMwdkIsUUFBUixHQUFtQixVQUFuQixHQUFnQztJQUhoQyxDQXBDSTtJQTBDZDtJQUNBNVIsS0FBSyxFQUFFLGVBQVVoYyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0JvRCxLQUF0QixFQUE2Qml0QixLQUE3QixFQUFxQztNQUUzQztNQUNBLElBQUssQ0FBQ3J4QixJQUFELElBQVNBLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBM0IsSUFBZ0MxQyxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxELElBQXVELENBQUMxQyxJQUFJLENBQUNnYyxLQUFsRSxFQUEwRTtRQUN6RTtNQUNBLENBTDBDLENBTzNDOzs7TUFDQSxJQUFJdGMsR0FBSjtNQUFBLElBQVN3QyxJQUFUO01BQUEsSUFBZXdiLEtBQWY7TUFBQSxJQUNDcVUsUUFBUSxHQUFHM3pCLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0JqQyxJQUFsQixDQURaO01BQUEsSUFFQ2diLEtBQUssR0FBR2hjLElBQUksQ0FBQ2djLEtBRmQ7TUFJQWhiLElBQUksR0FBRzVDLE1BQU0sQ0FBQzB6QixRQUFQLENBQWlCQyxRQUFqQixNQUNKM3pCLE1BQU0sQ0FBQzB6QixRQUFQLENBQWlCQyxRQUFqQixJQUE4QmxCLGNBQWMsQ0FBRWtCLFFBQUYsQ0FBZCxJQUE4QkEsUUFEeEQsQ0FBUCxDQVoyQyxDQWUzQztNQUNBOztNQUNBclUsS0FBSyxHQUFHdGYsTUFBTSxDQUFDeXpCLFFBQVAsQ0FBaUI3d0IsSUFBakIsS0FBMkI1QyxNQUFNLENBQUN5ekIsUUFBUCxDQUFpQkUsUUFBakIsQ0FBbkMsQ0FqQjJDLENBbUIzQzs7TUFDQSxJQUFLM3RCLEtBQUssS0FBSzVDLFNBQWYsRUFBMkI7UUFDMUJVLElBQUksV0FBVWtDLEtBQVYsQ0FBSixDQUQwQixDQUcxQjs7UUFDQSxJQUFLbEMsSUFBSSxLQUFLLFFBQVQsS0FBdUJ4QyxHQUFHLEdBQUc0ZSxPQUFPLENBQUNuVixJQUFSLENBQWMvRSxLQUFkLENBQTdCLEtBQXdEMUUsR0FBRyxDQUFFLENBQUYsQ0FBaEUsRUFBd0U7VUFDdkUwRSxLQUFLLEdBQUd1YSxTQUFTLENBQUUzZSxJQUFGLEVBQVFnQixJQUFSLEVBQWN0QixHQUFkLENBQWpCLENBRHVFLENBR3ZFOztVQUNBd0MsSUFBSSxHQUFHLFFBQVA7UUFDQSxDQVR5QixDQVcxQjs7O1FBQ0EsSUFBS2tDLEtBQUssSUFBSSxJQUFULElBQWlCQSxLQUFLLEtBQUtBLEtBQWhDLEVBQXdDO1VBQ3ZDO1FBQ0EsQ0FkeUIsQ0FnQjFCOzs7UUFDQSxJQUFLbEMsSUFBSSxLQUFLLFFBQWQsRUFBeUI7VUFDeEJrQyxLQUFLLElBQUkxRSxHQUFHLElBQUlBLEdBQUcsQ0FBRSxDQUFGLENBQVYsS0FBcUJ0QixNQUFNLENBQUNpaEIsU0FBUCxDQUFrQjBTLFFBQWxCLElBQStCLEVBQS9CLEdBQW9DLElBQXpELENBQVQ7UUFDQSxDQW5CeUIsQ0FxQjFCO1FBQ0E7UUFDQTs7O1FBQ0EsSUFBSyxDQUFDN3pCLE9BQU8sQ0FBQzR2QixlQUFULElBQTRCMXBCLEtBQUssS0FBSyxFQUF0QyxJQUE0Q3BELElBQUksQ0FBQ25ELE9BQUwsQ0FBYyxZQUFkLE1BQWlDLENBQWxGLEVBQXNGO1VBQ3JGbWUsS0FBSyxDQUFFaGIsSUFBRixDQUFMLEdBQWdCLFNBQWhCO1FBQ0EsQ0ExQnlCLENBNEIxQjs7O1FBQ0EsSUFBSyxDQUFDMGMsS0FBRCxJQUFVLEVBQUcsU0FBU0EsS0FBWixDQUFWLElBQ0osQ0FBRXRaLEtBQUssR0FBR3NaLEtBQUssQ0FBQ3NVLEdBQU4sQ0FBV2h5QixJQUFYLEVBQWlCb0UsS0FBakIsRUFBd0JpdEIsS0FBeEIsQ0FBVixNQUFnRDd2QixTQURqRCxFQUM2RDtVQUU1RDtVQUNBO1VBQ0EsSUFBSTtZQUNId2EsS0FBSyxDQUFFaGIsSUFBRixDQUFMLEdBQWdCb0QsS0FBaEI7VUFDQSxDQUZELENBRUUsT0FBUXpCLENBQVIsRUFBWSxDQUFFO1FBQ2hCO01BRUQsQ0F2Q0QsTUF1Q087UUFFTjtRQUNBLElBQUsrYSxLQUFLLElBQUksU0FBU0EsS0FBbEIsSUFDSixDQUFFaGUsR0FBRyxHQUFHZ2UsS0FBSyxDQUFDcGUsR0FBTixDQUFXVSxJQUFYLEVBQWlCLEtBQWpCLEVBQXdCcXhCLEtBQXhCLENBQVIsTUFBOEM3dkIsU0FEL0MsRUFDMkQ7VUFFMUQsT0FBTzlCLEdBQVA7UUFDQSxDQVBLLENBU047OztRQUNBLE9BQU9zYyxLQUFLLENBQUVoYixJQUFGLENBQVo7TUFDQTtJQUNELENBbEhhO0lBb0hkMGQsR0FBRyxFQUFFLGFBQVUxZSxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0Jxd0IsS0FBdEIsRUFBNkJFLE1BQTdCLEVBQXNDO01BQzFDLElBQUloeUIsR0FBSjtNQUFBLElBQVMwTyxHQUFUO01BQUEsSUFBY3lQLEtBQWQ7TUFBQSxJQUNDcVUsUUFBUSxHQUFHM3pCLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0JqQyxJQUFsQixDQURaLENBRDBDLENBSTFDOztNQUNBQSxJQUFJLEdBQUc1QyxNQUFNLENBQUMwekIsUUFBUCxDQUFpQkMsUUFBakIsTUFDSjN6QixNQUFNLENBQUMwekIsUUFBUCxDQUFpQkMsUUFBakIsSUFBOEJsQixjQUFjLENBQUVrQixRQUFGLENBQWQsSUFBOEJBLFFBRHhELENBQVAsQ0FMMEMsQ0FRMUM7TUFDQTs7TUFDQXJVLEtBQUssR0FBR3RmLE1BQU0sQ0FBQ3l6QixRQUFQLENBQWlCN3dCLElBQWpCLEtBQTJCNUMsTUFBTSxDQUFDeXpCLFFBQVAsQ0FBaUJFLFFBQWpCLENBQW5DLENBVjBDLENBWTFDOztNQUNBLElBQUtyVSxLQUFLLElBQUksU0FBU0EsS0FBdkIsRUFBK0I7UUFDOUJ6UCxHQUFHLEdBQUd5UCxLQUFLLENBQUNwZSxHQUFOLENBQVdVLElBQVgsRUFBaUIsSUFBakIsRUFBdUJxeEIsS0FBdkIsQ0FBTjtNQUNBLENBZnlDLENBaUIxQzs7O01BQ0EsSUFBS3BqQixHQUFHLEtBQUt6TSxTQUFiLEVBQXlCO1FBQ3hCeU0sR0FBRyxHQUFHK2dCLE1BQU0sQ0FBRWh2QixJQUFGLEVBQVFnQixJQUFSLEVBQWN1d0IsTUFBZCxDQUFaO01BQ0EsQ0FwQnlDLENBc0IxQzs7O01BQ0EsSUFBS3RqQixHQUFHLEtBQUssUUFBUixJQUFvQmpOLElBQUksSUFBSXd2QixrQkFBakMsRUFBc0Q7UUFDckR2aUIsR0FBRyxHQUFHdWlCLGtCQUFrQixDQUFFeHZCLElBQUYsQ0FBeEI7TUFDQSxDQXpCeUMsQ0EyQjFDOzs7TUFDQSxJQUFLcXdCLEtBQUssS0FBSyxFQUFWLElBQWdCQSxLQUFyQixFQUE2QjtRQUM1Qjl4QixHQUFHLEdBQUdnRCxVQUFVLENBQUUwTCxHQUFGLENBQWhCO1FBQ0EsT0FBT29qQixLQUFLLEtBQUssSUFBVixJQUFrQlksUUFBUSxDQUFFMXlCLEdBQUYsQ0FBMUIsR0FBb0NBLEdBQUcsSUFBSSxDQUEzQyxHQUErQzBPLEdBQXREO01BQ0E7O01BQ0QsT0FBT0EsR0FBUDtJQUNBO0VBckphLENBQWY7RUF3SkE3UCxNQUFNLENBQUN5QixJQUFQLENBQWEsQ0FBRSxRQUFGLEVBQVksT0FBWixDQUFiLEVBQW9DLFVBQVVJLENBQVYsRUFBYWUsSUFBYixFQUFvQjtJQUN2RDVDLE1BQU0sQ0FBQ3l6QixRQUFQLENBQWlCN3dCLElBQWpCLElBQTBCO01BQ3pCMUIsR0FBRyxFQUFFLGFBQVVVLElBQVYsRUFBZ0JvdkIsUUFBaEIsRUFBMEJpQyxLQUExQixFQUFrQztRQUN0QyxJQUFLakMsUUFBTCxFQUFnQjtVQUVmO1VBQ0E7VUFDQSxPQUFPZSxZQUFZLENBQUMxbUIsSUFBYixDQUFtQnJMLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFNBQWxCLENBQW5CLEtBQ05BLElBQUksQ0FBQ21jLFdBQUwsS0FBcUIsQ0FEZixHQUVMZ1IsSUFBSSxDQUFFbnRCLElBQUYsRUFBUXF3QixPQUFSLEVBQWlCLFlBQVc7WUFDL0IsT0FBT21CLGdCQUFnQixDQUFFeHhCLElBQUYsRUFBUWdCLElBQVIsRUFBY3F3QixLQUFkLENBQXZCO1VBQ0EsQ0FGRyxDQUZDLEdBS0xHLGdCQUFnQixDQUFFeHhCLElBQUYsRUFBUWdCLElBQVIsRUFBY3F3QixLQUFkLENBTGxCO1FBTUE7TUFDRCxDQWJ3QjtNQWV6QlcsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFnQm9FLEtBQWhCLEVBQXVCaXRCLEtBQXZCLEVBQStCO1FBQ25DLElBQUlFLE1BQU0sR0FBR0YsS0FBSyxJQUFJdEMsU0FBUyxDQUFFL3VCLElBQUYsQ0FBL0I7UUFDQSxPQUFPa3hCLGlCQUFpQixDQUFFbHhCLElBQUYsRUFBUW9FLEtBQVIsRUFBZWl0QixLQUFLLEdBQzNDRCxvQkFBb0IsQ0FDbkJweEIsSUFEbUIsRUFFbkJnQixJQUZtQixFQUduQnF3QixLQUhtQixFQUluQm56QixPQUFPLENBQUM2dkIsU0FBUixJQUNDM3ZCLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFdBQWxCLEVBQStCLEtBQS9CLEVBQXNDdXhCLE1BQXRDLE1BQW1ELFlBTGpDLEVBTW5CQSxNQU5tQixDQUR1QixHQVF2QyxDQVJtQixDQUF4QjtNQVVBO0lBM0J3QixDQUExQjtFQTZCQSxDQTlCRDs7RUFnQ0EsSUFBSyxDQUFDcnpCLE9BQU8sQ0FBQ3l2QixPQUFkLEVBQXdCO0lBQ3ZCdnZCLE1BQU0sQ0FBQ3l6QixRQUFQLENBQWdCbEUsT0FBaEIsR0FBMEI7TUFDekJydUIsR0FBRyxFQUFFLGFBQVVVLElBQVYsRUFBZ0JvdkIsUUFBaEIsRUFBMkI7UUFFL0I7UUFDQSxPQUFPYyxRQUFRLENBQUN6bUIsSUFBVCxDQUFlLENBQUUybEIsUUFBUSxJQUFJcHZCLElBQUksQ0FBQ3d2QixZQUFqQixHQUN2Qnh2QixJQUFJLENBQUN3dkIsWUFBTCxDQUFrQi9pQixNQURLLEdBRXZCek0sSUFBSSxDQUFDZ2MsS0FBTCxDQUFXdlAsTUFGVSxLQUVFLEVBRmpCLElBR0gsT0FBT2xLLFVBQVUsQ0FBRTJFLE1BQU0sQ0FBQ2dyQixFQUFULENBQW5CLEdBQXFDLEVBSGhDLEdBSUw5QyxRQUFRLEdBQUcsR0FBSCxHQUFTLEVBSm5CO01BS0EsQ0FUd0I7TUFXekI0QyxHQUFHLEVBQUUsYUFBVWh5QixJQUFWLEVBQWdCb0UsS0FBaEIsRUFBd0I7UUFDNUIsSUFBSTRYLEtBQUssR0FBR2hjLElBQUksQ0FBQ2djLEtBQWpCO1FBQUEsSUFDQ3dULFlBQVksR0FBR3h2QixJQUFJLENBQUN3dkIsWUFEckI7UUFBQSxJQUVDN0IsT0FBTyxHQUFHdnZCLE1BQU0sQ0FBQ2lFLFNBQVAsQ0FBa0IrQixLQUFsQixJQUE0QixtQkFBbUJBLEtBQUssR0FBRyxHQUEzQixHQUFpQyxHQUE3RCxHQUFtRSxFQUY5RTtRQUFBLElBR0NxSSxNQUFNLEdBQUcraUIsWUFBWSxJQUFJQSxZQUFZLENBQUMvaUIsTUFBN0IsSUFBdUN1UCxLQUFLLENBQUN2UCxNQUE3QyxJQUF1RCxFQUhqRSxDQUQ0QixDQU01QjtRQUNBOztRQUNBdVAsS0FBSyxDQUFDRSxJQUFOLEdBQWEsQ0FBYixDQVI0QixDQVU1QjtRQUNBO1FBQ0E7O1FBQ0EsSUFBSyxDQUFFOVgsS0FBSyxJQUFJLENBQVQsSUFBY0EsS0FBSyxLQUFLLEVBQTFCLEtBQ0hoRyxNQUFNLENBQUMyRSxJQUFQLENBQWEwSixNQUFNLENBQUM3SyxPQUFQLENBQWdCcXVCLE1BQWhCLEVBQXdCLEVBQXhCLENBQWIsTUFBZ0QsRUFEN0MsSUFFSGpVLEtBQUssQ0FBQzlSLGVBRlIsRUFFMEI7VUFFekI7VUFDQTtVQUNBO1VBQ0E4UixLQUFLLENBQUM5UixlQUFOLENBQXVCLFFBQXZCLEVBTHlCLENBT3pCO1VBQ0E7O1VBQ0EsSUFBSzlGLEtBQUssS0FBSyxFQUFWLElBQWdCb3JCLFlBQVksSUFBSSxDQUFDQSxZQUFZLENBQUMvaUIsTUFBbkQsRUFBNEQ7WUFDM0Q7VUFDQTtRQUNELENBM0IyQixDQTZCNUI7OztRQUNBdVAsS0FBSyxDQUFDdlAsTUFBTixHQUFld2pCLE1BQU0sQ0FBQ3htQixJQUFQLENBQWFnRCxNQUFiLElBQ2RBLE1BQU0sQ0FBQzdLLE9BQVAsQ0FBZ0JxdUIsTUFBaEIsRUFBd0J0QyxPQUF4QixDQURjLEdBRWRsaEIsTUFBTSxHQUFHLEdBQVQsR0FBZWtoQixPQUZoQjtNQUdBO0lBNUN3QixDQUExQjtFQThDQTs7RUFFRHZ2QixNQUFNLENBQUN5ekIsUUFBUCxDQUFnQmpELFdBQWhCLEdBQThCa0IsWUFBWSxDQUFFNXhCLE9BQU8sQ0FBQ3F3QixtQkFBVixFQUN6QyxVQUFVdnVCLElBQVYsRUFBZ0JvdkIsUUFBaEIsRUFBMkI7SUFDMUIsSUFBS0EsUUFBTCxFQUFnQjtNQUNmLE9BQU9qQyxJQUFJLENBQUVudEIsSUFBRixFQUFRO1FBQUUsV0FBVztNQUFiLENBQVIsRUFDVmd2QixNQURVLEVBQ0YsQ0FBRWh2QixJQUFGLEVBQVEsYUFBUixDQURFLENBQVg7SUFFQTtFQUNELENBTndDLENBQTFDO0VBU0E1QixNQUFNLENBQUN5ekIsUUFBUCxDQUFnQmxELFVBQWhCLEdBQTZCbUIsWUFBWSxDQUFFNXhCLE9BQU8sQ0FBQ3N3QixrQkFBVixFQUN4QyxVQUFVeHVCLElBQVYsRUFBZ0JvdkIsUUFBaEIsRUFBMkI7SUFDMUIsSUFBS0EsUUFBTCxFQUFnQjtNQUNmLE9BQU8sQ0FDTjdzQixVQUFVLENBQUV5c0IsTUFBTSxDQUFFaHZCLElBQUYsRUFBUSxZQUFSLENBQVIsQ0FBVixNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0U1QixNQUFNLENBQUN5SCxRQUFQLENBQWlCN0YsSUFBSSxDQUFDa0osYUFBdEIsRUFBcUNsSixJQUFyQyxJQUNEQSxJQUFJLENBQUM0eEIscUJBQUwsR0FBNkJuQyxJQUE3QixHQUNDdEMsSUFBSSxDQUFFbnRCLElBQUYsRUFBUTtRQUFFMnVCLFVBQVUsRUFBRTtNQUFkLENBQVIsRUFBMkIsWUFBVztRQUN6QyxPQUFPM3VCLElBQUksQ0FBQzR4QixxQkFBTCxHQUE2Qm5DLElBQXBDO01BQ0EsQ0FGRyxDQUZKLEdBS0QsQ0FYRCxDQURNLElBY0gsSUFkSjtJQWVBO0VBQ0QsQ0FuQnVDLENBQXpDLENBcmxPOEUsQ0EybU85RTs7RUFDQXJ4QixNQUFNLENBQUN5QixJQUFQLENBQWE7SUFDWnN5QixNQUFNLEVBQUUsRUFESTtJQUVaQyxPQUFPLEVBQUUsRUFGRztJQUdaQyxNQUFNLEVBQUU7RUFISSxDQUFiLEVBSUcsVUFBVUMsTUFBVixFQUFrQkMsTUFBbEIsRUFBMkI7SUFDN0JuMEIsTUFBTSxDQUFDeXpCLFFBQVAsQ0FBaUJTLE1BQU0sR0FBR0MsTUFBMUIsSUFBcUM7TUFDcENDLE1BQU0sRUFBRSxnQkFBVXB1QixLQUFWLEVBQWtCO1FBQ3pCLElBQUluRSxDQUFDLEdBQUcsQ0FBUjtRQUFBLElBQ0N3eUIsUUFBUSxHQUFHLEVBRFo7UUFBQSxJQUdDO1FBQ0FDLEtBQUssR0FBRyxPQUFPdHVCLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQUssQ0FBQ1MsS0FBTixDQUFhLEdBQWIsQ0FBNUIsR0FBaUQsQ0FBRVQsS0FBRixDQUoxRDs7UUFNQSxPQUFRbkUsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxFQUFoQixFQUFxQjtVQUNwQnd5QixRQUFRLENBQUVILE1BQU0sR0FBRy9ULFNBQVMsQ0FBRXRlLENBQUYsQ0FBbEIsR0FBMEJzeUIsTUFBNUIsQ0FBUixHQUNDRyxLQUFLLENBQUV6eUIsQ0FBRixDQUFMLElBQWN5eUIsS0FBSyxDQUFFenlCLENBQUMsR0FBRyxDQUFOLENBQW5CLElBQWdDeXlCLEtBQUssQ0FBRSxDQUFGLENBRHRDO1FBRUE7O1FBRUQsT0FBT0QsUUFBUDtNQUNBO0lBZG1DLENBQXJDOztJQWlCQSxJQUFLLENBQUN4RixPQUFPLENBQUN4akIsSUFBUixDQUFjNm9CLE1BQWQsQ0FBTixFQUErQjtNQUM5QmwwQixNQUFNLENBQUN5ekIsUUFBUCxDQUFpQlMsTUFBTSxHQUFHQyxNQUExQixFQUFtQ1AsR0FBbkMsR0FBeUNkLGlCQUF6QztJQUNBO0VBQ0QsQ0F6QkQ7RUEyQkE5eUIsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLENBQWtCO0lBQ2pCOGQsR0FBRyxFQUFFLGFBQVUxZCxJQUFWLEVBQWdCb0QsS0FBaEIsRUFBd0I7TUFDNUIsT0FBT21iLE1BQU0sQ0FBRSxJQUFGLEVBQVEsVUFBVXZmLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQm9ELEtBQXRCLEVBQThCO1FBQ2xELElBQUltdEIsTUFBSjtRQUFBLElBQVloeEIsR0FBWjtRQUFBLElBQ0NSLEdBQUcsR0FBRyxFQURQO1FBQUEsSUFFQ0UsQ0FBQyxHQUFHLENBRkw7O1FBSUEsSUFBSzdCLE1BQU0sQ0FBQ21ELE9BQVAsQ0FBZ0JQLElBQWhCLENBQUwsRUFBOEI7VUFDN0J1d0IsTUFBTSxHQUFHeEMsU0FBUyxDQUFFL3VCLElBQUYsQ0FBbEI7VUFDQU8sR0FBRyxHQUFHUyxJQUFJLENBQUM3QixNQUFYOztVQUVBLE9BQVFjLENBQUMsR0FBR00sR0FBWixFQUFpQk4sQ0FBQyxFQUFsQixFQUF1QjtZQUN0QkYsR0FBRyxDQUFFaUIsSUFBSSxDQUFFZixDQUFGLENBQU4sQ0FBSCxHQUFtQjdCLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCZ0IsSUFBSSxDQUFFZixDQUFGLENBQXRCLEVBQTZCLEtBQTdCLEVBQW9Dc3hCLE1BQXBDLENBQW5CO1VBQ0E7O1VBRUQsT0FBT3h4QixHQUFQO1FBQ0E7O1FBRUQsT0FBT3FFLEtBQUssS0FBSzVDLFNBQVYsR0FDTnBELE1BQU0sQ0FBQzRkLEtBQVAsQ0FBY2hjLElBQWQsRUFBb0JnQixJQUFwQixFQUEwQm9ELEtBQTFCLENBRE0sR0FFTmhHLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCZ0IsSUFBbEIsQ0FGRDtNQUdBLENBbkJZLEVBbUJWQSxJQW5CVSxFQW1CSm9ELEtBbkJJLEVBbUJHakUsU0FBUyxDQUFDaEIsTUFBVixHQUFtQixDQW5CdEIsQ0FBYjtJQW9CQSxDQXRCZ0I7SUF1QmpCNnhCLElBQUksRUFBRSxnQkFBVztNQUNoQixPQUFPRCxRQUFRLENBQUUsSUFBRixFQUFRLElBQVIsQ0FBZjtJQUNBLENBekJnQjtJQTBCakI0QixJQUFJLEVBQUUsZ0JBQVc7TUFDaEIsT0FBTzVCLFFBQVEsQ0FBRSxJQUFGLENBQWY7SUFDQSxDQTVCZ0I7SUE2QmpCNkIsTUFBTSxFQUFFLGdCQUFVM1osS0FBVixFQUFrQjtNQUN6QixJQUFLLE9BQU9BLEtBQVAsS0FBaUIsU0FBdEIsRUFBa0M7UUFDakMsT0FBT0EsS0FBSyxHQUFHLEtBQUsrWCxJQUFMLEVBQUgsR0FBaUIsS0FBSzJCLElBQUwsRUFBN0I7TUFDQTs7TUFFRCxPQUFPLEtBQUs5eUIsSUFBTCxDQUFXLFlBQVc7UUFDNUIsSUFBSzJlLFFBQVEsQ0FBRSxJQUFGLENBQWIsRUFBd0I7VUFDdkJwZ0IsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlNHlCLElBQWY7UUFDQSxDQUZELE1BRU87VUFDTjV5QixNQUFNLENBQUUsSUFBRixDQUFOLENBQWV1MEIsSUFBZjtRQUNBO01BQ0QsQ0FOTSxDQUFQO0lBT0E7RUF6Q2dCLENBQWxCOztFQTZDQSxTQUFTRSxLQUFULENBQWdCN3lCLElBQWhCLEVBQXNCaUIsT0FBdEIsRUFBK0IyZCxJQUEvQixFQUFxQ25lLEdBQXJDLEVBQTBDcXlCLE1BQTFDLEVBQW1EO0lBQ2xELE9BQU8sSUFBSUQsS0FBSyxDQUFDN3pCLFNBQU4sQ0FBZ0JSLElBQXBCLENBQTBCd0IsSUFBMUIsRUFBZ0NpQixPQUFoQyxFQUF5QzJkLElBQXpDLEVBQStDbmUsR0FBL0MsRUFBb0RxeUIsTUFBcEQsQ0FBUDtFQUNBOztFQUNEMTBCLE1BQU0sQ0FBQ3kwQixLQUFQLEdBQWVBLEtBQWY7RUFFQUEsS0FBSyxDQUFDN3pCLFNBQU4sR0FBa0I7SUFDakJFLFdBQVcsRUFBRTJ6QixLQURJO0lBRWpCcjBCLElBQUksRUFBRSxjQUFVd0IsSUFBVixFQUFnQmlCLE9BQWhCLEVBQXlCMmQsSUFBekIsRUFBK0JuZSxHQUEvQixFQUFvQ3F5QixNQUFwQyxFQUE0QzFULElBQTVDLEVBQW1EO01BQ3hELEtBQUtwZixJQUFMLEdBQVlBLElBQVo7TUFDQSxLQUFLNGUsSUFBTCxHQUFZQSxJQUFaO01BQ0EsS0FBS2tVLE1BQUwsR0FBY0EsTUFBTSxJQUFJMTBCLE1BQU0sQ0FBQzAwQixNQUFQLENBQWN0UixRQUF0QztNQUNBLEtBQUt2Z0IsT0FBTCxHQUFlQSxPQUFmO01BQ0EsS0FBSzZPLEtBQUwsR0FBYSxLQUFLckwsR0FBTCxHQUFXLEtBQUt3RyxHQUFMLEVBQXhCO01BQ0EsS0FBS3hLLEdBQUwsR0FBV0EsR0FBWDtNQUNBLEtBQUsyZSxJQUFMLEdBQVlBLElBQUksS0FBTWhoQixNQUFNLENBQUNpaEIsU0FBUCxDQUFrQlQsSUFBbEIsSUFBMkIsRUFBM0IsR0FBZ0MsSUFBdEMsQ0FBaEI7SUFDQSxDQVZnQjtJQVdqQjNULEdBQUcsRUFBRSxlQUFXO01BQ2YsSUFBSXlTLEtBQUssR0FBR21WLEtBQUssQ0FBQ0UsU0FBTixDQUFpQixLQUFLblUsSUFBdEIsQ0FBWjtNQUVBLE9BQU9sQixLQUFLLElBQUlBLEtBQUssQ0FBQ3BlLEdBQWYsR0FDTm9lLEtBQUssQ0FBQ3BlLEdBQU4sQ0FBVyxJQUFYLENBRE0sR0FFTnV6QixLQUFLLENBQUNFLFNBQU4sQ0FBZ0J2UixRQUFoQixDQUF5QmxpQixHQUF6QixDQUE4QixJQUE5QixDQUZEO0lBR0EsQ0FqQmdCO0lBa0JqQjB6QixHQUFHLEVBQUUsYUFBVUMsT0FBVixFQUFvQjtNQUN4QixJQUFJQyxLQUFKO01BQUEsSUFDQ3hWLEtBQUssR0FBR21WLEtBQUssQ0FBQ0UsU0FBTixDQUFpQixLQUFLblUsSUFBdEIsQ0FEVDs7TUFHQSxJQUFLLEtBQUszZCxPQUFMLENBQWFreUIsUUFBbEIsRUFBNkI7UUFDNUIsS0FBS3RjLEdBQUwsR0FBV3FjLEtBQUssR0FBRzkwQixNQUFNLENBQUMwMEIsTUFBUCxDQUFlLEtBQUtBLE1BQXBCLEVBQ2xCRyxPQURrQixFQUNULEtBQUtoeUIsT0FBTCxDQUFha3lCLFFBQWIsR0FBd0JGLE9BRGYsRUFDd0IsQ0FEeEIsRUFDMkIsQ0FEM0IsRUFDOEIsS0FBS2h5QixPQUFMLENBQWFreUIsUUFEM0MsQ0FBbkI7TUFHQSxDQUpELE1BSU87UUFDTixLQUFLdGMsR0FBTCxHQUFXcWMsS0FBSyxHQUFHRCxPQUFuQjtNQUNBOztNQUNELEtBQUt4dUIsR0FBTCxHQUFXLENBQUUsS0FBS2hFLEdBQUwsR0FBVyxLQUFLcVAsS0FBbEIsSUFBNEJvakIsS0FBNUIsR0FBb0MsS0FBS3BqQixLQUFwRDs7TUFFQSxJQUFLLEtBQUs3TyxPQUFMLENBQWFteUIsSUFBbEIsRUFBeUI7UUFDeEIsS0FBS255QixPQUFMLENBQWFteUIsSUFBYixDQUFrQi96QixJQUFsQixDQUF3QixLQUFLVyxJQUE3QixFQUFtQyxLQUFLeUUsR0FBeEMsRUFBNkMsSUFBN0M7TUFDQTs7TUFFRCxJQUFLaVosS0FBSyxJQUFJQSxLQUFLLENBQUNzVSxHQUFwQixFQUEwQjtRQUN6QnRVLEtBQUssQ0FBQ3NVLEdBQU4sQ0FBVyxJQUFYO01BQ0EsQ0FGRCxNQUVPO1FBQ05hLEtBQUssQ0FBQ0UsU0FBTixDQUFnQnZSLFFBQWhCLENBQXlCd1EsR0FBekIsQ0FBOEIsSUFBOUI7TUFDQTs7TUFDRCxPQUFPLElBQVA7SUFDQTtFQXpDZ0IsQ0FBbEI7RUE0Q0FhLEtBQUssQ0FBQzd6QixTQUFOLENBQWdCUixJQUFoQixDQUFxQlEsU0FBckIsR0FBaUM2ekIsS0FBSyxDQUFDN3pCLFNBQXZDO0VBRUE2ekIsS0FBSyxDQUFDRSxTQUFOLEdBQWtCO0lBQ2pCdlIsUUFBUSxFQUFFO01BQ1RsaUIsR0FBRyxFQUFFLGFBQVV3ZixLQUFWLEVBQWtCO1FBQ3RCLElBQUl6UCxNQUFKLENBRHNCLENBR3RCO1FBQ0E7O1FBQ0EsSUFBS3lQLEtBQUssQ0FBQzllLElBQU4sQ0FBVzBDLFFBQVgsS0FBd0IsQ0FBeEIsSUFDSm9jLEtBQUssQ0FBQzllLElBQU4sQ0FBWThlLEtBQUssQ0FBQ0YsSUFBbEIsS0FBNEIsSUFBNUIsSUFBb0NFLEtBQUssQ0FBQzllLElBQU4sQ0FBV2djLEtBQVgsQ0FBa0I4QyxLQUFLLENBQUNGLElBQXhCLEtBQWtDLElBRHZFLEVBQzhFO1VBQzdFLE9BQU9FLEtBQUssQ0FBQzllLElBQU4sQ0FBWThlLEtBQUssQ0FBQ0YsSUFBbEIsQ0FBUDtRQUNBLENBUnFCLENBVXRCO1FBQ0E7UUFDQTtRQUNBOzs7UUFDQXZQLE1BQU0sR0FBR2pSLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVlJLEtBQUssQ0FBQzllLElBQWxCLEVBQXdCOGUsS0FBSyxDQUFDRixJQUE5QixFQUFvQyxFQUFwQyxDQUFULENBZHNCLENBZ0J0Qjs7UUFDQSxPQUFPLENBQUN2UCxNQUFELElBQVdBLE1BQU0sS0FBSyxNQUF0QixHQUErQixDQUEvQixHQUFtQ0EsTUFBMUM7TUFDQSxDQW5CUTtNQW9CVDJpQixHQUFHLEVBQUUsYUFBVWxULEtBQVYsRUFBa0I7UUFFdEI7UUFDQTtRQUNBLElBQUsxZ0IsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVUQsSUFBVixDQUFnQnRVLEtBQUssQ0FBQ0YsSUFBdEIsQ0FBTCxFQUFvQztVQUNuQ3hnQixNQUFNLENBQUNpMUIsRUFBUCxDQUFVRCxJQUFWLENBQWdCdFUsS0FBSyxDQUFDRixJQUF0QixFQUE4QkUsS0FBOUI7UUFDQSxDQUZELE1BRU8sSUFBS0EsS0FBSyxDQUFDOWUsSUFBTixDQUFXMEMsUUFBWCxLQUF3QixDQUF4QixLQUNUb2MsS0FBSyxDQUFDOWUsSUFBTixDQUFXZ2MsS0FBWCxDQUFrQjVkLE1BQU0sQ0FBQzB6QixRQUFQLENBQWlCaFQsS0FBSyxDQUFDRixJQUF2QixDQUFsQixLQUFxRCxJQUFyRCxJQUNEeGdCLE1BQU0sQ0FBQ3l6QixRQUFQLENBQWlCL1MsS0FBSyxDQUFDRixJQUF2QixDQUZVLENBQUwsRUFFNkI7VUFDbkN4Z0IsTUFBTSxDQUFDNGQsS0FBUCxDQUFjOEMsS0FBSyxDQUFDOWUsSUFBcEIsRUFBMEI4ZSxLQUFLLENBQUNGLElBQWhDLEVBQXNDRSxLQUFLLENBQUNyYSxHQUFOLEdBQVlxYSxLQUFLLENBQUNNLElBQXhEO1FBQ0EsQ0FKTSxNQUlBO1VBQ05OLEtBQUssQ0FBQzllLElBQU4sQ0FBWThlLEtBQUssQ0FBQ0YsSUFBbEIsSUFBMkJFLEtBQUssQ0FBQ3JhLEdBQWpDO1FBQ0E7TUFDRDtJQWpDUTtFQURPLENBQWxCLENBdnVPOEUsQ0E2d085RTtFQUNBOztFQUVBb3VCLEtBQUssQ0FBQ0UsU0FBTixDQUFnQjlLLFNBQWhCLEdBQTRCNEssS0FBSyxDQUFDRSxTQUFOLENBQWdCbEwsVUFBaEIsR0FBNkI7SUFDeERtSyxHQUFHLEVBQUUsYUFBVWxULEtBQVYsRUFBa0I7TUFDdEIsSUFBS0EsS0FBSyxDQUFDOWUsSUFBTixDQUFXMEMsUUFBWCxJQUF1Qm9jLEtBQUssQ0FBQzllLElBQU4sQ0FBVytKLFVBQXZDLEVBQW9EO1FBQ25EK1UsS0FBSyxDQUFDOWUsSUFBTixDQUFZOGUsS0FBSyxDQUFDRixJQUFsQixJQUEyQkUsS0FBSyxDQUFDcmEsR0FBakM7TUFDQTtJQUNEO0VBTHVELENBQXpEO0VBUUFyRyxNQUFNLENBQUMwMEIsTUFBUCxHQUFnQjtJQUNmUSxNQUFNLEVBQUUsZ0JBQVVDLENBQVYsRUFBYztNQUNyQixPQUFPQSxDQUFQO0lBQ0EsQ0FIYztJQUlmQyxLQUFLLEVBQUUsZUFBVUQsQ0FBVixFQUFjO01BQ3BCLE9BQU8sTUFBTTd4QixJQUFJLENBQUMreEIsR0FBTCxDQUFVRixDQUFDLEdBQUc3eEIsSUFBSSxDQUFDZ3lCLEVBQW5CLElBQTBCLENBQXZDO0lBQ0EsQ0FOYztJQU9mbFMsUUFBUSxFQUFFO0VBUEssQ0FBaEI7RUFVQXBqQixNQUFNLENBQUNpMUIsRUFBUCxHQUFZUixLQUFLLENBQUM3ekIsU0FBTixDQUFnQlIsSUFBNUIsQ0FseU84RSxDQW95TzlFOztFQUNBSixNQUFNLENBQUNpMUIsRUFBUCxDQUFVRCxJQUFWLEdBQWlCLEVBQWpCO0VBS0EsSUFDQ08sS0FERDtFQUFBLElBQ1FDLE9BRFI7RUFBQSxJQUVDQyxRQUFRLEdBQUcsd0JBRlo7RUFBQSxJQUdDQyxJQUFJLEdBQUcsYUFIUixDQTF5TzhFLENBK3lPOUU7O0VBQ0EsU0FBU0MsV0FBVCxHQUF1QjtJQUN0QngyQixNQUFNLENBQUNtZSxVQUFQLENBQW1CLFlBQVc7TUFDN0JpWSxLQUFLLEdBQUdueUIsU0FBUjtJQUNBLENBRkQ7SUFHQSxPQUFTbXlCLEtBQUssR0FBR3YxQixNQUFNLENBQUNxRyxHQUFQLEVBQWpCO0VBQ0EsQ0Fyek82RSxDQXV6TzlFOzs7RUFDQSxTQUFTdXZCLEtBQVQsQ0FBZ0I5eEIsSUFBaEIsRUFBc0IreEIsWUFBdEIsRUFBcUM7SUFDcEMsSUFBSTNNLEtBQUo7SUFBQSxJQUNDemMsS0FBSyxHQUFHO01BQUVxcEIsTUFBTSxFQUFFaHlCO0lBQVYsQ0FEVDtJQUFBLElBRUNqQyxDQUFDLEdBQUcsQ0FGTCxDQURvQyxDQUtwQztJQUNBOztJQUNBZzBCLFlBQVksR0FBR0EsWUFBWSxHQUFHLENBQUgsR0FBTyxDQUFsQzs7SUFDQSxPQUFRaDBCLENBQUMsR0FBRyxDQUFaLEVBQWdCQSxDQUFDLElBQUksSUFBSWcwQixZQUF6QixFQUF3QztNQUN2QzNNLEtBQUssR0FBRy9JLFNBQVMsQ0FBRXRlLENBQUYsQ0FBakI7TUFDQTRLLEtBQUssQ0FBRSxXQUFXeWMsS0FBYixDQUFMLEdBQTRCemMsS0FBSyxDQUFFLFlBQVl5YyxLQUFkLENBQUwsR0FBNkJwbEIsSUFBekQ7SUFDQTs7SUFFRCxJQUFLK3hCLFlBQUwsRUFBb0I7TUFDbkJwcEIsS0FBSyxDQUFDOGlCLE9BQU4sR0FBZ0I5aUIsS0FBSyxDQUFDc1QsS0FBTixHQUFjamMsSUFBOUI7SUFDQTs7SUFFRCxPQUFPMkksS0FBUDtFQUNBOztFQUVELFNBQVNzcEIsV0FBVCxDQUFzQi92QixLQUF0QixFQUE2QndhLElBQTdCLEVBQW1Dd1YsU0FBbkMsRUFBK0M7SUFDOUMsSUFBSXRWLEtBQUo7SUFBQSxJQUNDa00sVUFBVSxHQUFHLENBQUVxSixTQUFTLENBQUNDLFFBQVYsQ0FBb0IxVixJQUFwQixLQUE4QixFQUFoQyxFQUFxQ2poQixNQUFyQyxDQUE2QzAyQixTQUFTLENBQUNDLFFBQVYsQ0FBb0IsR0FBcEIsQ0FBN0MsQ0FEZDtJQUFBLElBRUN4ZCxLQUFLLEdBQUcsQ0FGVDtJQUFBLElBR0MzWCxNQUFNLEdBQUc2ckIsVUFBVSxDQUFDN3JCLE1BSHJCOztJQUlBLE9BQVEyWCxLQUFLLEdBQUczWCxNQUFoQixFQUF3QjJYLEtBQUssRUFBN0IsRUFBa0M7TUFDakMsSUFBT2dJLEtBQUssR0FBR2tNLFVBQVUsQ0FBRWxVLEtBQUYsQ0FBVixDQUFvQnpYLElBQXBCLENBQTBCKzBCLFNBQTFCLEVBQXFDeFYsSUFBckMsRUFBMkN4YSxLQUEzQyxDQUFmLEVBQXNFO1FBRXJFO1FBQ0EsT0FBTzBhLEtBQVA7TUFDQTtJQUNEO0VBQ0Q7O0VBRUQsU0FBU3lWLGdCQUFULENBQTJCdjBCLElBQTNCLEVBQWlDa25CLEtBQWpDLEVBQXdDc04sSUFBeEMsRUFBK0M7SUFDOUM7SUFDQSxJQUFJNVYsSUFBSjtJQUFBLElBQVV4YSxLQUFWO0lBQUEsSUFBaUJ3dUIsTUFBakI7SUFBQSxJQUF5QjlULEtBQXpCO0lBQUEsSUFBZ0NwQixLQUFoQztJQUFBLElBQXVDK1csT0FBdkM7SUFBQSxJQUFnRDVILE9BQWhEO0lBQUEsSUFBeUQ2SCxZQUF6RDtJQUFBLElBQ0NDLElBQUksR0FBRyxJQURSO0lBQUEsSUFFQ3RMLElBQUksR0FBRyxFQUZSO0lBQUEsSUFHQ3JOLEtBQUssR0FBR2hjLElBQUksQ0FBQ2djLEtBSGQ7SUFBQSxJQUlDaVYsTUFBTSxHQUFHanhCLElBQUksQ0FBQzBDLFFBQUwsSUFBaUI4YixRQUFRLENBQUV4ZSxJQUFGLENBSm5DO0lBQUEsSUFLQzQwQixRQUFRLEdBQUd4MkIsTUFBTSxDQUFDa2YsS0FBUCxDQUFjdGQsSUFBZCxFQUFvQixRQUFwQixDQUxaLENBRjhDLENBUzlDOzs7SUFDQSxJQUFLLENBQUN3MEIsSUFBSSxDQUFDcGMsS0FBWCxFQUFtQjtNQUNsQnNGLEtBQUssR0FBR3RmLE1BQU0sQ0FBQ3VmLFdBQVAsQ0FBb0IzZCxJQUFwQixFQUEwQixJQUExQixDQUFSOztNQUNBLElBQUswZCxLQUFLLENBQUNtWCxRQUFOLElBQWtCLElBQXZCLEVBQThCO1FBQzdCblgsS0FBSyxDQUFDbVgsUUFBTixHQUFpQixDQUFqQjtRQUNBSixPQUFPLEdBQUcvVyxLQUFLLENBQUNoRixLQUFOLENBQVlKLElBQXRCOztRQUNBb0YsS0FBSyxDQUFDaEYsS0FBTixDQUFZSixJQUFaLEdBQW1CLFlBQVc7VUFDN0IsSUFBSyxDQUFDb0YsS0FBSyxDQUFDbVgsUUFBWixFQUF1QjtZQUN0QkosT0FBTztVQUNQO1FBQ0QsQ0FKRDtNQUtBOztNQUNEL1csS0FBSyxDQUFDbVgsUUFBTjtNQUVBRixJQUFJLENBQUN4YixNQUFMLENBQWEsWUFBVztRQUV2QjtRQUNBO1FBQ0F3YixJQUFJLENBQUN4YixNQUFMLENBQWEsWUFBVztVQUN2QnVFLEtBQUssQ0FBQ21YLFFBQU47O1VBQ0EsSUFBSyxDQUFDejJCLE1BQU0sQ0FBQ2dhLEtBQVAsQ0FBY3BZLElBQWQsRUFBb0IsSUFBcEIsRUFBMkJiLE1BQWpDLEVBQTBDO1lBQ3pDdWUsS0FBSyxDQUFDaEYsS0FBTixDQUFZSixJQUFaO1VBQ0E7UUFDRCxDQUxEO01BTUEsQ0FWRDtJQVdBLENBbEM2QyxDQW9DOUM7OztJQUNBLElBQUt0WSxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxCLEtBQXlCLFlBQVl3a0IsS0FBWixJQUFxQixXQUFXQSxLQUF6RCxDQUFMLEVBQXdFO01BRXZFO01BQ0E7TUFDQTtNQUNBO01BQ0FzTixJQUFJLENBQUNNLFFBQUwsR0FBZ0IsQ0FBRTlZLEtBQUssQ0FBQzhZLFFBQVIsRUFBa0I5WSxLQUFLLENBQUMrWSxTQUF4QixFQUFtQy9ZLEtBQUssQ0FBQ2daLFNBQXpDLENBQWhCLENBTnVFLENBUXZFO01BQ0E7O01BQ0FuSSxPQUFPLEdBQUd6dUIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsU0FBbEIsQ0FBVixDQVZ1RSxDQVl2RTs7TUFDQTAwQixZQUFZLEdBQUc3SCxPQUFPLEtBQUssTUFBWixHQUNkenVCLE1BQU0sQ0FBQ2tmLEtBQVAsQ0FBY3RkLElBQWQsRUFBb0IsWUFBcEIsS0FBc0M4c0IsY0FBYyxDQUFFOXNCLElBQUksQ0FBQ21ELFFBQVAsQ0FEdEMsR0FDMEQwcEIsT0FEekU7O01BR0EsSUFBSzZILFlBQVksS0FBSyxRQUFqQixJQUE2QnQyQixNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQixPQUFsQixNQUFnQyxNQUFsRSxFQUEyRTtRQUUxRTtRQUNBO1FBQ0EsSUFBSyxDQUFDOUIsT0FBTyxDQUFDMmQsc0JBQVQsSUFBbUNpUixjQUFjLENBQUU5c0IsSUFBSSxDQUFDbUQsUUFBUCxDQUFkLEtBQW9DLFFBQTVFLEVBQXVGO1VBQ3RGNlksS0FBSyxDQUFDNlEsT0FBTixHQUFnQixjQUFoQjtRQUNBLENBRkQsTUFFTztVQUNON1EsS0FBSyxDQUFDRSxJQUFOLEdBQWEsQ0FBYjtRQUNBO01BQ0Q7SUFDRDs7SUFFRCxJQUFLc1ksSUFBSSxDQUFDTSxRQUFWLEVBQXFCO01BQ3BCOVksS0FBSyxDQUFDOFksUUFBTixHQUFpQixRQUFqQjs7TUFDQSxJQUFLLENBQUM1MkIsT0FBTyxDQUFDZ2dCLGdCQUFSLEVBQU4sRUFBbUM7UUFDbEN5VyxJQUFJLENBQUN4YixNQUFMLENBQWEsWUFBVztVQUN2QjZDLEtBQUssQ0FBQzhZLFFBQU4sR0FBaUJOLElBQUksQ0FBQ00sUUFBTCxDQUFlLENBQWYsQ0FBakI7VUFDQTlZLEtBQUssQ0FBQytZLFNBQU4sR0FBa0JQLElBQUksQ0FBQ00sUUFBTCxDQUFlLENBQWYsQ0FBbEI7VUFDQTlZLEtBQUssQ0FBQ2daLFNBQU4sR0FBa0JSLElBQUksQ0FBQ00sUUFBTCxDQUFlLENBQWYsQ0FBbEI7UUFDQSxDQUpEO01BS0E7SUFDRCxDQTFFNkMsQ0E0RTlDOzs7SUFDQSxLQUFNbFcsSUFBTixJQUFjc0ksS0FBZCxFQUFzQjtNQUNyQjlpQixLQUFLLEdBQUc4aUIsS0FBSyxDQUFFdEksSUFBRixDQUFiOztNQUNBLElBQUtpVixRQUFRLENBQUMxcUIsSUFBVCxDQUFlL0UsS0FBZixDQUFMLEVBQThCO1FBQzdCLE9BQU84aUIsS0FBSyxDQUFFdEksSUFBRixDQUFaO1FBQ0FnVSxNQUFNLEdBQUdBLE1BQU0sSUFBSXh1QixLQUFLLEtBQUssUUFBN0I7O1FBQ0EsSUFBS0EsS0FBSyxNQUFPNnNCLE1BQU0sR0FBRyxNQUFILEdBQVksTUFBekIsQ0FBVixFQUE4QztVQUU3QztVQUNBO1VBQ0EsSUFBSzdzQixLQUFLLEtBQUssTUFBVixJQUFvQnd3QixRQUFwQixJQUFnQ0EsUUFBUSxDQUFFaFcsSUFBRixDQUFSLEtBQXFCcGQsU0FBMUQsRUFBc0U7WUFDckV5dkIsTUFBTSxHQUFHLElBQVQ7VUFDQSxDQUZELE1BRU87WUFDTjtVQUNBO1FBQ0Q7O1FBQ0Q1SCxJQUFJLENBQUV6SyxJQUFGLENBQUosR0FBZWdXLFFBQVEsSUFBSUEsUUFBUSxDQUFFaFcsSUFBRixDQUFwQixJQUFnQ3hnQixNQUFNLENBQUM0ZCxLQUFQLENBQWNoYyxJQUFkLEVBQW9CNGUsSUFBcEIsQ0FBL0MsQ0FiNkIsQ0FlOUI7TUFDQyxDQWhCRCxNQWdCTztRQUNOaU8sT0FBTyxHQUFHcnJCLFNBQVY7TUFDQTtJQUNEOztJQUVELElBQUssQ0FBQ3BELE1BQU0sQ0FBQ29FLGFBQVAsQ0FBc0I2bUIsSUFBdEIsQ0FBTixFQUFxQztNQUNwQyxJQUFLdUwsUUFBTCxFQUFnQjtRQUNmLElBQUssWUFBWUEsUUFBakIsRUFBNEI7VUFDM0IzRCxNQUFNLEdBQUcyRCxRQUFRLENBQUMzRCxNQUFsQjtRQUNBO01BQ0QsQ0FKRCxNQUlPO1FBQ04yRCxRQUFRLEdBQUd4MkIsTUFBTSxDQUFDa2YsS0FBUCxDQUFjdGQsSUFBZCxFQUFvQixRQUFwQixFQUE4QixFQUE5QixDQUFYO01BQ0EsQ0FQbUMsQ0FTcEM7OztNQUNBLElBQUs0eUIsTUFBTCxFQUFjO1FBQ2JnQyxRQUFRLENBQUMzRCxNQUFULEdBQWtCLENBQUNBLE1BQW5CO01BQ0E7O01BQ0QsSUFBS0EsTUFBTCxFQUFjO1FBQ2I3eUIsTUFBTSxDQUFFNEIsSUFBRixDQUFOLENBQWVneEIsSUFBZjtNQUNBLENBRkQsTUFFTztRQUNOMkQsSUFBSSxDQUFDM3VCLElBQUwsQ0FBVyxZQUFXO1VBQ3JCNUgsTUFBTSxDQUFFNEIsSUFBRixDQUFOLENBQWUyeUIsSUFBZjtRQUNBLENBRkQ7TUFHQTs7TUFDRGdDLElBQUksQ0FBQzN1QixJQUFMLENBQVcsWUFBVztRQUNyQixJQUFJNFksSUFBSjs7UUFDQXhnQixNQUFNLENBQUNtZixXQUFQLENBQW9CdmQsSUFBcEIsRUFBMEIsUUFBMUI7O1FBQ0EsS0FBTTRlLElBQU4sSUFBY3lLLElBQWQsRUFBcUI7VUFDcEJqckIsTUFBTSxDQUFDNGQsS0FBUCxDQUFjaGMsSUFBZCxFQUFvQjRlLElBQXBCLEVBQTBCeUssSUFBSSxDQUFFekssSUFBRixDQUE5QjtRQUNBO01BQ0QsQ0FORDs7TUFPQSxLQUFNQSxJQUFOLElBQWN5SyxJQUFkLEVBQXFCO1FBQ3BCdkssS0FBSyxHQUFHcVYsV0FBVyxDQUFFbEQsTUFBTSxHQUFHMkQsUUFBUSxDQUFFaFcsSUFBRixDQUFYLEdBQXNCLENBQTlCLEVBQWlDQSxJQUFqQyxFQUF1QytWLElBQXZDLENBQW5COztRQUVBLElBQUssRUFBRy9WLElBQUksSUFBSWdXLFFBQVgsQ0FBTCxFQUE2QjtVQUM1QkEsUUFBUSxDQUFFaFcsSUFBRixDQUFSLEdBQW1CRSxLQUFLLENBQUNoUCxLQUF6Qjs7VUFDQSxJQUFLbWhCLE1BQUwsRUFBYztZQUNiblMsS0FBSyxDQUFDcmUsR0FBTixHQUFZcWUsS0FBSyxDQUFDaFAsS0FBbEI7WUFDQWdQLEtBQUssQ0FBQ2hQLEtBQU4sR0FBYzhPLElBQUksS0FBSyxPQUFULElBQW9CQSxJQUFJLEtBQUssUUFBN0IsR0FBd0MsQ0FBeEMsR0FBNEMsQ0FBMUQ7VUFDQTtRQUNEO01BQ0QsQ0FyQ21DLENBdUNyQzs7SUFDQyxDQXhDRCxNQXdDTyxJQUFLLENBQUVpTyxPQUFPLEtBQUssTUFBWixHQUFxQkMsY0FBYyxDQUFFOXNCLElBQUksQ0FBQ21ELFFBQVAsQ0FBbkMsR0FBdUQwcEIsT0FBekQsTUFBdUUsUUFBNUUsRUFBdUY7TUFDN0Y3USxLQUFLLENBQUM2USxPQUFOLEdBQWdCQSxPQUFoQjtJQUNBO0VBQ0Q7O0VBRUQsU0FBU29JLFVBQVQsQ0FBcUIvTixLQUFyQixFQUE0QmdPLGFBQTVCLEVBQTRDO0lBQzNDLElBQUlwZSxLQUFKLEVBQVc5VixJQUFYLEVBQWlCOHhCLE1BQWpCLEVBQXlCMXVCLEtBQXpCLEVBQWdDc1osS0FBaEMsQ0FEMkMsQ0FHM0M7O0lBQ0EsS0FBTTVHLEtBQU4sSUFBZW9RLEtBQWYsRUFBdUI7TUFDdEJsbUIsSUFBSSxHQUFHNUMsTUFBTSxDQUFDNkUsU0FBUCxDQUFrQjZULEtBQWxCLENBQVA7TUFDQWdjLE1BQU0sR0FBR29DLGFBQWEsQ0FBRWwwQixJQUFGLENBQXRCO01BQ0FvRCxLQUFLLEdBQUc4aUIsS0FBSyxDQUFFcFEsS0FBRixDQUFiOztNQUNBLElBQUsxWSxNQUFNLENBQUNtRCxPQUFQLENBQWdCNkMsS0FBaEIsQ0FBTCxFQUErQjtRQUM5QjB1QixNQUFNLEdBQUcxdUIsS0FBSyxDQUFFLENBQUYsQ0FBZDtRQUNBQSxLQUFLLEdBQUc4aUIsS0FBSyxDQUFFcFEsS0FBRixDQUFMLEdBQWlCMVMsS0FBSyxDQUFFLENBQUYsQ0FBOUI7TUFDQTs7TUFFRCxJQUFLMFMsS0FBSyxLQUFLOVYsSUFBZixFQUFzQjtRQUNyQmttQixLQUFLLENBQUVsbUIsSUFBRixDQUFMLEdBQWdCb0QsS0FBaEI7UUFDQSxPQUFPOGlCLEtBQUssQ0FBRXBRLEtBQUYsQ0FBWjtNQUNBOztNQUVENEcsS0FBSyxHQUFHdGYsTUFBTSxDQUFDeXpCLFFBQVAsQ0FBaUI3d0IsSUFBakIsQ0FBUjs7TUFDQSxJQUFLMGMsS0FBSyxJQUFJLFlBQVlBLEtBQTFCLEVBQWtDO1FBQ2pDdFosS0FBSyxHQUFHc1osS0FBSyxDQUFDOFUsTUFBTixDQUFjcHVCLEtBQWQsQ0FBUjtRQUNBLE9BQU84aUIsS0FBSyxDQUFFbG1CLElBQUYsQ0FBWixDQUZpQyxDQUlqQztRQUNBOztRQUNBLEtBQU04VixLQUFOLElBQWUxUyxLQUFmLEVBQXVCO1VBQ3RCLElBQUssRUFBRzBTLEtBQUssSUFBSW9RLEtBQVosQ0FBTCxFQUEyQjtZQUMxQkEsS0FBSyxDQUFFcFEsS0FBRixDQUFMLEdBQWlCMVMsS0FBSyxDQUFFMFMsS0FBRixDQUF0QjtZQUNBb2UsYUFBYSxDQUFFcGUsS0FBRixDQUFiLEdBQXlCZ2MsTUFBekI7VUFDQTtRQUNEO01BQ0QsQ0FaRCxNQVlPO1FBQ05vQyxhQUFhLENBQUVsMEIsSUFBRixDQUFiLEdBQXdCOHhCLE1BQXhCO01BQ0E7SUFDRDtFQUNEOztFQUVELFNBQVN1QixTQUFULENBQW9CcjBCLElBQXBCLEVBQTBCbTFCLFVBQTFCLEVBQXNDbDBCLE9BQXRDLEVBQWdEO0lBQy9DLElBQUlvTyxNQUFKO0lBQUEsSUFDQytsQixPQUREO0lBQUEsSUFFQ3RlLEtBQUssR0FBRyxDQUZUO0lBQUEsSUFHQzNYLE1BQU0sR0FBR2sxQixTQUFTLENBQUNnQixVQUFWLENBQXFCbDJCLE1BSC9CO0lBQUEsSUFJQ2lhLFFBQVEsR0FBR2hiLE1BQU0sQ0FBQzBhLFFBQVAsR0FBa0JLLE1BQWxCLENBQTBCLFlBQVc7TUFFL0M7TUFDQSxPQUFPbWMsSUFBSSxDQUFDdDFCLElBQVo7SUFDQSxDQUpVLENBSlo7SUFBQSxJQVNDczFCLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVc7TUFDakIsSUFBS0YsT0FBTCxFQUFlO1FBQ2QsT0FBTyxLQUFQO01BQ0E7O01BQ0QsSUFBSUcsV0FBVyxHQUFHNUIsS0FBSyxJQUFJSSxXQUFXLEVBQXRDO01BQUEsSUFDQzNaLFNBQVMsR0FBRzFZLElBQUksQ0FBQ2tDLEdBQUwsQ0FBVSxDQUFWLEVBQWF3d0IsU0FBUyxDQUFDb0IsU0FBVixHQUFzQnBCLFNBQVMsQ0FBQ2pCLFFBQWhDLEdBQTJDb0MsV0FBeEQsQ0FEYjtNQUFBLElBR0M7TUFDQTtNQUNBbmlCLElBQUksR0FBR2dILFNBQVMsR0FBR2dhLFNBQVMsQ0FBQ2pCLFFBQXRCLElBQWtDLENBTDFDO01BQUEsSUFNQ0YsT0FBTyxHQUFHLElBQUk3ZixJQU5mO01BQUEsSUFPQzBELEtBQUssR0FBRyxDQVBUO01BQUEsSUFRQzNYLE1BQU0sR0FBR2kxQixTQUFTLENBQUNxQixNQUFWLENBQWlCdDJCLE1BUjNCOztNQVVBLE9BQVEyWCxLQUFLLEdBQUczWCxNQUFoQixFQUF5QjJYLEtBQUssRUFBOUIsRUFBbUM7UUFDbENzZCxTQUFTLENBQUNxQixNQUFWLENBQWtCM2UsS0FBbEIsRUFBMEJrYyxHQUExQixDQUErQkMsT0FBL0I7TUFDQTs7TUFFRDdaLFFBQVEsQ0FBQ29CLFVBQVQsQ0FBcUJ4YSxJQUFyQixFQUEyQixDQUFFbzBCLFNBQUYsRUFBYW5CLE9BQWIsRUFBc0I3WSxTQUF0QixDQUEzQjs7TUFFQSxJQUFLNlksT0FBTyxHQUFHLENBQVYsSUFBZTl6QixNQUFwQixFQUE2QjtRQUM1QixPQUFPaWIsU0FBUDtNQUNBLENBRkQsTUFFTztRQUNOaEIsUUFBUSxDQUFDcUIsV0FBVCxDQUFzQnphLElBQXRCLEVBQTRCLENBQUVvMEIsU0FBRixDQUE1QjtRQUNBLE9BQU8sS0FBUDtNQUNBO0lBQ0QsQ0FuQ0Y7SUFBQSxJQW9DQ0EsU0FBUyxHQUFHaGIsUUFBUSxDQUFDRixPQUFULENBQWtCO01BQzdCbFosSUFBSSxFQUFFQSxJQUR1QjtNQUU3QmtuQixLQUFLLEVBQUU5b0IsTUFBTSxDQUFDd0MsTUFBUCxDQUFlLEVBQWYsRUFBbUJ1MEIsVUFBbkIsQ0FGc0I7TUFHN0JYLElBQUksRUFBRXAyQixNQUFNLENBQUN3QyxNQUFQLENBQWUsSUFBZixFQUFxQjtRQUMxQnMwQixhQUFhLEVBQUUsRUFEVztRQUUxQnBDLE1BQU0sRUFBRTEwQixNQUFNLENBQUMwMEIsTUFBUCxDQUFjdFI7TUFGSSxDQUFyQixFQUdIdmdCLE9BSEcsQ0FIdUI7TUFPN0J5MEIsa0JBQWtCLEVBQUVQLFVBUFM7TUFRN0JRLGVBQWUsRUFBRTEwQixPQVJZO01BUzdCdTBCLFNBQVMsRUFBRTdCLEtBQUssSUFBSUksV0FBVyxFQVRGO01BVTdCWixRQUFRLEVBQUVseUIsT0FBTyxDQUFDa3lCLFFBVlc7TUFXN0JzQyxNQUFNLEVBQUUsRUFYcUI7TUFZN0J0QixXQUFXLEVBQUUscUJBQVV2VixJQUFWLEVBQWdCbmUsR0FBaEIsRUFBc0I7UUFDbEMsSUFBSXFlLEtBQUssR0FBRzFnQixNQUFNLENBQUN5MEIsS0FBUCxDQUFjN3lCLElBQWQsRUFBb0JvMEIsU0FBUyxDQUFDSSxJQUE5QixFQUFvQzVWLElBQXBDLEVBQTBDbmUsR0FBMUMsRUFDVjJ6QixTQUFTLENBQUNJLElBQVYsQ0FBZVUsYUFBZixDQUE4QnRXLElBQTlCLEtBQXdDd1YsU0FBUyxDQUFDSSxJQUFWLENBQWUxQixNQUQ3QyxDQUFaO1FBRUFzQixTQUFTLENBQUNxQixNQUFWLENBQWlCNzNCLElBQWpCLENBQXVCa2hCLEtBQXZCO1FBQ0EsT0FBT0EsS0FBUDtNQUNBLENBakI0QjtNQWtCN0JsQixJQUFJLEVBQUUsY0FBVWdZLE9BQVYsRUFBb0I7UUFDekIsSUFBSTllLEtBQUssR0FBRyxDQUFaO1FBQUEsSUFFQztRQUNBO1FBQ0EzWCxNQUFNLEdBQUd5MkIsT0FBTyxHQUFHeEIsU0FBUyxDQUFDcUIsTUFBVixDQUFpQnQyQixNQUFwQixHQUE2QixDQUo5Qzs7UUFLQSxJQUFLaTJCLE9BQUwsRUFBZTtVQUNkLE9BQU8sSUFBUDtRQUNBOztRQUNEQSxPQUFPLEdBQUcsSUFBVjs7UUFDQSxPQUFRdGUsS0FBSyxHQUFHM1gsTUFBaEIsRUFBeUIyWCxLQUFLLEVBQTlCLEVBQW1DO1VBQ2xDc2QsU0FBUyxDQUFDcUIsTUFBVixDQUFrQjNlLEtBQWxCLEVBQTBCa2MsR0FBMUIsQ0FBK0IsQ0FBL0I7UUFDQSxDQVp3QixDQWN6QjtRQUNBOzs7UUFDQSxJQUFLNEMsT0FBTCxFQUFlO1VBQ2R4YyxRQUFRLENBQUNvQixVQUFULENBQXFCeGEsSUFBckIsRUFBMkIsQ0FBRW8wQixTQUFGLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUEzQjtVQUNBaGIsUUFBUSxDQUFDcUIsV0FBVCxDQUFzQnphLElBQXRCLEVBQTRCLENBQUVvMEIsU0FBRixFQUFhd0IsT0FBYixDQUE1QjtRQUNBLENBSEQsTUFHTztVQUNOeGMsUUFBUSxDQUFDeWMsVUFBVCxDQUFxQjcxQixJQUFyQixFQUEyQixDQUFFbzBCLFNBQUYsRUFBYXdCLE9BQWIsQ0FBM0I7UUFDQTs7UUFDRCxPQUFPLElBQVA7TUFDQTtJQXpDNEIsQ0FBbEIsQ0FwQ2I7SUFBQSxJQStFQzFPLEtBQUssR0FBR2tOLFNBQVMsQ0FBQ2xOLEtBL0VuQjs7SUFpRkErTixVQUFVLENBQUUvTixLQUFGLEVBQVNrTixTQUFTLENBQUNJLElBQVYsQ0FBZVUsYUFBeEIsQ0FBVjs7SUFFQSxPQUFRcGUsS0FBSyxHQUFHM1gsTUFBaEIsRUFBeUIyWCxLQUFLLEVBQTlCLEVBQW1DO01BQ2xDekgsTUFBTSxHQUFHZ2xCLFNBQVMsQ0FBQ2dCLFVBQVYsQ0FBc0J2ZSxLQUF0QixFQUE4QnpYLElBQTlCLENBQW9DKzBCLFNBQXBDLEVBQStDcDBCLElBQS9DLEVBQXFEa25CLEtBQXJELEVBQTREa04sU0FBUyxDQUFDSSxJQUF0RSxDQUFUOztNQUNBLElBQUtubEIsTUFBTCxFQUFjO1FBQ2IsSUFBS2pSLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUJnTyxNQUFNLENBQUN1TyxJQUExQixDQUFMLEVBQXdDO1VBQ3ZDeGYsTUFBTSxDQUFDdWYsV0FBUCxDQUFvQnlXLFNBQVMsQ0FBQ3AwQixJQUE5QixFQUFvQ28wQixTQUFTLENBQUNJLElBQVYsQ0FBZXBjLEtBQW5ELEVBQTJEd0YsSUFBM0QsR0FDQ3hmLE1BQU0sQ0FBQ2tHLEtBQVAsQ0FBYytLLE1BQU0sQ0FBQ3VPLElBQXJCLEVBQTJCdk8sTUFBM0IsQ0FERDtRQUVBOztRQUNELE9BQU9BLE1BQVA7TUFDQTtJQUNEOztJQUVEalIsTUFBTSxDQUFDMkIsR0FBUCxDQUFZbW5CLEtBQVosRUFBbUJpTixXQUFuQixFQUFnQ0MsU0FBaEM7O0lBRUEsSUFBS2gyQixNQUFNLENBQUNpRCxVQUFQLENBQW1CK3lCLFNBQVMsQ0FBQ0ksSUFBVixDQUFlMWtCLEtBQWxDLENBQUwsRUFBaUQ7TUFDaERza0IsU0FBUyxDQUFDSSxJQUFWLENBQWUxa0IsS0FBZixDQUFxQnpRLElBQXJCLENBQTJCVyxJQUEzQixFQUFpQ28wQixTQUFqQztJQUNBOztJQUVEaDJCLE1BQU0sQ0FBQ2kxQixFQUFQLENBQVV5QyxLQUFWLENBQ0MxM0IsTUFBTSxDQUFDd0MsTUFBUCxDQUFlMDBCLElBQWYsRUFBcUI7TUFDcEJ0MUIsSUFBSSxFQUFFQSxJQURjO01BRXBCMjBCLElBQUksRUFBRVAsU0FGYztNQUdwQmhjLEtBQUssRUFBRWdjLFNBQVMsQ0FBQ0ksSUFBVixDQUFlcGM7SUFIRixDQUFyQixDQURELEVBckcrQyxDQTZHL0M7O0lBQ0EsT0FBT2djLFNBQVMsQ0FBQ3phLFFBQVYsQ0FBb0J5YSxTQUFTLENBQUNJLElBQVYsQ0FBZTdhLFFBQW5DLEVBQ0wzVCxJQURLLENBQ0NvdUIsU0FBUyxDQUFDSSxJQUFWLENBQWV4dUIsSUFEaEIsRUFDc0JvdUIsU0FBUyxDQUFDSSxJQUFWLENBQWV1QixRQURyQyxFQUVMMWMsSUFGSyxDQUVDK2EsU0FBUyxDQUFDSSxJQUFWLENBQWVuYixJQUZoQixFQUdMRixNQUhLLENBR0dpYixTQUFTLENBQUNJLElBQVYsQ0FBZXJiLE1BSGxCLENBQVA7RUFJQTs7RUFFRC9hLE1BQU0sQ0FBQ2kyQixTQUFQLEdBQW1CajJCLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZXl6QixTQUFmLEVBQTBCO0lBRTVDQyxRQUFRLEVBQUU7TUFDVCxLQUFLLENBQUUsVUFBVTFWLElBQVYsRUFBZ0J4YSxLQUFoQixFQUF3QjtRQUM5QixJQUFJMGEsS0FBSyxHQUFHLEtBQUtxVixXQUFMLENBQWtCdlYsSUFBbEIsRUFBd0J4YSxLQUF4QixDQUFaO1FBQ0F1YSxTQUFTLENBQUVHLEtBQUssQ0FBQzllLElBQVIsRUFBYzRlLElBQWQsRUFBb0JOLE9BQU8sQ0FBQ25WLElBQVIsQ0FBYy9FLEtBQWQsQ0FBcEIsRUFBMkMwYSxLQUEzQyxDQUFUO1FBQ0EsT0FBT0EsS0FBUDtNQUNBLENBSkk7SUFESSxDQUZrQztJQVU1Q2tYLE9BQU8sRUFBRSxpQkFBVTlPLEtBQVYsRUFBaUJwbkIsUUFBakIsRUFBNEI7TUFDcEMsSUFBSzFCLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUI2bEIsS0FBbkIsQ0FBTCxFQUFrQztRQUNqQ3BuQixRQUFRLEdBQUdvbkIsS0FBWDtRQUNBQSxLQUFLLEdBQUcsQ0FBRSxHQUFGLENBQVI7TUFDQSxDQUhELE1BR087UUFDTkEsS0FBSyxHQUFHQSxLQUFLLENBQUNwZSxLQUFOLENBQWE2TyxTQUFiLENBQVI7TUFDQTs7TUFFRCxJQUFJaUgsSUFBSjtNQUFBLElBQ0M5SCxLQUFLLEdBQUcsQ0FEVDtNQUFBLElBRUMzWCxNQUFNLEdBQUcrbkIsS0FBSyxDQUFDL25CLE1BRmhCOztNQUlBLE9BQVEyWCxLQUFLLEdBQUczWCxNQUFoQixFQUF5QjJYLEtBQUssRUFBOUIsRUFBbUM7UUFDbEM4SCxJQUFJLEdBQUdzSSxLQUFLLENBQUVwUSxLQUFGLENBQVo7UUFDQXVkLFNBQVMsQ0FBQ0MsUUFBVixDQUFvQjFWLElBQXBCLElBQTZCeVYsU0FBUyxDQUFDQyxRQUFWLENBQW9CMVYsSUFBcEIsS0FBOEIsRUFBM0Q7UUFDQXlWLFNBQVMsQ0FBQ0MsUUFBVixDQUFvQjFWLElBQXBCLEVBQTJCL1EsT0FBM0IsQ0FBb0MvTixRQUFwQztNQUNBO0lBQ0QsQ0EzQjJDO0lBNkI1Q3UxQixVQUFVLEVBQUUsQ0FBRWQsZ0JBQUYsQ0E3QmdDO0lBK0I1QzBCLFNBQVMsRUFBRSxtQkFBVW4yQixRQUFWLEVBQW9CK3JCLE9BQXBCLEVBQThCO01BQ3hDLElBQUtBLE9BQUwsRUFBZTtRQUNkd0ksU0FBUyxDQUFDZ0IsVUFBVixDQUFxQnhuQixPQUFyQixDQUE4Qi9OLFFBQTlCO01BQ0EsQ0FGRCxNQUVPO1FBQ051MEIsU0FBUyxDQUFDZ0IsVUFBVixDQUFxQnozQixJQUFyQixDQUEyQmtDLFFBQTNCO01BQ0E7SUFDRDtFQXJDMkMsQ0FBMUIsQ0FBbkI7O0VBd0NBMUIsTUFBTSxDQUFDODNCLEtBQVAsR0FBZSxVQUFVQSxLQUFWLEVBQWlCcEQsTUFBakIsRUFBeUJ2MEIsRUFBekIsRUFBOEI7SUFDNUMsSUFBSTQzQixHQUFHLEdBQUdELEtBQUssSUFBSSxRQUFPQSxLQUFQLE1BQWlCLFFBQTFCLEdBQXFDOTNCLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBZSxFQUFmLEVBQW1CczFCLEtBQW5CLENBQXJDLEdBQWtFO01BQzNFSCxRQUFRLEVBQUV4M0IsRUFBRSxJQUFJLENBQUNBLEVBQUQsSUFBT3UwQixNQUFiLElBQ1QxMEIsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQjYwQixLQUFuQixLQUE4QkEsS0FGNEM7TUFHM0UvQyxRQUFRLEVBQUUrQyxLQUhpRTtNQUkzRXBELE1BQU0sRUFBRXYwQixFQUFFLElBQUl1MEIsTUFBTixJQUFnQkEsTUFBTSxJQUFJLENBQUMxMEIsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQnl4QixNQUFuQixDQUFYLElBQTBDQTtJQUpTLENBQTVFO0lBT0FxRCxHQUFHLENBQUNoRCxRQUFKLEdBQWUvMEIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVW5ZLEdBQVYsR0FBZ0IsQ0FBaEIsR0FBb0IsT0FBT2liLEdBQUcsQ0FBQ2hELFFBQVgsS0FBd0IsUUFBeEIsR0FBbUNnRCxHQUFHLENBQUNoRCxRQUF2QyxHQUNsQ2dELEdBQUcsQ0FBQ2hELFFBQUosSUFBZ0IvMEIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVStDLE1BQTFCLEdBQ0NoNEIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVStDLE1BQVYsQ0FBa0JELEdBQUcsQ0FBQ2hELFFBQXRCLENBREQsR0FDb0MvMEIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVStDLE1BQVYsQ0FBaUI1VSxRQUZ0RCxDQVI0QyxDQVk1Qzs7SUFDQSxJQUFLMlUsR0FBRyxDQUFDL2QsS0FBSixJQUFhLElBQWIsSUFBcUIrZCxHQUFHLENBQUMvZCxLQUFKLEtBQWMsSUFBeEMsRUFBK0M7TUFDOUMrZCxHQUFHLENBQUMvZCxLQUFKLEdBQVksSUFBWjtJQUNBLENBZjJDLENBaUI1Qzs7O0lBQ0ErZCxHQUFHLENBQUMvSSxHQUFKLEdBQVUrSSxHQUFHLENBQUNKLFFBQWQ7O0lBRUFJLEdBQUcsQ0FBQ0osUUFBSixHQUFlLFlBQVc7TUFDekIsSUFBSzMzQixNQUFNLENBQUNpRCxVQUFQLENBQW1CODBCLEdBQUcsQ0FBQy9JLEdBQXZCLENBQUwsRUFBb0M7UUFDbkMrSSxHQUFHLENBQUMvSSxHQUFKLENBQVEvdEIsSUFBUixDQUFjLElBQWQ7TUFDQTs7TUFFRCxJQUFLODJCLEdBQUcsQ0FBQy9kLEtBQVQsRUFBaUI7UUFDaEJoYSxNQUFNLENBQUNvZixPQUFQLENBQWdCLElBQWhCLEVBQXNCMlksR0FBRyxDQUFDL2QsS0FBMUI7TUFDQTtJQUNELENBUkQ7O0lBVUEsT0FBTytkLEdBQVA7RUFDQSxDQS9CRDs7RUFpQ0EvM0IsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLENBQWtCO0lBQ2pCeTFCLE1BQU0sRUFBRSxnQkFBVUgsS0FBVixFQUFpQkksRUFBakIsRUFBcUJ4RCxNQUFyQixFQUE2Qmh6QixRQUE3QixFQUF3QztNQUUvQztNQUNBLE9BQU8sS0FBSzJNLE1BQUwsQ0FBYStSLFFBQWIsRUFBd0JFLEdBQXhCLENBQTZCLFNBQTdCLEVBQXdDLENBQXhDLEVBQTRDc1MsSUFBNUMsR0FFTjtNQUZNLENBR0x2d0IsR0FISyxHQUdDODFCLE9BSEQsQ0FHVTtRQUFFNUksT0FBTyxFQUFFMkk7TUFBWCxDQUhWLEVBRzJCSixLQUgzQixFQUdrQ3BELE1BSGxDLEVBRzBDaHpCLFFBSDFDLENBQVA7SUFJQSxDQVJnQjtJQVNqQnkyQixPQUFPLEVBQUUsaUJBQVUzWCxJQUFWLEVBQWdCc1gsS0FBaEIsRUFBdUJwRCxNQUF2QixFQUErQmh6QixRQUEvQixFQUEwQztNQUNsRCxJQUFJNFksS0FBSyxHQUFHdGEsTUFBTSxDQUFDb0UsYUFBUCxDQUFzQm9jLElBQXRCLENBQVo7TUFBQSxJQUNDNFgsTUFBTSxHQUFHcDRCLE1BQU0sQ0FBQzgzQixLQUFQLENBQWNBLEtBQWQsRUFBcUJwRCxNQUFyQixFQUE2Qmh6QixRQUE3QixDQURWO01BQUEsSUFFQzIyQixXQUFXLEdBQUcsU0FBZEEsV0FBYyxHQUFXO1FBRXhCO1FBQ0EsSUFBSTlCLElBQUksR0FBR04sU0FBUyxDQUFFLElBQUYsRUFBUWoyQixNQUFNLENBQUN3QyxNQUFQLENBQWUsRUFBZixFQUFtQmdlLElBQW5CLENBQVIsRUFBbUM0WCxNQUFuQyxDQUFwQixDQUh3QixDQUt4Qjs7UUFDQSxJQUFLOWQsS0FBSyxJQUFJdGEsTUFBTSxDQUFDa2YsS0FBUCxDQUFjLElBQWQsRUFBb0IsUUFBcEIsQ0FBZCxFQUErQztVQUM5Q3FYLElBQUksQ0FBQy9XLElBQUwsQ0FBVyxJQUFYO1FBQ0E7TUFDRCxDQVhGOztNQVlDNlksV0FBVyxDQUFDQyxNQUFaLEdBQXFCRCxXQUFyQjtNQUVELE9BQU8vZCxLQUFLLElBQUk4ZCxNQUFNLENBQUNwZSxLQUFQLEtBQWlCLEtBQTFCLEdBQ04sS0FBS3ZZLElBQUwsQ0FBVzQyQixXQUFYLENBRE0sR0FFTixLQUFLcmUsS0FBTCxDQUFZb2UsTUFBTSxDQUFDcGUsS0FBbkIsRUFBMEJxZSxXQUExQixDQUZEO0lBR0EsQ0EzQmdCO0lBNEJqQjdZLElBQUksRUFBRSxjQUFVMWIsSUFBVixFQUFnQjRiLFVBQWhCLEVBQTRCOFgsT0FBNUIsRUFBc0M7TUFDM0MsSUFBSWUsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBVWpaLEtBQVYsRUFBa0I7UUFDakMsSUFBSUUsSUFBSSxHQUFHRixLQUFLLENBQUNFLElBQWpCO1FBQ0EsT0FBT0YsS0FBSyxDQUFDRSxJQUFiO1FBQ0FBLElBQUksQ0FBRWdZLE9BQUYsQ0FBSjtNQUNBLENBSkQ7O01BTUEsSUFBSyxPQUFPMXpCLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7UUFDL0IwekIsT0FBTyxHQUFHOVgsVUFBVjtRQUNBQSxVQUFVLEdBQUc1YixJQUFiO1FBQ0FBLElBQUksR0FBR1YsU0FBUDtNQUNBOztNQUNELElBQUtzYyxVQUFVLElBQUk1YixJQUFJLEtBQUssS0FBNUIsRUFBb0M7UUFDbkMsS0FBS2tXLEtBQUwsQ0FBWWxXLElBQUksSUFBSSxJQUFwQixFQUEwQixFQUExQjtNQUNBOztNQUVELE9BQU8sS0FBS3JDLElBQUwsQ0FBVyxZQUFXO1FBQzVCLElBQUkyZCxPQUFPLEdBQUcsSUFBZDtRQUFBLElBQ0MxRyxLQUFLLEdBQUc1VSxJQUFJLElBQUksSUFBUixJQUFnQkEsSUFBSSxHQUFHLFlBRGhDO1FBQUEsSUFFQzAwQixNQUFNLEdBQUd4NEIsTUFBTSxDQUFDdzRCLE1BRmpCO1FBQUEsSUFHQzl6QixJQUFJLEdBQUcxRSxNQUFNLENBQUNrZixLQUFQLENBQWMsSUFBZCxDQUhSOztRQUtBLElBQUt4RyxLQUFMLEVBQWE7VUFDWixJQUFLaFUsSUFBSSxDQUFFZ1UsS0FBRixDQUFKLElBQWlCaFUsSUFBSSxDQUFFZ1UsS0FBRixDQUFKLENBQWM4RyxJQUFwQyxFQUEyQztZQUMxQytZLFNBQVMsQ0FBRTd6QixJQUFJLENBQUVnVSxLQUFGLENBQU4sQ0FBVDtVQUNBO1FBQ0QsQ0FKRCxNQUlPO1VBQ04sS0FBTUEsS0FBTixJQUFlaFUsSUFBZixFQUFzQjtZQUNyQixJQUFLQSxJQUFJLENBQUVnVSxLQUFGLENBQUosSUFBaUJoVSxJQUFJLENBQUVnVSxLQUFGLENBQUosQ0FBYzhHLElBQS9CLElBQXVDa1csSUFBSSxDQUFDcnFCLElBQUwsQ0FBV3FOLEtBQVgsQ0FBNUMsRUFBaUU7Y0FDaEU2ZixTQUFTLENBQUU3ekIsSUFBSSxDQUFFZ1UsS0FBRixDQUFOLENBQVQ7WUFDQTtVQUNEO1FBQ0Q7O1FBRUQsS0FBTUEsS0FBSyxHQUFHOGYsTUFBTSxDQUFDejNCLE1BQXJCLEVBQTZCMlgsS0FBSyxFQUFsQyxHQUF3QztVQUN2QyxJQUFLOGYsTUFBTSxDQUFFOWYsS0FBRixDQUFOLENBQWdCOVcsSUFBaEIsS0FBeUIsSUFBekIsS0FDRmtDLElBQUksSUFBSSxJQUFSLElBQWdCMDBCLE1BQU0sQ0FBRTlmLEtBQUYsQ0FBTixDQUFnQnNCLEtBQWhCLEtBQTBCbFcsSUFEeEMsQ0FBTCxFQUNzRDtZQUVyRDAwQixNQUFNLENBQUU5ZixLQUFGLENBQU4sQ0FBZ0I2ZCxJQUFoQixDQUFxQi9XLElBQXJCLENBQTJCZ1ksT0FBM0I7WUFDQXBZLE9BQU8sR0FBRyxLQUFWO1lBQ0FvWixNQUFNLENBQUNqMkIsTUFBUCxDQUFlbVcsS0FBZixFQUFzQixDQUF0QjtVQUNBO1FBQ0QsQ0ExQjJCLENBNEI1QjtRQUNBO1FBQ0E7OztRQUNBLElBQUswRyxPQUFPLElBQUksQ0FBQ29ZLE9BQWpCLEVBQTJCO1VBQzFCeDNCLE1BQU0sQ0FBQ29mLE9BQVAsQ0FBZ0IsSUFBaEIsRUFBc0J0YixJQUF0QjtRQUNBO01BQ0QsQ0FsQ00sQ0FBUDtJQW1DQSxDQS9FZ0I7SUFnRmpCdzBCLE1BQU0sRUFBRSxnQkFBVXgwQixJQUFWLEVBQWlCO01BQ3hCLElBQUtBLElBQUksS0FBSyxLQUFkLEVBQXNCO1FBQ3JCQSxJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFmO01BQ0E7O01BQ0QsT0FBTyxLQUFLckMsSUFBTCxDQUFXLFlBQVc7UUFDNUIsSUFBSWlYLEtBQUo7UUFBQSxJQUNDaFUsSUFBSSxHQUFHMUUsTUFBTSxDQUFDa2YsS0FBUCxDQUFjLElBQWQsQ0FEUjtRQUFBLElBRUNsRixLQUFLLEdBQUd0VixJQUFJLENBQUVaLElBQUksR0FBRyxPQUFULENBRmI7UUFBQSxJQUdDd2IsS0FBSyxHQUFHNWEsSUFBSSxDQUFFWixJQUFJLEdBQUcsWUFBVCxDQUhiO1FBQUEsSUFJQzAwQixNQUFNLEdBQUd4NEIsTUFBTSxDQUFDdzRCLE1BSmpCO1FBQUEsSUFLQ3ozQixNQUFNLEdBQUdpWixLQUFLLEdBQUdBLEtBQUssQ0FBQ2paLE1BQVQsR0FBa0IsQ0FMakMsQ0FENEIsQ0FRNUI7OztRQUNBMkQsSUFBSSxDQUFDNHpCLE1BQUwsR0FBYyxJQUFkLENBVDRCLENBVzVCOztRQUNBdDRCLE1BQU0sQ0FBQ2dhLEtBQVAsQ0FBYyxJQUFkLEVBQW9CbFcsSUFBcEIsRUFBMEIsRUFBMUI7O1FBRUEsSUFBS3diLEtBQUssSUFBSUEsS0FBSyxDQUFDRSxJQUFwQixFQUEyQjtVQUMxQkYsS0FBSyxDQUFDRSxJQUFOLENBQVd2ZSxJQUFYLENBQWlCLElBQWpCLEVBQXVCLElBQXZCO1FBQ0EsQ0FoQjJCLENBa0I1Qjs7O1FBQ0EsS0FBTXlYLEtBQUssR0FBRzhmLE1BQU0sQ0FBQ3ozQixNQUFyQixFQUE2QjJYLEtBQUssRUFBbEMsR0FBd0M7VUFDdkMsSUFBSzhmLE1BQU0sQ0FBRTlmLEtBQUYsQ0FBTixDQUFnQjlXLElBQWhCLEtBQXlCLElBQXpCLElBQWlDNDJCLE1BQU0sQ0FBRTlmLEtBQUYsQ0FBTixDQUFnQnNCLEtBQWhCLEtBQTBCbFcsSUFBaEUsRUFBdUU7WUFDdEUwMEIsTUFBTSxDQUFFOWYsS0FBRixDQUFOLENBQWdCNmQsSUFBaEIsQ0FBcUIvVyxJQUFyQixDQUEyQixJQUEzQjtZQUNBZ1osTUFBTSxDQUFDajJCLE1BQVAsQ0FBZW1XLEtBQWYsRUFBc0IsQ0FBdEI7VUFDQTtRQUNELENBeEIyQixDQTBCNUI7OztRQUNBLEtBQU1BLEtBQUssR0FBRyxDQUFkLEVBQWlCQSxLQUFLLEdBQUczWCxNQUF6QixFQUFpQzJYLEtBQUssRUFBdEMsRUFBMkM7VUFDMUMsSUFBS3NCLEtBQUssQ0FBRXRCLEtBQUYsQ0FBTCxJQUFrQnNCLEtBQUssQ0FBRXRCLEtBQUYsQ0FBTCxDQUFlNGYsTUFBdEMsRUFBK0M7WUFDOUN0ZSxLQUFLLENBQUV0QixLQUFGLENBQUwsQ0FBZTRmLE1BQWYsQ0FBc0JyM0IsSUFBdEIsQ0FBNEIsSUFBNUI7VUFDQTtRQUNELENBL0IyQixDQWlDNUI7OztRQUNBLE9BQU95RCxJQUFJLENBQUM0ekIsTUFBWjtNQUNBLENBbkNNLENBQVA7SUFvQ0E7RUF4SGdCLENBQWxCO0VBMkhBdDRCLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYSxDQUFFLFFBQUYsRUFBWSxNQUFaLEVBQW9CLE1BQXBCLENBQWIsRUFBMkMsVUFBVUksQ0FBVixFQUFhZSxJQUFiLEVBQW9CO0lBQzlELElBQUk2MUIsS0FBSyxHQUFHejRCLE1BQU0sQ0FBQ0csRUFBUCxDQUFXeUMsSUFBWCxDQUFaOztJQUNBNUMsTUFBTSxDQUFDRyxFQUFQLENBQVd5QyxJQUFYLElBQW9CLFVBQVVrMUIsS0FBVixFQUFpQnBELE1BQWpCLEVBQXlCaHpCLFFBQXpCLEVBQW9DO01BQ3ZELE9BQU9vMkIsS0FBSyxJQUFJLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUFsQyxHQUNOVyxLQUFLLENBQUMzMkIsS0FBTixDQUFhLElBQWIsRUFBbUJDLFNBQW5CLENBRE0sR0FFTixLQUFLbzJCLE9BQUwsQ0FBY3ZDLEtBQUssQ0FBRWh6QixJQUFGLEVBQVEsSUFBUixDQUFuQixFQUFtQ2sxQixLQUFuQyxFQUEwQ3BELE1BQTFDLEVBQWtEaHpCLFFBQWxELENBRkQ7SUFHQSxDQUpEO0VBS0EsQ0FQRCxFQXgwUDhFLENBaTFQOUU7O0VBQ0ExQixNQUFNLENBQUN5QixJQUFQLENBQWE7SUFDWmkzQixTQUFTLEVBQUU5QyxLQUFLLENBQUUsTUFBRixDQURKO0lBRVorQyxPQUFPLEVBQUUvQyxLQUFLLENBQUUsTUFBRixDQUZGO0lBR1pnRCxXQUFXLEVBQUVoRCxLQUFLLENBQUUsUUFBRixDQUhOO0lBSVppRCxNQUFNLEVBQUU7TUFBRXRKLE9BQU8sRUFBRTtJQUFYLENBSkk7SUFLWnVKLE9BQU8sRUFBRTtNQUFFdkosT0FBTyxFQUFFO0lBQVgsQ0FMRztJQU1ad0osVUFBVSxFQUFFO01BQUV4SixPQUFPLEVBQUU7SUFBWDtFQU5BLENBQWIsRUFPRyxVQUFVM3NCLElBQVYsRUFBZ0JrbUIsS0FBaEIsRUFBd0I7SUFDMUI5b0IsTUFBTSxDQUFDRyxFQUFQLENBQVd5QyxJQUFYLElBQW9CLFVBQVVrMUIsS0FBVixFQUFpQnBELE1BQWpCLEVBQXlCaHpCLFFBQXpCLEVBQW9DO01BQ3ZELE9BQU8sS0FBS3kyQixPQUFMLENBQWNyUCxLQUFkLEVBQXFCZ1AsS0FBckIsRUFBNEJwRCxNQUE1QixFQUFvQ2h6QixRQUFwQyxDQUFQO0lBQ0EsQ0FGRDtFQUdBLENBWEQ7RUFhQTFCLE1BQU0sQ0FBQ3c0QixNQUFQLEdBQWdCLEVBQWhCOztFQUNBeDRCLE1BQU0sQ0FBQ2kxQixFQUFQLENBQVVpQyxJQUFWLEdBQWlCLFlBQVc7SUFDM0IsSUFBSVEsS0FBSjtJQUFBLElBQ0NjLE1BQU0sR0FBR3g0QixNQUFNLENBQUN3NEIsTUFEakI7SUFBQSxJQUVDMzJCLENBQUMsR0FBRyxDQUZMO0lBSUEwekIsS0FBSyxHQUFHdjFCLE1BQU0sQ0FBQ3FHLEdBQVAsRUFBUjs7SUFFQSxPQUFReEUsQ0FBQyxHQUFHMjJCLE1BQU0sQ0FBQ3ozQixNQUFuQixFQUEyQmMsQ0FBQyxFQUE1QixFQUFpQztNQUNoQzYxQixLQUFLLEdBQUdjLE1BQU0sQ0FBRTMyQixDQUFGLENBQWQsQ0FEZ0MsQ0FHaEM7O01BQ0EsSUFBSyxDQUFDNjFCLEtBQUssRUFBTixJQUFZYyxNQUFNLENBQUUzMkIsQ0FBRixDQUFOLEtBQWdCNjFCLEtBQWpDLEVBQXlDO1FBQ3hDYyxNQUFNLENBQUNqMkIsTUFBUCxDQUFlVixDQUFDLEVBQWhCLEVBQW9CLENBQXBCO01BQ0E7SUFDRDs7SUFFRCxJQUFLLENBQUMyMkIsTUFBTSxDQUFDejNCLE1BQWIsRUFBc0I7TUFDckJmLE1BQU0sQ0FBQ2kxQixFQUFQLENBQVV6VixJQUFWO0lBQ0E7O0lBQ0QrVixLQUFLLEdBQUdueUIsU0FBUjtFQUNBLENBcEJEOztFQXNCQXBELE1BQU0sQ0FBQ2kxQixFQUFQLENBQVV5QyxLQUFWLEdBQWtCLFVBQVVBLEtBQVYsRUFBa0I7SUFDbkMxM0IsTUFBTSxDQUFDdzRCLE1BQVAsQ0FBY2g1QixJQUFkLENBQW9CazRCLEtBQXBCOztJQUNBLElBQUtBLEtBQUssRUFBVixFQUFlO01BQ2QxM0IsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVXZqQixLQUFWO0lBQ0EsQ0FGRCxNQUVPO01BQ04xUixNQUFNLENBQUN3NEIsTUFBUCxDQUFjbndCLEdBQWQ7SUFDQTtFQUNELENBUEQ7O0VBU0FySSxNQUFNLENBQUNpMUIsRUFBUCxDQUFVK0QsUUFBVixHQUFxQixFQUFyQjs7RUFFQWg1QixNQUFNLENBQUNpMUIsRUFBUCxDQUFVdmpCLEtBQVYsR0FBa0IsWUFBVztJQUM1QixJQUFLLENBQUM4akIsT0FBTixFQUFnQjtNQUNmQSxPQUFPLEdBQUdyMkIsTUFBTSxDQUFDODVCLFdBQVAsQ0FBb0JqNUIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVWlDLElBQTlCLEVBQW9DbDNCLE1BQU0sQ0FBQ2kxQixFQUFQLENBQVUrRCxRQUE5QyxDQUFWO0lBQ0E7RUFDRCxDQUpEOztFQU1BaDVCLE1BQU0sQ0FBQ2kxQixFQUFQLENBQVV6VixJQUFWLEdBQWlCLFlBQVc7SUFDM0JyZ0IsTUFBTSxDQUFDKzVCLGFBQVAsQ0FBc0IxRCxPQUF0QjtJQUNBQSxPQUFPLEdBQUcsSUFBVjtFQUNBLENBSEQ7O0VBS0F4MUIsTUFBTSxDQUFDaTFCLEVBQVAsQ0FBVStDLE1BQVYsR0FBbUI7SUFDbEJtQixJQUFJLEVBQUUsR0FEWTtJQUVsQkMsSUFBSSxFQUFFLEdBRlk7SUFJbEI7SUFDQWhXLFFBQVEsRUFBRTtFQUxRLENBQW5CLENBNTRQOEUsQ0FxNVA5RTtFQUNBOztFQUNBcGpCLE1BQU0sQ0FBQ0csRUFBUCxDQUFVazVCLEtBQVYsR0FBa0IsVUFBVUMsSUFBVixFQUFnQngxQixJQUFoQixFQUF1QjtJQUN4Q3cxQixJQUFJLEdBQUd0NUIsTUFBTSxDQUFDaTFCLEVBQVAsR0FBWWoxQixNQUFNLENBQUNpMUIsRUFBUCxDQUFVK0MsTUFBVixDQUFrQnNCLElBQWxCLEtBQTRCQSxJQUF4QyxHQUErQ0EsSUFBdEQ7SUFDQXgxQixJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFmO0lBRUEsT0FBTyxLQUFLa1csS0FBTCxDQUFZbFcsSUFBWixFQUFrQixVQUFVcVUsSUFBVixFQUFnQm1ILEtBQWhCLEVBQXdCO01BQ2hELElBQUlpYSxPQUFPLEdBQUdwNkIsTUFBTSxDQUFDbWUsVUFBUCxDQUFtQm5GLElBQW5CLEVBQXlCbWhCLElBQXpCLENBQWQ7O01BQ0FoYSxLQUFLLENBQUNFLElBQU4sR0FBYSxZQUFXO1FBQ3ZCcmdCLE1BQU0sQ0FBQ3E2QixZQUFQLENBQXFCRCxPQUFyQjtNQUNBLENBRkQ7SUFHQSxDQUxNLENBQVA7RUFNQSxDQVZEOztFQWFBLENBQUUsWUFBVztJQUNaLElBQUlyeEIsQ0FBSjtJQUFBLElBQ0N3RyxLQUFLLEdBQUcxUCxRQUFRLENBQUNzTixhQUFULENBQXdCLE9BQXhCLENBRFQ7SUFBQSxJQUVDRCxHQUFHLEdBQUdyTixRQUFRLENBQUNzTixhQUFULENBQXdCLEtBQXhCLENBRlA7SUFBQSxJQUdDdEYsTUFBTSxHQUFHaEksUUFBUSxDQUFDc04sYUFBVCxDQUF3QixRQUF4QixDQUhWO0lBQUEsSUFJQ3lyQixHQUFHLEdBQUcvd0IsTUFBTSxDQUFDZ0gsV0FBUCxDQUFvQmhQLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsUUFBeEIsQ0FBcEIsQ0FKUCxDQURZLENBT1o7O0lBQ0FELEdBQUcsR0FBR3JOLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBTjtJQUNBRCxHQUFHLENBQUNkLFlBQUosQ0FBa0IsV0FBbEIsRUFBK0IsR0FBL0I7SUFDQWMsR0FBRyxDQUFDb0MsU0FBSixHQUFnQixvRUFBaEI7SUFDQXZHLENBQUMsR0FBR21FLEdBQUcsQ0FBQ25CLG9CQUFKLENBQTBCLEdBQTFCLEVBQWlDLENBQWpDLENBQUosQ0FYWSxDQWFaO0lBQ0E7O0lBQ0F3RCxLQUFLLENBQUNuRCxZQUFOLENBQW9CLE1BQXBCLEVBQTRCLFVBQTVCO0lBQ0FjLEdBQUcsQ0FBQzJCLFdBQUosQ0FBaUJVLEtBQWpCO0lBRUF4RyxDQUFDLEdBQUdtRSxHQUFHLENBQUNuQixvQkFBSixDQUEwQixHQUExQixFQUFpQyxDQUFqQyxDQUFKLENBbEJZLENBb0JaOztJQUNBaEQsQ0FBQyxDQUFDMFYsS0FBRixDQUFRQyxPQUFSLEdBQWtCLFNBQWxCLENBckJZLENBdUJaO0lBQ0E7O0lBQ0EvZCxPQUFPLENBQUMyNUIsZUFBUixHQUEwQnB0QixHQUFHLENBQUMwQixTQUFKLEtBQWtCLEdBQTVDLENBekJZLENBMkJaO0lBQ0E7O0lBQ0FqTyxPQUFPLENBQUM4ZCxLQUFSLEdBQWdCLE1BQU12UyxJQUFOLENBQVluRCxDQUFDLENBQUNvRCxZQUFGLENBQWdCLE9BQWhCLENBQVosQ0FBaEIsQ0E3QlksQ0ErQlo7SUFDQTs7SUFDQXhMLE9BQU8sQ0FBQzQ1QixjQUFSLEdBQXlCeHhCLENBQUMsQ0FBQ29ELFlBQUYsQ0FBZ0IsTUFBaEIsTUFBNkIsSUFBdEQsQ0FqQ1ksQ0FtQ1o7O0lBQ0F4TCxPQUFPLENBQUM2NUIsT0FBUixHQUFrQixDQUFDLENBQUNqckIsS0FBSyxDQUFDMUksS0FBMUIsQ0FwQ1ksQ0FzQ1o7SUFDQTs7SUFDQWxHLE9BQU8sQ0FBQzg1QixXQUFSLEdBQXNCN0IsR0FBRyxDQUFDaGxCLFFBQTFCLENBeENZLENBMENaOztJQUNBalQsT0FBTyxDQUFDKzVCLE9BQVIsR0FBa0IsQ0FBQyxDQUFDNzZCLFFBQVEsQ0FBQ3NOLGFBQVQsQ0FBd0IsTUFBeEIsRUFBaUN1dEIsT0FBckQsQ0EzQ1ksQ0E2Q1o7SUFDQTs7SUFDQTd5QixNQUFNLENBQUM2TCxRQUFQLEdBQWtCLElBQWxCO0lBQ0EvUyxPQUFPLENBQUNnNkIsV0FBUixHQUFzQixDQUFDL0IsR0FBRyxDQUFDbGxCLFFBQTNCLENBaERZLENBa0RaO0lBQ0E7O0lBQ0FuRSxLQUFLLEdBQUcxUCxRQUFRLENBQUNzTixhQUFULENBQXdCLE9BQXhCLENBQVI7SUFDQW9DLEtBQUssQ0FBQ25ELFlBQU4sQ0FBb0IsT0FBcEIsRUFBNkIsRUFBN0I7SUFDQXpMLE9BQU8sQ0FBQzRPLEtBQVIsR0FBZ0JBLEtBQUssQ0FBQ3BELFlBQU4sQ0FBb0IsT0FBcEIsTUFBa0MsRUFBbEQsQ0F0RFksQ0F3RFo7O0lBQ0FvRCxLQUFLLENBQUMxSSxLQUFOLEdBQWMsR0FBZDtJQUNBMEksS0FBSyxDQUFDbkQsWUFBTixDQUFvQixNQUFwQixFQUE0QixPQUE1QjtJQUNBekwsT0FBTyxDQUFDaTZCLFVBQVIsR0FBcUJyckIsS0FBSyxDQUFDMUksS0FBTixLQUFnQixHQUFyQztFQUNBLENBNUREOztFQStEQSxJQUFJZzBCLE9BQU8sR0FBRyxLQUFkO0VBQUEsSUFDQ0MsT0FBTyxHQUFHLGtCQURYO0VBR0FqNkIsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLENBQWtCO0lBQ2pCcU4sR0FBRyxFQUFFLGFBQVU3SixLQUFWLEVBQWtCO01BQ3RCLElBQUlzWixLQUFKO01BQUEsSUFBV2hlLEdBQVg7TUFBQSxJQUFnQjJCLFVBQWhCO01BQUEsSUFDQ3JCLElBQUksR0FBRyxLQUFNLENBQU4sQ0FEUjs7TUFHQSxJQUFLLENBQUNHLFNBQVMsQ0FBQ2hCLE1BQWhCLEVBQXlCO1FBQ3hCLElBQUthLElBQUwsRUFBWTtVQUNYMGQsS0FBSyxHQUFHdGYsTUFBTSxDQUFDazZCLFFBQVAsQ0FBaUJ0NEIsSUFBSSxDQUFDa0MsSUFBdEIsS0FDUDlELE1BQU0sQ0FBQ2s2QixRQUFQLENBQWlCdDRCLElBQUksQ0FBQ21ELFFBQUwsQ0FBY0MsV0FBZCxFQUFqQixDQUREOztVQUdBLElBQ0NzYSxLQUFLLElBQ0wsU0FBU0EsS0FEVCxJQUVBLENBQUVoZSxHQUFHLEdBQUdnZSxLQUFLLENBQUNwZSxHQUFOLENBQVdVLElBQVgsRUFBaUIsT0FBakIsQ0FBUixNQUF5Q3dCLFNBSDFDLEVBSUU7WUFDRCxPQUFPOUIsR0FBUDtVQUNBOztVQUVEQSxHQUFHLEdBQUdNLElBQUksQ0FBQ29FLEtBQVg7VUFFQSxPQUFPLE9BQU8xRSxHQUFQLEtBQWUsUUFBZixHQUVOO1VBQ0FBLEdBQUcsQ0FBQ2tDLE9BQUosQ0FBYXcyQixPQUFiLEVBQXNCLEVBQXRCLENBSE0sR0FLTjtVQUNBMTRCLEdBQUcsSUFBSSxJQUFQLEdBQWMsRUFBZCxHQUFtQkEsR0FOcEI7UUFPQTs7UUFFRDtNQUNBOztNQUVEMkIsVUFBVSxHQUFHakQsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQitDLEtBQW5CLENBQWI7TUFFQSxPQUFPLEtBQUt2RSxJQUFMLENBQVcsVUFBVUksQ0FBVixFQUFjO1FBQy9CLElBQUlnTyxHQUFKOztRQUVBLElBQUssS0FBS3ZMLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7VUFDMUI7UUFDQTs7UUFFRCxJQUFLckIsVUFBTCxFQUFrQjtVQUNqQjRNLEdBQUcsR0FBRzdKLEtBQUssQ0FBQy9FLElBQU4sQ0FBWSxJQUFaLEVBQWtCWSxDQUFsQixFQUFxQjdCLE1BQU0sQ0FBRSxJQUFGLENBQU4sQ0FBZTZQLEdBQWYsRUFBckIsQ0FBTjtRQUNBLENBRkQsTUFFTztVQUNOQSxHQUFHLEdBQUc3SixLQUFOO1FBQ0EsQ0FYOEIsQ0FhL0I7OztRQUNBLElBQUs2SixHQUFHLElBQUksSUFBWixFQUFtQjtVQUNsQkEsR0FBRyxHQUFHLEVBQU47UUFDQSxDQUZELE1BRU8sSUFBSyxPQUFPQSxHQUFQLEtBQWUsUUFBcEIsRUFBK0I7VUFDckNBLEdBQUcsSUFBSSxFQUFQO1FBQ0EsQ0FGTSxNQUVBLElBQUs3UCxNQUFNLENBQUNtRCxPQUFQLENBQWdCME0sR0FBaEIsQ0FBTCxFQUE2QjtVQUNuQ0EsR0FBRyxHQUFHN1AsTUFBTSxDQUFDMkIsR0FBUCxDQUFZa08sR0FBWixFQUFpQixVQUFVN0osS0FBVixFQUFrQjtZQUN4QyxPQUFPQSxLQUFLLElBQUksSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBSyxHQUFHLEVBQXBDO1VBQ0EsQ0FGSyxDQUFOO1FBR0E7O1FBRURzWixLQUFLLEdBQUd0ZixNQUFNLENBQUNrNkIsUUFBUCxDQUFpQixLQUFLcDJCLElBQXRCLEtBQWdDOUQsTUFBTSxDQUFDazZCLFFBQVAsQ0FBaUIsS0FBS24xQixRQUFMLENBQWNDLFdBQWQsRUFBakIsQ0FBeEMsQ0F4QitCLENBMEIvQjs7UUFDQSxJQUFLLENBQUNzYSxLQUFELElBQVUsRUFBRyxTQUFTQSxLQUFaLENBQVYsSUFBaUNBLEtBQUssQ0FBQ3NVLEdBQU4sQ0FBVyxJQUFYLEVBQWlCL2pCLEdBQWpCLEVBQXNCLE9BQXRCLE1BQW9Dek0sU0FBMUUsRUFBc0Y7VUFDckYsS0FBSzRDLEtBQUwsR0FBYTZKLEdBQWI7UUFDQTtNQUNELENBOUJNLENBQVA7SUErQkE7RUFqRWdCLENBQWxCO0VBb0VBN1AsTUFBTSxDQUFDd0MsTUFBUCxDQUFlO0lBQ2QwM0IsUUFBUSxFQUFFO01BQ1R0WCxNQUFNLEVBQUU7UUFDUDFoQixHQUFHLEVBQUUsYUFBVVUsSUFBVixFQUFpQjtVQUNyQixJQUFJaU8sR0FBRyxHQUFHN1AsTUFBTSxDQUFDb08sSUFBUCxDQUFZd0IsSUFBWixDQUFrQmhPLElBQWxCLEVBQXdCLE9BQXhCLENBQVY7VUFDQSxPQUFPaU8sR0FBRyxJQUFJLElBQVAsR0FDTkEsR0FETSxHQUdOO1VBQ0E7VUFDQTtVQUNBO1VBQ0E3UCxNQUFNLENBQUMyRSxJQUFQLENBQWEzRSxNQUFNLENBQUNrRixJQUFQLENBQWF0RCxJQUFiLENBQWIsRUFBbUM0QixPQUFuQyxDQUE0Q3kyQixPQUE1QyxFQUFxRCxHQUFyRCxDQVBEO1FBUUE7TUFYTSxDQURDO01BY1RqekIsTUFBTSxFQUFFO1FBQ1A5RixHQUFHLEVBQUUsYUFBVVUsSUFBVixFQUFpQjtVQUNyQixJQUFJb0UsS0FBSjtVQUFBLElBQVc0YyxNQUFYO1VBQUEsSUFDQy9mLE9BQU8sR0FBR2pCLElBQUksQ0FBQ2lCLE9BRGhCO1VBQUEsSUFFQzZWLEtBQUssR0FBRzlXLElBQUksQ0FBQ29SLGFBRmQ7VUFBQSxJQUdDeVMsR0FBRyxHQUFHN2pCLElBQUksQ0FBQ2tDLElBQUwsS0FBYyxZQUFkLElBQThCNFUsS0FBSyxHQUFHLENBSDdDO1VBQUEsSUFJQ3dELE1BQU0sR0FBR3VKLEdBQUcsR0FBRyxJQUFILEdBQVUsRUFKdkI7VUFBQSxJQUtDamdCLEdBQUcsR0FBR2lnQixHQUFHLEdBQUcvTSxLQUFLLEdBQUcsQ0FBWCxHQUFlN1YsT0FBTyxDQUFDOUIsTUFMakM7VUFBQSxJQU1DYyxDQUFDLEdBQUc2VyxLQUFLLEdBQUcsQ0FBUixHQUNIbFQsR0FERyxHQUVIaWdCLEdBQUcsR0FBRy9NLEtBQUgsR0FBVyxDQVJoQixDQURxQixDQVdyQjs7VUFDQSxPQUFRN1csQ0FBQyxHQUFHMkQsR0FBWixFQUFpQjNELENBQUMsRUFBbEIsRUFBdUI7WUFDdEIrZ0IsTUFBTSxHQUFHL2YsT0FBTyxDQUFFaEIsQ0FBRixDQUFoQixDQURzQixDQUd0Qjs7WUFDQSxJQUFLLENBQUUrZ0IsTUFBTSxDQUFDN1AsUUFBUCxJQUFtQmxSLENBQUMsS0FBSzZXLEtBQTNCLE9BRUg7WUFDRTVZLE9BQU8sQ0FBQ2c2QixXQUFSLEdBQ0QsQ0FBQ2xYLE1BQU0sQ0FBQy9QLFFBRFAsR0FFRCtQLE1BQU0sQ0FBQ3RYLFlBQVAsQ0FBcUIsVUFBckIsTUFBc0MsSUFMcEMsTUFNRCxDQUFDc1gsTUFBTSxDQUFDalgsVUFBUCxDQUFrQmtILFFBQW5CLElBQ0QsQ0FBQzdTLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUI2ZCxNQUFNLENBQUNqWCxVQUF4QixFQUFvQyxVQUFwQyxDQVBDLENBQUwsRUFPeUQ7Y0FFeEQ7Y0FDQTNGLEtBQUssR0FBR2hHLE1BQU0sQ0FBRTRpQixNQUFGLENBQU4sQ0FBaUIvUyxHQUFqQixFQUFSLENBSHdELENBS3hEOztjQUNBLElBQUs0VixHQUFMLEVBQVc7Z0JBQ1YsT0FBT3pmLEtBQVA7Y0FDQSxDQVJ1RCxDQVV4RDs7O2NBQ0FrVyxNQUFNLENBQUMxYyxJQUFQLENBQWF3RyxLQUFiO1lBQ0E7VUFDRDs7VUFFRCxPQUFPa1csTUFBUDtRQUNBLENBeENNO1FBMENQMFgsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFnQm9FLEtBQWhCLEVBQXdCO1VBQzVCLElBQUltMEIsU0FBSjtVQUFBLElBQWV2WCxNQUFmO1VBQUEsSUFDQy9mLE9BQU8sR0FBR2pCLElBQUksQ0FBQ2lCLE9BRGhCO1VBQUEsSUFFQ3FaLE1BQU0sR0FBR2xjLE1BQU0sQ0FBQ21GLFNBQVAsQ0FBa0JhLEtBQWxCLENBRlY7VUFBQSxJQUdDbkUsQ0FBQyxHQUFHZ0IsT0FBTyxDQUFDOUIsTUFIYjs7VUFLQSxPQUFRYyxDQUFDLEVBQVQsRUFBYztZQUNiK2dCLE1BQU0sR0FBRy9mLE9BQU8sQ0FBRWhCLENBQUYsQ0FBaEI7O1lBRUEsSUFBSzdCLE1BQU0sQ0FBQ3VGLE9BQVAsQ0FBZ0J2RixNQUFNLENBQUNrNkIsUUFBUCxDQUFnQnRYLE1BQWhCLENBQXVCMWhCLEdBQXZCLENBQTRCMGhCLE1BQTVCLENBQWhCLEVBQXNEMUcsTUFBdEQsSUFBaUUsQ0FBQyxDQUF2RSxFQUEyRTtjQUUxRTtjQUNBO2NBQ0E7Y0FDQTtjQUNBLElBQUk7Z0JBQ0gwRyxNQUFNLENBQUM3UCxRQUFQLEdBQWtCb25CLFNBQVMsR0FBRyxJQUE5QjtjQUVBLENBSEQsQ0FHRSxPQUFRdHdCLENBQVIsRUFBWTtnQkFFYjtnQkFDQStZLE1BQU0sQ0FBQ3dYLFlBQVA7Y0FDQTtZQUVELENBZkQsTUFlTztjQUNOeFgsTUFBTSxDQUFDN1AsUUFBUCxHQUFrQixLQUFsQjtZQUNBO1VBQ0QsQ0EzQjJCLENBNkI1Qjs7O1VBQ0EsSUFBSyxDQUFDb25CLFNBQU4sRUFBa0I7WUFDakJ2NEIsSUFBSSxDQUFDb1IsYUFBTCxHQUFxQixDQUFDLENBQXRCO1VBQ0E7O1VBRUQsT0FBT25RLE9BQVA7UUFDQTtNQTdFTTtJQWRDO0VBREksQ0FBZixFQTFpUThFLENBMm9ROUU7O0VBQ0E3QyxNQUFNLENBQUN5QixJQUFQLENBQWEsQ0FBRSxPQUFGLEVBQVcsVUFBWCxDQUFiLEVBQXNDLFlBQVc7SUFDaER6QixNQUFNLENBQUNrNkIsUUFBUCxDQUFpQixJQUFqQixJQUEwQjtNQUN6QnRHLEdBQUcsRUFBRSxhQUFVaHlCLElBQVYsRUFBZ0JvRSxLQUFoQixFQUF3QjtRQUM1QixJQUFLaEcsTUFBTSxDQUFDbUQsT0FBUCxDQUFnQjZDLEtBQWhCLENBQUwsRUFBK0I7VUFDOUIsT0FBU3BFLElBQUksQ0FBQ2tSLE9BQUwsR0FBZTlTLE1BQU0sQ0FBQ3VGLE9BQVAsQ0FBZ0J2RixNQUFNLENBQUU0QixJQUFGLENBQU4sQ0FBZWlPLEdBQWYsRUFBaEIsRUFBc0M3SixLQUF0QyxJQUFnRCxDQUFDLENBQXpFO1FBQ0E7TUFDRDtJQUx3QixDQUExQjs7SUFPQSxJQUFLLENBQUNsRyxPQUFPLENBQUM2NUIsT0FBZCxFQUF3QjtNQUN2QjM1QixNQUFNLENBQUNrNkIsUUFBUCxDQUFpQixJQUFqQixFQUF3Qmg1QixHQUF4QixHQUE4QixVQUFVVSxJQUFWLEVBQWlCO1FBQzlDLE9BQU9BLElBQUksQ0FBQzBKLFlBQUwsQ0FBbUIsT0FBbkIsTUFBaUMsSUFBakMsR0FBd0MsSUFBeEMsR0FBK0MxSixJQUFJLENBQUNvRSxLQUEzRDtNQUNBLENBRkQ7SUFHQTtFQUNELENBYkQ7RUFrQkEsSUFBSXEwQixRQUFKO0VBQUEsSUFBY0MsUUFBZDtFQUFBLElBQ0MzdEIsVUFBVSxHQUFHM00sTUFBTSxDQUFDMFAsSUFBUCxDQUFZL0MsVUFEMUI7RUFBQSxJQUVDNHRCLFdBQVcsR0FBRyx5QkFGZjtFQUFBLElBR0NkLGVBQWUsR0FBRzM1QixPQUFPLENBQUMyNUIsZUFIM0I7RUFBQSxJQUlDZSxXQUFXLEdBQUcxNkIsT0FBTyxDQUFDNE8sS0FKdkI7RUFNQTFPLE1BQU0sQ0FBQ0csRUFBUCxDQUFVcUMsTUFBVixDQUFrQjtJQUNqQm9OLElBQUksRUFBRSxjQUFVaE4sSUFBVixFQUFnQm9ELEtBQWhCLEVBQXdCO01BQzdCLE9BQU9tYixNQUFNLENBQUUsSUFBRixFQUFRbmhCLE1BQU0sQ0FBQzRQLElBQWYsRUFBcUJoTixJQUFyQixFQUEyQm9ELEtBQTNCLEVBQWtDakUsU0FBUyxDQUFDaEIsTUFBVixHQUFtQixDQUFyRCxDQUFiO0lBQ0EsQ0FIZ0I7SUFLakIwNUIsVUFBVSxFQUFFLG9CQUFVNzNCLElBQVYsRUFBaUI7TUFDNUIsT0FBTyxLQUFLbkIsSUFBTCxDQUFXLFlBQVc7UUFDNUJ6QixNQUFNLENBQUN5NkIsVUFBUCxDQUFtQixJQUFuQixFQUF5QjczQixJQUF6QjtNQUNBLENBRk0sQ0FBUDtJQUdBO0VBVGdCLENBQWxCO0VBWUE1QyxNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFDZG9OLElBQUksRUFBRSxjQUFVaE8sSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCb0QsS0FBdEIsRUFBOEI7TUFDbkMsSUFBSTFFLEdBQUo7TUFBQSxJQUFTZ2UsS0FBVDtNQUFBLElBQ0NvYixLQUFLLEdBQUc5NEIsSUFBSSxDQUFDMEMsUUFEZCxDQURtQyxDQUluQzs7TUFDQSxJQUFLbzJCLEtBQUssS0FBSyxDQUFWLElBQWVBLEtBQUssS0FBSyxDQUF6QixJQUE4QkEsS0FBSyxLQUFLLENBQTdDLEVBQWlEO1FBQ2hEO01BQ0EsQ0FQa0MsQ0FTbkM7OztNQUNBLElBQUssT0FBTzk0QixJQUFJLENBQUMwSixZQUFaLEtBQTZCLFdBQWxDLEVBQWdEO1FBQy9DLE9BQU90TCxNQUFNLENBQUN3Z0IsSUFBUCxDQUFhNWUsSUFBYixFQUFtQmdCLElBQW5CLEVBQXlCb0QsS0FBekIsQ0FBUDtNQUNBLENBWmtDLENBY25DO01BQ0E7OztNQUNBLElBQUswMEIsS0FBSyxLQUFLLENBQVYsSUFBZSxDQUFDMTZCLE1BQU0sQ0FBQzRXLFFBQVAsQ0FBaUJoVixJQUFqQixDQUFyQixFQUErQztRQUM5Q2dCLElBQUksR0FBR0EsSUFBSSxDQUFDb0MsV0FBTCxFQUFQO1FBQ0FzYSxLQUFLLEdBQUd0ZixNQUFNLENBQUMyNkIsU0FBUCxDQUFrQi8zQixJQUFsQixNQUNMNUMsTUFBTSxDQUFDMFAsSUFBUCxDQUFZaEYsS0FBWixDQUFrQmt3QixJQUFsQixDQUF1QnZ2QixJQUF2QixDQUE2QnpJLElBQTdCLElBQXNDMDNCLFFBQXRDLEdBQWlERCxRQUQ1QyxDQUFSO01BRUE7O01BRUQsSUFBS3IwQixLQUFLLEtBQUs1QyxTQUFmLEVBQTJCO1FBQzFCLElBQUs0QyxLQUFLLEtBQUssSUFBZixFQUFzQjtVQUNyQmhHLE1BQU0sQ0FBQ3k2QixVQUFQLENBQW1CNzRCLElBQW5CLEVBQXlCZ0IsSUFBekI7VUFDQTtRQUNBOztRQUVELElBQUswYyxLQUFLLElBQUksU0FBU0EsS0FBbEIsSUFDSixDQUFFaGUsR0FBRyxHQUFHZ2UsS0FBSyxDQUFDc1UsR0FBTixDQUFXaHlCLElBQVgsRUFBaUJvRSxLQUFqQixFQUF3QnBELElBQXhCLENBQVIsTUFBNkNRLFNBRDlDLEVBQzBEO1VBQ3pELE9BQU85QixHQUFQO1FBQ0E7O1FBRURNLElBQUksQ0FBQzJKLFlBQUwsQ0FBbUIzSSxJQUFuQixFQUF5Qm9ELEtBQUssR0FBRyxFQUFqQztRQUNBLE9BQU9BLEtBQVA7TUFDQTs7TUFFRCxJQUFLc1osS0FBSyxJQUFJLFNBQVNBLEtBQWxCLElBQTJCLENBQUVoZSxHQUFHLEdBQUdnZSxLQUFLLENBQUNwZSxHQUFOLENBQVdVLElBQVgsRUFBaUJnQixJQUFqQixDQUFSLE1BQXNDLElBQXRFLEVBQTZFO1FBQzVFLE9BQU90QixHQUFQO01BQ0E7O01BRURBLEdBQUcsR0FBR3RCLE1BQU0sQ0FBQ29PLElBQVAsQ0FBWXdCLElBQVosQ0FBa0JoTyxJQUFsQixFQUF3QmdCLElBQXhCLENBQU4sQ0F6Q21DLENBMkNuQzs7TUFDQSxPQUFPdEIsR0FBRyxJQUFJLElBQVAsR0FBYzhCLFNBQWQsR0FBMEI5QixHQUFqQztJQUNBLENBOUNhO0lBZ0RkcTVCLFNBQVMsRUFBRTtNQUNWNzJCLElBQUksRUFBRTtRQUNMOHZCLEdBQUcsRUFBRSxhQUFVaHlCLElBQVYsRUFBZ0JvRSxLQUFoQixFQUF3QjtVQUM1QixJQUFLLENBQUNsRyxPQUFPLENBQUNpNkIsVUFBVCxJQUF1Qi96QixLQUFLLEtBQUssT0FBakMsSUFDSmhHLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJuRCxJQUFqQixFQUF1QixPQUF2QixDQURELEVBQ29DO1lBRW5DO1lBQ0E7WUFDQSxJQUFJaU8sR0FBRyxHQUFHak8sSUFBSSxDQUFDb0UsS0FBZjtZQUNBcEUsSUFBSSxDQUFDMkosWUFBTCxDQUFtQixNQUFuQixFQUEyQnZGLEtBQTNCOztZQUNBLElBQUs2SixHQUFMLEVBQVc7Y0FDVmpPLElBQUksQ0FBQ29FLEtBQUwsR0FBYTZKLEdBQWI7WUFDQTs7WUFDRCxPQUFPN0osS0FBUDtVQUNBO1FBQ0Q7TUFkSTtJQURJLENBaERHO0lBbUVkeTBCLFVBQVUsRUFBRSxvQkFBVTc0QixJQUFWLEVBQWdCb0UsS0FBaEIsRUFBd0I7TUFDbkMsSUFBSXBELElBQUo7TUFBQSxJQUFVaTRCLFFBQVY7TUFBQSxJQUNDaDVCLENBQUMsR0FBRyxDQURMO01BQUEsSUFFQ2k1QixTQUFTLEdBQUc5MEIsS0FBSyxJQUFJQSxLQUFLLENBQUMwRSxLQUFOLENBQWE2TyxTQUFiLENBRnRCOztNQUlBLElBQUt1aEIsU0FBUyxJQUFJbDVCLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBcEMsRUFBd0M7UUFDdkMsT0FBVTFCLElBQUksR0FBR2s0QixTQUFTLENBQUVqNUIsQ0FBQyxFQUFILENBQTFCLEVBQXNDO1VBQ3JDZzVCLFFBQVEsR0FBRzc2QixNQUFNLENBQUMrNkIsT0FBUCxDQUFnQm40QixJQUFoQixLQUEwQkEsSUFBckMsQ0FEcUMsQ0FHckM7O1VBQ0EsSUFBSzVDLE1BQU0sQ0FBQzBQLElBQVAsQ0FBWWhGLEtBQVosQ0FBa0Jrd0IsSUFBbEIsQ0FBdUJ2dkIsSUFBdkIsQ0FBNkJ6SSxJQUE3QixDQUFMLEVBQTJDO1lBRTFDO1lBQ0EsSUFBSzQzQixXQUFXLElBQUlmLGVBQWYsSUFBa0MsQ0FBQ2MsV0FBVyxDQUFDbHZCLElBQVosQ0FBa0J6SSxJQUFsQixDQUF4QyxFQUFtRTtjQUNsRWhCLElBQUksQ0FBRWk1QixRQUFGLENBQUosR0FBbUIsS0FBbkIsQ0FEa0UsQ0FHbkU7Y0FDQTtZQUNDLENBTEQsTUFLTztjQUNOajVCLElBQUksQ0FBRTVCLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0IsYUFBYWpDLElBQS9CLENBQUYsQ0FBSixHQUNDaEIsSUFBSSxDQUFFaTVCLFFBQUYsQ0FBSixHQUFtQixLQURwQjtZQUVBLENBWHlDLENBYTNDOztVQUNDLENBZEQsTUFjTztZQUNONzZCLE1BQU0sQ0FBQzRQLElBQVAsQ0FBYWhPLElBQWIsRUFBbUJnQixJQUFuQixFQUF5QixFQUF6QjtVQUNBOztVQUVEaEIsSUFBSSxDQUFDa0ssZUFBTCxDQUFzQjJ0QixlQUFlLEdBQUc3MkIsSUFBSCxHQUFVaTRCLFFBQS9DO1FBQ0E7TUFDRDtJQUNEO0VBbEdhLENBQWYsRUFoclE4RSxDQXF4UTlFOztFQUNBUCxRQUFRLEdBQUc7SUFDVjFHLEdBQUcsRUFBRSxhQUFVaHlCLElBQVYsRUFBZ0JvRSxLQUFoQixFQUF1QnBELElBQXZCLEVBQThCO01BQ2xDLElBQUtvRCxLQUFLLEtBQUssS0FBZixFQUF1QjtRQUV0QjtRQUNBaEcsTUFBTSxDQUFDeTZCLFVBQVAsQ0FBbUI3NEIsSUFBbkIsRUFBeUJnQixJQUF6QjtNQUNBLENBSkQsTUFJTyxJQUFLNDNCLFdBQVcsSUFBSWYsZUFBZixJQUFrQyxDQUFDYyxXQUFXLENBQUNsdkIsSUFBWixDQUFrQnpJLElBQWxCLENBQXhDLEVBQW1FO1FBRXpFO1FBQ0FoQixJQUFJLENBQUMySixZQUFMLENBQW1CLENBQUNrdUIsZUFBRCxJQUFvQno1QixNQUFNLENBQUMrNkIsT0FBUCxDQUFnQm40QixJQUFoQixDQUFwQixJQUE4Q0EsSUFBakUsRUFBdUVBLElBQXZFO01BRUEsQ0FMTSxNQUtBO1FBRU47UUFDQTtRQUNBaEIsSUFBSSxDQUFFNUIsTUFBTSxDQUFDNkUsU0FBUCxDQUFrQixhQUFhakMsSUFBL0IsQ0FBRixDQUFKLEdBQWdEaEIsSUFBSSxDQUFFZ0IsSUFBRixDQUFKLEdBQWUsSUFBL0Q7TUFDQTs7TUFDRCxPQUFPQSxJQUFQO0lBQ0E7RUFsQlMsQ0FBWDtFQXFCQTVDLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYXpCLE1BQU0sQ0FBQzBQLElBQVAsQ0FBWWhGLEtBQVosQ0FBa0Jrd0IsSUFBbEIsQ0FBdUIzYSxNQUF2QixDQUE4QnZWLEtBQTlCLENBQXFDLE1BQXJDLENBQWIsRUFBNEQsVUFBVTdJLENBQVYsRUFBYWUsSUFBYixFQUFvQjtJQUMvRSxJQUFJbzRCLE1BQU0sR0FBR3J1QixVQUFVLENBQUUvSixJQUFGLENBQVYsSUFBc0I1QyxNQUFNLENBQUNvTyxJQUFQLENBQVl3QixJQUEvQzs7SUFFQSxJQUFLNHFCLFdBQVcsSUFBSWYsZUFBZixJQUFrQyxDQUFDYyxXQUFXLENBQUNsdkIsSUFBWixDQUFrQnpJLElBQWxCLENBQXhDLEVBQW1FO01BQ2xFK0osVUFBVSxDQUFFL0osSUFBRixDQUFWLEdBQXFCLFVBQVVoQixJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0JpRSxLQUF0QixFQUE4QjtRQUNsRCxJQUFJdkYsR0FBSixFQUFTK2tCLE1BQVQ7O1FBQ0EsSUFBSyxDQUFDeGYsS0FBTixFQUFjO1VBRWI7VUFDQXdmLE1BQU0sR0FBRzFaLFVBQVUsQ0FBRS9KLElBQUYsQ0FBbkI7VUFDQStKLFVBQVUsQ0FBRS9KLElBQUYsQ0FBVixHQUFxQnRCLEdBQXJCO1VBQ0FBLEdBQUcsR0FBRzA1QixNQUFNLENBQUVwNUIsSUFBRixFQUFRZ0IsSUFBUixFQUFjaUUsS0FBZCxDQUFOLElBQStCLElBQS9CLEdBQ0xqRSxJQUFJLENBQUNvQyxXQUFMLEVBREssR0FFTCxJQUZEO1VBR0EySCxVQUFVLENBQUUvSixJQUFGLENBQVYsR0FBcUJ5akIsTUFBckI7UUFDQTs7UUFDRCxPQUFPL2tCLEdBQVA7TUFDQSxDQWJEO0lBY0EsQ0FmRCxNQWVPO01BQ05xTCxVQUFVLENBQUUvSixJQUFGLENBQVYsR0FBcUIsVUFBVWhCLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQmlFLEtBQXRCLEVBQThCO1FBQ2xELElBQUssQ0FBQ0EsS0FBTixFQUFjO1VBQ2IsT0FBT2pGLElBQUksQ0FBRTVCLE1BQU0sQ0FBQzZFLFNBQVAsQ0FBa0IsYUFBYWpDLElBQS9CLENBQUYsQ0FBSixHQUNOQSxJQUFJLENBQUNvQyxXQUFMLEVBRE0sR0FFTixJQUZEO1FBR0E7TUFDRCxDQU5EO0lBT0E7RUFDRCxDQTNCRCxFQTN5UThFLENBdzBROUU7O0VBQ0EsSUFBSyxDQUFDdzFCLFdBQUQsSUFBZ0IsQ0FBQ2YsZUFBdEIsRUFBd0M7SUFDdkN6NUIsTUFBTSxDQUFDMjZCLFNBQVAsQ0FBaUIzMEIsS0FBakIsR0FBeUI7TUFDeEI0dEIsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFnQm9FLEtBQWhCLEVBQXVCcEQsSUFBdkIsRUFBOEI7UUFDbEMsSUFBSzVDLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJuRCxJQUFqQixFQUF1QixPQUF2QixDQUFMLEVBQXdDO1VBRXZDO1VBQ0FBLElBQUksQ0FBQzhVLFlBQUwsR0FBb0IxUSxLQUFwQjtRQUNBLENBSkQsTUFJTztVQUVOO1VBQ0EsT0FBT3EwQixRQUFRLElBQUlBLFFBQVEsQ0FBQ3pHLEdBQVQsQ0FBY2h5QixJQUFkLEVBQW9Cb0UsS0FBcEIsRUFBMkJwRCxJQUEzQixDQUFuQjtRQUNBO01BQ0Q7SUFYdUIsQ0FBekI7RUFhQSxDQXYxUTZFLENBeTFROUU7OztFQUNBLElBQUssQ0FBQzYyQixlQUFOLEVBQXdCO0lBRXZCO0lBQ0E7SUFDQVksUUFBUSxHQUFHO01BQ1Z6RyxHQUFHLEVBQUUsYUFBVWh5QixJQUFWLEVBQWdCb0UsS0FBaEIsRUFBdUJwRCxJQUF2QixFQUE4QjtRQUVsQztRQUNBLElBQUl0QixHQUFHLEdBQUdNLElBQUksQ0FBQzJNLGdCQUFMLENBQXVCM0wsSUFBdkIsQ0FBVjs7UUFDQSxJQUFLLENBQUN0QixHQUFOLEVBQVk7VUFDWE0sSUFBSSxDQUFDcTVCLGdCQUFMLENBQ0czNUIsR0FBRyxHQUFHTSxJQUFJLENBQUNrSixhQUFMLENBQW1Cb3dCLGVBQW5CLENBQW9DdDRCLElBQXBDLENBRFQ7UUFHQTs7UUFFRHRCLEdBQUcsQ0FBQzBFLEtBQUosR0FBWUEsS0FBSyxJQUFJLEVBQXJCLENBVmtDLENBWWxDOztRQUNBLElBQUtwRCxJQUFJLEtBQUssT0FBVCxJQUFvQm9ELEtBQUssS0FBS3BFLElBQUksQ0FBQzBKLFlBQUwsQ0FBbUIxSSxJQUFuQixDQUFuQyxFQUErRDtVQUM5RCxPQUFPb0QsS0FBUDtRQUNBO01BQ0Q7SUFqQlMsQ0FBWCxDQUp1QixDQXdCdkI7O0lBQ0EyRyxVQUFVLENBQUMxQixFQUFYLEdBQWdCMEIsVUFBVSxDQUFDL0osSUFBWCxHQUFrQitKLFVBQVUsQ0FBQ3d1QixNQUFYLEdBQ2pDLFVBQVV2NUIsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCaUUsS0FBdEIsRUFBOEI7TUFDN0IsSUFBSXZGLEdBQUo7O01BQ0EsSUFBSyxDQUFDdUYsS0FBTixFQUFjO1FBQ2IsT0FBTyxDQUFFdkYsR0FBRyxHQUFHTSxJQUFJLENBQUMyTSxnQkFBTCxDQUF1QjNMLElBQXZCLENBQVIsS0FBMkN0QixHQUFHLENBQUMwRSxLQUFKLEtBQWMsRUFBekQsR0FDTjFFLEdBQUcsQ0FBQzBFLEtBREUsR0FFTixJQUZEO01BR0E7SUFDRCxDQVJGLENBekJ1QixDQW1DdkI7OztJQUNBaEcsTUFBTSxDQUFDazZCLFFBQVAsQ0FBZ0IxUixNQUFoQixHQUF5QjtNQUN4QnRuQixHQUFHLEVBQUUsYUFBVVUsSUFBVixFQUFnQmdCLElBQWhCLEVBQXVCO1FBQzNCLElBQUl0QixHQUFHLEdBQUdNLElBQUksQ0FBQzJNLGdCQUFMLENBQXVCM0wsSUFBdkIsQ0FBVjs7UUFDQSxJQUFLdEIsR0FBRyxJQUFJQSxHQUFHLENBQUN3TyxTQUFoQixFQUE0QjtVQUMzQixPQUFPeE8sR0FBRyxDQUFDMEUsS0FBWDtRQUNBO01BQ0QsQ0FOdUI7TUFPeEI0dEIsR0FBRyxFQUFFeUcsUUFBUSxDQUFDekc7SUFQVSxDQUF6QixDQXBDdUIsQ0E4Q3ZCO0lBQ0E7O0lBQ0E1ekIsTUFBTSxDQUFDMjZCLFNBQVAsQ0FBaUJTLGVBQWpCLEdBQW1DO01BQ2xDeEgsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFnQm9FLEtBQWhCLEVBQXVCcEQsSUFBdkIsRUFBOEI7UUFDbEN5M0IsUUFBUSxDQUFDekcsR0FBVCxDQUFjaHlCLElBQWQsRUFBb0JvRSxLQUFLLEtBQUssRUFBVixHQUFlLEtBQWYsR0FBdUJBLEtBQTNDLEVBQWtEcEQsSUFBbEQ7TUFDQTtJQUhpQyxDQUFuQyxDQWhEdUIsQ0FzRHZCO0lBQ0E7O0lBQ0E1QyxNQUFNLENBQUN5QixJQUFQLENBQWEsQ0FBRSxPQUFGLEVBQVcsUUFBWCxDQUFiLEVBQW9DLFVBQVVJLENBQVYsRUFBYWUsSUFBYixFQUFvQjtNQUN2RDVDLE1BQU0sQ0FBQzI2QixTQUFQLENBQWtCLzNCLElBQWxCLElBQTJCO1FBQzFCZ3hCLEdBQUcsRUFBRSxhQUFVaHlCLElBQVYsRUFBZ0JvRSxLQUFoQixFQUF3QjtVQUM1QixJQUFLQSxLQUFLLEtBQUssRUFBZixFQUFvQjtZQUNuQnBFLElBQUksQ0FBQzJKLFlBQUwsQ0FBbUIzSSxJQUFuQixFQUF5QixNQUF6QjtZQUNBLE9BQU9vRCxLQUFQO1VBQ0E7UUFDRDtNQU55QixDQUEzQjtJQVFBLENBVEQ7RUFVQTs7RUFFRCxJQUFLLENBQUNsRyxPQUFPLENBQUM4ZCxLQUFkLEVBQXNCO0lBQ3JCNWQsTUFBTSxDQUFDMjZCLFNBQVAsQ0FBaUIvYyxLQUFqQixHQUF5QjtNQUN4QjFjLEdBQUcsRUFBRSxhQUFVVSxJQUFWLEVBQWlCO1FBRXJCO1FBQ0E7UUFDQTtRQUNBLE9BQU9BLElBQUksQ0FBQ2djLEtBQUwsQ0FBV0MsT0FBWCxJQUFzQnphLFNBQTdCO01BQ0EsQ0FQdUI7TUFReEJ3d0IsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFnQm9FLEtBQWhCLEVBQXdCO1FBQzVCLE9BQVNwRSxJQUFJLENBQUNnYyxLQUFMLENBQVdDLE9BQVgsR0FBcUI3WCxLQUFLLEdBQUcsRUFBdEM7TUFDQTtJQVZ1QixDQUF6QjtFQVlBOztFQUtELElBQUlxMUIsVUFBVSxHQUFHLDRDQUFqQjtFQUFBLElBQ0NDLFVBQVUsR0FBRyxlQURkO0VBR0F0N0IsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLENBQWtCO0lBQ2pCZ2UsSUFBSSxFQUFFLGNBQVU1ZCxJQUFWLEVBQWdCb0QsS0FBaEIsRUFBd0I7TUFDN0IsT0FBT21iLE1BQU0sQ0FBRSxJQUFGLEVBQVFuaEIsTUFBTSxDQUFDd2dCLElBQWYsRUFBcUI1ZCxJQUFyQixFQUEyQm9ELEtBQTNCLEVBQWtDakUsU0FBUyxDQUFDaEIsTUFBVixHQUFtQixDQUFyRCxDQUFiO0lBQ0EsQ0FIZ0I7SUFLakJ3NkIsVUFBVSxFQUFFLG9CQUFVMzRCLElBQVYsRUFBaUI7TUFDNUJBLElBQUksR0FBRzVDLE1BQU0sQ0FBQys2QixPQUFQLENBQWdCbjRCLElBQWhCLEtBQTBCQSxJQUFqQztNQUNBLE9BQU8sS0FBS25CLElBQUwsQ0FBVyxZQUFXO1FBRTVCO1FBQ0EsSUFBSTtVQUNILEtBQU1tQixJQUFOLElBQWVRLFNBQWY7VUFDQSxPQUFPLEtBQU1SLElBQU4sQ0FBUDtRQUNBLENBSEQsQ0FHRSxPQUFRMkIsQ0FBUixFQUFZLENBQUU7TUFDaEIsQ0FQTSxDQUFQO0lBUUE7RUFmZ0IsQ0FBbEI7RUFrQkF2RSxNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFDZGdlLElBQUksRUFBRSxjQUFVNWUsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCb0QsS0FBdEIsRUFBOEI7TUFDbkMsSUFBSTFFLEdBQUo7TUFBQSxJQUFTZ2UsS0FBVDtNQUFBLElBQ0NvYixLQUFLLEdBQUc5NEIsSUFBSSxDQUFDMEMsUUFEZCxDQURtQyxDQUluQzs7TUFDQSxJQUFLbzJCLEtBQUssS0FBSyxDQUFWLElBQWVBLEtBQUssS0FBSyxDQUF6QixJQUE4QkEsS0FBSyxLQUFLLENBQTdDLEVBQWlEO1FBQ2hEO01BQ0E7O01BRUQsSUFBS0EsS0FBSyxLQUFLLENBQVYsSUFBZSxDQUFDMTZCLE1BQU0sQ0FBQzRXLFFBQVAsQ0FBaUJoVixJQUFqQixDQUFyQixFQUErQztRQUU5QztRQUNBZ0IsSUFBSSxHQUFHNUMsTUFBTSxDQUFDKzZCLE9BQVAsQ0FBZ0JuNEIsSUFBaEIsS0FBMEJBLElBQWpDO1FBQ0EwYyxLQUFLLEdBQUd0ZixNQUFNLENBQUMyMEIsU0FBUCxDQUFrQi94QixJQUFsQixDQUFSO01BQ0E7O01BRUQsSUFBS29ELEtBQUssS0FBSzVDLFNBQWYsRUFBMkI7UUFDMUIsSUFBS2tjLEtBQUssSUFBSSxTQUFTQSxLQUFsQixJQUNKLENBQUVoZSxHQUFHLEdBQUdnZSxLQUFLLENBQUNzVSxHQUFOLENBQVdoeUIsSUFBWCxFQUFpQm9FLEtBQWpCLEVBQXdCcEQsSUFBeEIsQ0FBUixNQUE2Q1EsU0FEOUMsRUFDMEQ7VUFDekQsT0FBTzlCLEdBQVA7UUFDQTs7UUFFRCxPQUFTTSxJQUFJLENBQUVnQixJQUFGLENBQUosR0FBZW9ELEtBQXhCO01BQ0E7O01BRUQsSUFBS3NaLEtBQUssSUFBSSxTQUFTQSxLQUFsQixJQUEyQixDQUFFaGUsR0FBRyxHQUFHZ2UsS0FBSyxDQUFDcGUsR0FBTixDQUFXVSxJQUFYLEVBQWlCZ0IsSUFBakIsQ0FBUixNQUFzQyxJQUF0RSxFQUE2RTtRQUM1RSxPQUFPdEIsR0FBUDtNQUNBOztNQUVELE9BQU9NLElBQUksQ0FBRWdCLElBQUYsQ0FBWDtJQUNBLENBL0JhO0lBaUNkK3hCLFNBQVMsRUFBRTtNQUNWL2hCLFFBQVEsRUFBRTtRQUNUMVIsR0FBRyxFQUFFLGFBQVVVLElBQVYsRUFBaUI7VUFFckI7VUFDQTtVQUNBO1VBQ0E7VUFDQSxJQUFJNDVCLFFBQVEsR0FBR3g3QixNQUFNLENBQUNvTyxJQUFQLENBQVl3QixJQUFaLENBQWtCaE8sSUFBbEIsRUFBd0IsVUFBeEIsQ0FBZjtVQUVBLE9BQU80NUIsUUFBUSxHQUNkQyxRQUFRLENBQUVELFFBQUYsRUFBWSxFQUFaLENBRE0sR0FFZEgsVUFBVSxDQUFDaHdCLElBQVgsQ0FBaUJ6SixJQUFJLENBQUNtRCxRQUF0QixLQUNDdTJCLFVBQVUsQ0FBQ2p3QixJQUFYLENBQWlCekosSUFBSSxDQUFDbUQsUUFBdEIsS0FBb0NuRCxJQUFJLENBQUMrUSxJQUQxQyxHQUVFLENBRkYsR0FHRSxDQUFDLENBTEo7UUFNQTtNQWZRO0lBREEsQ0FqQ0c7SUFxRGRvb0IsT0FBTyxFQUFFO01BQ1IsT0FBTyxTQURDO01BRVIsU0FBUztJQUZEO0VBckRLLENBQWYsRUFyOFE4RSxDQWdnUjlFO0VBQ0E7O0VBQ0EsSUFBSyxDQUFDajdCLE9BQU8sQ0FBQzQ1QixjQUFkLEVBQStCO0lBRTlCO0lBQ0ExNUIsTUFBTSxDQUFDeUIsSUFBUCxDQUFhLENBQUUsTUFBRixFQUFVLEtBQVYsQ0FBYixFQUFnQyxVQUFVSSxDQUFWLEVBQWFlLElBQWIsRUFBb0I7TUFDbkQ1QyxNQUFNLENBQUMyMEIsU0FBUCxDQUFrQi94QixJQUFsQixJQUEyQjtRQUMxQjFCLEdBQUcsRUFBRSxhQUFVVSxJQUFWLEVBQWlCO1VBQ3JCLE9BQU9BLElBQUksQ0FBQzBKLFlBQUwsQ0FBbUIxSSxJQUFuQixFQUF5QixDQUF6QixDQUFQO1FBQ0E7TUFIeUIsQ0FBM0I7SUFLQSxDQU5EO0VBT0EsQ0E1Z1I2RSxDQThnUjlFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7O0VBQ0EsSUFBSyxDQUFDOUMsT0FBTyxDQUFDODVCLFdBQWQsRUFBNEI7SUFDM0I1NUIsTUFBTSxDQUFDMjBCLFNBQVAsQ0FBaUI1aEIsUUFBakIsR0FBNEI7TUFDM0I3UixHQUFHLEVBQUUsYUFBVVUsSUFBVixFQUFpQjtRQUNyQixJQUFJNkwsTUFBTSxHQUFHN0wsSUFBSSxDQUFDK0osVUFBbEI7O1FBRUEsSUFBSzhCLE1BQUwsRUFBYztVQUNiQSxNQUFNLENBQUN1RixhQUFQLENBRGEsQ0FHYjs7VUFDQSxJQUFLdkYsTUFBTSxDQUFDOUIsVUFBWixFQUF5QjtZQUN4QjhCLE1BQU0sQ0FBQzlCLFVBQVAsQ0FBa0JxSCxhQUFsQjtVQUNBO1FBQ0Q7O1FBQ0QsT0FBTyxJQUFQO01BQ0EsQ0FiMEI7TUFjM0I0Z0IsR0FBRyxFQUFFLGFBQVVoeUIsSUFBVixFQUFpQjtRQUNyQixJQUFJNkwsTUFBTSxHQUFHN0wsSUFBSSxDQUFDK0osVUFBbEI7O1FBQ0EsSUFBSzhCLE1BQUwsRUFBYztVQUNiQSxNQUFNLENBQUN1RixhQUFQOztVQUVBLElBQUt2RixNQUFNLENBQUM5QixVQUFaLEVBQXlCO1lBQ3hCOEIsTUFBTSxDQUFDOUIsVUFBUCxDQUFrQnFILGFBQWxCO1VBQ0E7UUFDRDtNQUNEO0lBdkIwQixDQUE1QjtFQXlCQTs7RUFFRGhULE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYSxDQUNaLFVBRFksRUFFWixVQUZZLEVBR1osV0FIWSxFQUlaLGFBSlksRUFLWixhQUxZLEVBTVosU0FOWSxFQU9aLFNBUFksRUFRWixRQVJZLEVBU1osYUFUWSxFQVVaLGlCQVZZLENBQWIsRUFXRyxZQUFXO0lBQ2J6QixNQUFNLENBQUMrNkIsT0FBUCxDQUFnQixLQUFLLzFCLFdBQUwsRUFBaEIsSUFBdUMsSUFBdkM7RUFDQSxDQWJELEVBaGpSOEUsQ0EralI5RTs7RUFDQSxJQUFLLENBQUNsRixPQUFPLENBQUMrNUIsT0FBZCxFQUF3QjtJQUN2Qjc1QixNQUFNLENBQUMrNkIsT0FBUCxDQUFlbEIsT0FBZixHQUF5QixVQUF6QjtFQUNBOztFQUtELElBQUk2QixNQUFNLEdBQUcsYUFBYjs7RUFFQSxTQUFTQyxRQUFULENBQW1CLzVCLElBQW5CLEVBQTBCO0lBQ3pCLE9BQU81QixNQUFNLENBQUM0UCxJQUFQLENBQWFoTyxJQUFiLEVBQW1CLE9BQW5CLEtBQWdDLEVBQXZDO0VBQ0E7O0VBRUQ1QixNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFDakJvNUIsUUFBUSxFQUFFLGtCQUFVNTFCLEtBQVYsRUFBa0I7TUFDM0IsSUFBSTYxQixPQUFKO01BQUEsSUFBYWo2QixJQUFiO01BQUEsSUFBbUJpTCxHQUFuQjtNQUFBLElBQXdCaXZCLFFBQXhCO01BQUEsSUFBa0NDLEtBQWxDO01BQUEsSUFBeUMzNUIsQ0FBekM7TUFBQSxJQUE0QzQ1QixVQUE1QztNQUFBLElBQ0NuNkIsQ0FBQyxHQUFHLENBREw7O01BR0EsSUFBSzdCLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUIrQyxLQUFuQixDQUFMLEVBQWtDO1FBQ2pDLE9BQU8sS0FBS3ZFLElBQUwsQ0FBVyxVQUFVVyxDQUFWLEVBQWM7VUFDL0JwQyxNQUFNLENBQUUsSUFBRixDQUFOLENBQWU0N0IsUUFBZixDQUF5QjUxQixLQUFLLENBQUMvRSxJQUFOLENBQVksSUFBWixFQUFrQm1CLENBQWxCLEVBQXFCdTVCLFFBQVEsQ0FBRSxJQUFGLENBQTdCLENBQXpCO1FBQ0EsQ0FGTSxDQUFQO01BR0E7O01BRUQsSUFBSyxPQUFPMzFCLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBQWxDLEVBQTBDO1FBQ3pDNjFCLE9BQU8sR0FBRzcxQixLQUFLLENBQUMwRSxLQUFOLENBQWE2TyxTQUFiLEtBQTRCLEVBQXRDOztRQUVBLE9BQVUzWCxJQUFJLEdBQUcsS0FBTUMsQ0FBQyxFQUFQLENBQWpCLEVBQWlDO1VBQ2hDaTZCLFFBQVEsR0FBR0gsUUFBUSxDQUFFLzVCLElBQUYsQ0FBbkI7VUFDQWlMLEdBQUcsR0FBR2pMLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBbEIsSUFDTCxDQUFFLE1BQU13M0IsUUFBTixHQUFpQixHQUFuQixFQUF5QnQ0QixPQUF6QixDQUFrQ2s0QixNQUFsQyxFQUEwQyxHQUExQyxDQUREOztVQUdBLElBQUs3dUIsR0FBTCxFQUFXO1lBQ1Z6SyxDQUFDLEdBQUcsQ0FBSjs7WUFDQSxPQUFVMjVCLEtBQUssR0FBR0YsT0FBTyxDQUFFejVCLENBQUMsRUFBSCxDQUF6QixFQUFxQztjQUNwQyxJQUFLeUssR0FBRyxDQUFDcE4sT0FBSixDQUFhLE1BQU1zOEIsS0FBTixHQUFjLEdBQTNCLElBQW1DLENBQXhDLEVBQTRDO2dCQUMzQ2x2QixHQUFHLElBQUlrdkIsS0FBSyxHQUFHLEdBQWY7Y0FDQTtZQUNELENBTlMsQ0FRVjs7O1lBQ0FDLFVBQVUsR0FBR2g4QixNQUFNLENBQUMyRSxJQUFQLENBQWFrSSxHQUFiLENBQWI7O1lBQ0EsSUFBS2l2QixRQUFRLEtBQUtFLFVBQWxCLEVBQStCO2NBQzlCaDhCLE1BQU0sQ0FBQzRQLElBQVAsQ0FBYWhPLElBQWIsRUFBbUIsT0FBbkIsRUFBNEJvNkIsVUFBNUI7WUFDQTtVQUNEO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPLElBQVA7SUFDQSxDQXJDZ0I7SUF1Q2pCQyxXQUFXLEVBQUUscUJBQVVqMkIsS0FBVixFQUFrQjtNQUM5QixJQUFJNjFCLE9BQUo7TUFBQSxJQUFhajZCLElBQWI7TUFBQSxJQUFtQmlMLEdBQW5CO01BQUEsSUFBd0JpdkIsUUFBeEI7TUFBQSxJQUFrQ0MsS0FBbEM7TUFBQSxJQUF5QzM1QixDQUF6QztNQUFBLElBQTRDNDVCLFVBQTVDO01BQUEsSUFDQ242QixDQUFDLEdBQUcsQ0FETDs7TUFHQSxJQUFLN0IsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQitDLEtBQW5CLENBQUwsRUFBa0M7UUFDakMsT0FBTyxLQUFLdkUsSUFBTCxDQUFXLFVBQVVXLENBQVYsRUFBYztVQUMvQnBDLE1BQU0sQ0FBRSxJQUFGLENBQU4sQ0FBZWk4QixXQUFmLENBQTRCajJCLEtBQUssQ0FBQy9FLElBQU4sQ0FBWSxJQUFaLEVBQWtCbUIsQ0FBbEIsRUFBcUJ1NUIsUUFBUSxDQUFFLElBQUYsQ0FBN0IsQ0FBNUI7UUFDQSxDQUZNLENBQVA7TUFHQTs7TUFFRCxJQUFLLENBQUM1NUIsU0FBUyxDQUFDaEIsTUFBaEIsRUFBeUI7UUFDeEIsT0FBTyxLQUFLNk8sSUFBTCxDQUFXLE9BQVgsRUFBb0IsRUFBcEIsQ0FBUDtNQUNBOztNQUVELElBQUssT0FBTzVKLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBQWxDLEVBQTBDO1FBQ3pDNjFCLE9BQU8sR0FBRzcxQixLQUFLLENBQUMwRSxLQUFOLENBQWE2TyxTQUFiLEtBQTRCLEVBQXRDOztRQUVBLE9BQVUzWCxJQUFJLEdBQUcsS0FBTUMsQ0FBQyxFQUFQLENBQWpCLEVBQWlDO1VBQ2hDaTZCLFFBQVEsR0FBR0gsUUFBUSxDQUFFLzVCLElBQUYsQ0FBbkIsQ0FEZ0MsQ0FHaEM7O1VBQ0FpTCxHQUFHLEdBQUdqTCxJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQWxCLElBQ0wsQ0FBRSxNQUFNdzNCLFFBQU4sR0FBaUIsR0FBbkIsRUFBeUJ0NEIsT0FBekIsQ0FBa0NrNEIsTUFBbEMsRUFBMEMsR0FBMUMsQ0FERDs7VUFHQSxJQUFLN3VCLEdBQUwsRUFBVztZQUNWekssQ0FBQyxHQUFHLENBQUo7O1lBQ0EsT0FBVTI1QixLQUFLLEdBQUdGLE9BQU8sQ0FBRXo1QixDQUFDLEVBQUgsQ0FBekIsRUFBcUM7Y0FFcEM7Y0FDQSxPQUFReUssR0FBRyxDQUFDcE4sT0FBSixDQUFhLE1BQU1zOEIsS0FBTixHQUFjLEdBQTNCLElBQW1DLENBQUMsQ0FBNUMsRUFBZ0Q7Z0JBQy9DbHZCLEdBQUcsR0FBR0EsR0FBRyxDQUFDckosT0FBSixDQUFhLE1BQU11NEIsS0FBTixHQUFjLEdBQTNCLEVBQWdDLEdBQWhDLENBQU47Y0FDQTtZQUNELENBUlMsQ0FVVjs7O1lBQ0FDLFVBQVUsR0FBR2g4QixNQUFNLENBQUMyRSxJQUFQLENBQWFrSSxHQUFiLENBQWI7O1lBQ0EsSUFBS2l2QixRQUFRLEtBQUtFLFVBQWxCLEVBQStCO2NBQzlCaDhCLE1BQU0sQ0FBQzRQLElBQVAsQ0FBYWhPLElBQWIsRUFBbUIsT0FBbkIsRUFBNEJvNkIsVUFBNUI7WUFDQTtVQUNEO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPLElBQVA7SUFDQSxDQW5GZ0I7SUFxRmpCRSxXQUFXLEVBQUUscUJBQVVsMkIsS0FBVixFQUFpQm0yQixRQUFqQixFQUE0QjtNQUN4QyxJQUFJcjRCLElBQUksV0FBVWtDLEtBQVYsQ0FBUjs7TUFFQSxJQUFLLE9BQU9tMkIsUUFBUCxLQUFvQixTQUFwQixJQUFpQ3I0QixJQUFJLEtBQUssUUFBL0MsRUFBMEQ7UUFDekQsT0FBT3E0QixRQUFRLEdBQUcsS0FBS1AsUUFBTCxDQUFlNTFCLEtBQWYsQ0FBSCxHQUE0QixLQUFLaTJCLFdBQUwsQ0FBa0JqMkIsS0FBbEIsQ0FBM0M7TUFDQTs7TUFFRCxJQUFLaEcsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQitDLEtBQW5CLENBQUwsRUFBa0M7UUFDakMsT0FBTyxLQUFLdkUsSUFBTCxDQUFXLFVBQVVJLENBQVYsRUFBYztVQUMvQjdCLE1BQU0sQ0FBRSxJQUFGLENBQU4sQ0FBZWs4QixXQUFmLENBQ0NsMkIsS0FBSyxDQUFDL0UsSUFBTixDQUFZLElBQVosRUFBa0JZLENBQWxCLEVBQXFCODVCLFFBQVEsQ0FBRSxJQUFGLENBQTdCLEVBQXVDUSxRQUF2QyxDQURELEVBRUNBLFFBRkQ7UUFJQSxDQUxNLENBQVA7TUFNQTs7TUFFRCxPQUFPLEtBQUsxNkIsSUFBTCxDQUFXLFlBQVc7UUFDNUIsSUFBSXNNLFNBQUosRUFBZWxNLENBQWYsRUFBa0I0VixJQUFsQixFQUF3QjJrQixVQUF4Qjs7UUFFQSxJQUFLdDRCLElBQUksS0FBSyxRQUFkLEVBQXlCO1VBRXhCO1VBQ0FqQyxDQUFDLEdBQUcsQ0FBSjtVQUNBNFYsSUFBSSxHQUFHelgsTUFBTSxDQUFFLElBQUYsQ0FBYjtVQUNBbzhCLFVBQVUsR0FBR3AyQixLQUFLLENBQUMwRSxLQUFOLENBQWE2TyxTQUFiLEtBQTRCLEVBQXpDOztVQUVBLE9BQVV4TCxTQUFTLEdBQUdxdUIsVUFBVSxDQUFFdjZCLENBQUMsRUFBSCxDQUFoQyxFQUE0QztZQUUzQztZQUNBLElBQUs0VixJQUFJLENBQUM0a0IsUUFBTCxDQUFldHVCLFNBQWYsQ0FBTCxFQUFrQztjQUNqQzBKLElBQUksQ0FBQ3drQixXQUFMLENBQWtCbHVCLFNBQWxCO1lBQ0EsQ0FGRCxNQUVPO2NBQ04wSixJQUFJLENBQUNta0IsUUFBTCxDQUFlN3RCLFNBQWY7WUFDQTtVQUNELENBZnVCLENBaUJ6Qjs7UUFDQyxDQWxCRCxNQWtCTyxJQUFLL0gsS0FBSyxLQUFLNUMsU0FBVixJQUF1QlUsSUFBSSxLQUFLLFNBQXJDLEVBQWlEO1VBQ3ZEaUssU0FBUyxHQUFHNHRCLFFBQVEsQ0FBRSxJQUFGLENBQXBCOztVQUNBLElBQUs1dEIsU0FBTCxFQUFpQjtZQUVoQjtZQUNBL04sTUFBTSxDQUFDa2YsS0FBUCxDQUFjLElBQWQsRUFBb0IsZUFBcEIsRUFBcUNuUixTQUFyQztVQUNBLENBTnNELENBUXZEO1VBQ0E7VUFDQTtVQUNBOzs7VUFDQS9OLE1BQU0sQ0FBQzRQLElBQVAsQ0FBYSxJQUFiLEVBQW1CLE9BQW5CLEVBQ0M3QixTQUFTLElBQUkvSCxLQUFLLEtBQUssS0FBdkIsR0FDQSxFQURBLEdBRUFoRyxNQUFNLENBQUNrZixLQUFQLENBQWMsSUFBZCxFQUFvQixlQUFwQixLQUF5QyxFQUgxQztRQUtBO01BQ0QsQ0F2Q00sQ0FBUDtJQXdDQSxDQTdJZ0I7SUErSWpCbWQsUUFBUSxFQUFFLGtCQUFVcDhCLFFBQVYsRUFBcUI7TUFDOUIsSUFBSThOLFNBQUo7TUFBQSxJQUFlbk0sSUFBZjtNQUFBLElBQ0NDLENBQUMsR0FBRyxDQURMO01BR0FrTSxTQUFTLEdBQUcsTUFBTTlOLFFBQU4sR0FBaUIsR0FBN0I7O01BQ0EsT0FBVTJCLElBQUksR0FBRyxLQUFNQyxDQUFDLEVBQVAsQ0FBakIsRUFBaUM7UUFDaEMsSUFBS0QsSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUFsQixJQUNKLENBQUUsTUFBTXEzQixRQUFRLENBQUUvNUIsSUFBRixDQUFkLEdBQXlCLEdBQTNCLEVBQWlDNEIsT0FBakMsQ0FBMENrNEIsTUFBMUMsRUFBa0QsR0FBbEQsRUFDRWo4QixPQURGLENBQ1dzTyxTQURYLElBQ3lCLENBQUMsQ0FGM0IsRUFHRTtVQUNELE9BQU8sSUFBUDtRQUNBO01BQ0Q7O01BRUQsT0FBTyxLQUFQO0lBQ0E7RUE5SmdCLENBQWxCLEVBN2tSOEUsQ0FpdlI5RTs7RUFHQS9OLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYSxDQUFFLDBFQUNkLHVFQURjLEdBRWQsK0RBRlksRUFFc0RnRixLQUZ0RCxDQUU2RCxHQUY3RCxDQUFiLEVBR0MsVUFBVTVFLENBQVYsRUFBYWUsSUFBYixFQUFvQjtJQUVwQjtJQUNBNUMsTUFBTSxDQUFDRyxFQUFQLENBQVd5QyxJQUFYLElBQW9CLFVBQVU4QixJQUFWLEVBQWdCdkUsRUFBaEIsRUFBcUI7TUFDeEMsT0FBTzRCLFNBQVMsQ0FBQ2hCLE1BQVYsR0FBbUIsQ0FBbkIsR0FDTixLQUFLd2tCLEVBQUwsQ0FBUzNpQixJQUFULEVBQWUsSUFBZixFQUFxQjhCLElBQXJCLEVBQTJCdkUsRUFBM0IsQ0FETSxHQUVOLEtBQUs4bUIsT0FBTCxDQUFjcmtCLElBQWQsQ0FGRDtJQUdBLENBSkQ7RUFLQSxDQVhEO0VBYUE1QyxNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFDakI4NUIsS0FBSyxFQUFFLGVBQVVDLE1BQVYsRUFBa0JDLEtBQWxCLEVBQTBCO01BQ2hDLE9BQU8sS0FBSzNSLFVBQUwsQ0FBaUIwUixNQUFqQixFQUEwQnpSLFVBQTFCLENBQXNDMFIsS0FBSyxJQUFJRCxNQUEvQyxDQUFQO0lBQ0E7RUFIZ0IsQ0FBbEI7RUFPQSxJQUFJL3BCLFFBQVEsR0FBR3JULE1BQU0sQ0FBQ3FULFFBQXRCO0VBRUEsSUFBSWlxQixLQUFLLEdBQUd6OEIsTUFBTSxDQUFDcUcsR0FBUCxFQUFaO0VBRUEsSUFBSXEyQixNQUFNLEdBQUssSUFBZjtFQUlBLElBQUlDLFlBQVksR0FBRyxrSUFBbkI7O0VBRUEzOEIsTUFBTSxDQUFDc2UsU0FBUCxHQUFtQixVQUFVNVosSUFBVixFQUFpQjtJQUVuQztJQUNBLElBQUt2RixNQUFNLENBQUN5OUIsSUFBUCxJQUFlejlCLE1BQU0sQ0FBQ3k5QixJQUFQLENBQVlDLEtBQWhDLEVBQXdDO01BRXZDO01BQ0E7TUFDQSxPQUFPMTlCLE1BQU0sQ0FBQ3k5QixJQUFQLENBQVlDLEtBQVosQ0FBbUJuNEIsSUFBSSxHQUFHLEVBQTFCLENBQVA7SUFDQTs7SUFFRCxJQUFJbzRCLGVBQUo7SUFBQSxJQUNDQyxLQUFLLEdBQUcsSUFEVDtJQUFBLElBRUNDLEdBQUcsR0FBR2g5QixNQUFNLENBQUMyRSxJQUFQLENBQWFELElBQUksR0FBRyxFQUFwQixDQUZQLENBVm1DLENBY25DO0lBQ0E7O0lBQ0EsT0FBT3M0QixHQUFHLElBQUksQ0FBQ2g5QixNQUFNLENBQUMyRSxJQUFQLENBQWFxNEIsR0FBRyxDQUFDeDVCLE9BQUosQ0FBYW01QixZQUFiLEVBQTJCLFVBQVVwbUIsS0FBVixFQUFpQjBtQixLQUFqQixFQUF3QkMsSUFBeEIsRUFBOEJ0TyxLQUE5QixFQUFzQztNQUU1RjtNQUNBLElBQUtrTyxlQUFlLElBQUlHLEtBQXhCLEVBQWdDO1FBQy9CRixLQUFLLEdBQUcsQ0FBUjtNQUNBLENBTDJGLENBTzVGOzs7TUFDQSxJQUFLQSxLQUFLLEtBQUssQ0FBZixFQUFtQjtRQUNsQixPQUFPeG1CLEtBQVA7TUFDQSxDQVYyRixDQVk1Rjs7O01BQ0F1bUIsZUFBZSxHQUFHSSxJQUFJLElBQUlELEtBQTFCLENBYjRGLENBZTVGO01BQ0E7TUFDQTtNQUNBOztNQUNBRixLQUFLLElBQUksQ0FBQ25PLEtBQUQsR0FBUyxDQUFDc08sSUFBbkIsQ0FuQjRGLENBcUI1Rjs7TUFDQSxPQUFPLEVBQVA7SUFDQSxDQXZCMkIsQ0FBYixDQUFSLEdBd0JKQyxRQUFRLENBQUUsWUFBWUgsR0FBZCxDQUFWLEVBeEJNLEdBeUJOaDlCLE1BQU0sQ0FBQzBELEtBQVAsQ0FBYyxtQkFBbUJnQixJQUFqQyxDQXpCRDtFQTBCQSxDQTFDRCxDQWx4UjhFLENBK3pSOUU7OztFQUNBMUUsTUFBTSxDQUFDbzlCLFFBQVAsR0FBa0IsVUFBVTE0QixJQUFWLEVBQWlCO0lBQ2xDLElBQUk0TSxHQUFKLEVBQVNsTCxHQUFUOztJQUNBLElBQUssQ0FBQzFCLElBQUQsSUFBUyxPQUFPQSxJQUFQLEtBQWdCLFFBQTlCLEVBQXlDO01BQ3hDLE9BQU8sSUFBUDtJQUNBOztJQUNELElBQUk7TUFDSCxJQUFLdkYsTUFBTSxDQUFDaytCLFNBQVosRUFBd0I7UUFBRTtRQUN6QmozQixHQUFHLEdBQUcsSUFBSWpILE1BQU0sQ0FBQ2srQixTQUFYLEVBQU47UUFDQS9yQixHQUFHLEdBQUdsTCxHQUFHLENBQUNrM0IsZUFBSixDQUFxQjU0QixJQUFyQixFQUEyQixVQUEzQixDQUFOO01BQ0EsQ0FIRCxNQUdPO1FBQUU7UUFDUjRNLEdBQUcsR0FBRyxJQUFJblMsTUFBTSxDQUFDbytCLGFBQVgsQ0FBMEIsa0JBQTFCLENBQU47UUFDQWpzQixHQUFHLENBQUNrc0IsS0FBSixHQUFZLE9BQVo7UUFDQWxzQixHQUFHLENBQUNtc0IsT0FBSixDQUFhLzRCLElBQWI7TUFDQTtJQUNELENBVEQsQ0FTRSxPQUFRSCxDQUFSLEVBQVk7TUFDYitNLEdBQUcsR0FBR2xPLFNBQU47SUFDQTs7SUFDRCxJQUFLLENBQUNrTyxHQUFELElBQVEsQ0FBQ0EsR0FBRyxDQUFDaEUsZUFBYixJQUFnQ2dFLEdBQUcsQ0FBQ3BHLG9CQUFKLENBQTBCLGFBQTFCLEVBQTBDbkssTUFBL0UsRUFBd0Y7TUFDdkZmLE1BQU0sQ0FBQzBELEtBQVAsQ0FBYyxrQkFBa0JnQixJQUFoQztJQUNBOztJQUNELE9BQU80TSxHQUFQO0VBQ0EsQ0FyQkQ7O0VBd0JBLElBQ0Nvc0IsS0FBSyxHQUFHLE1BRFQ7RUFBQSxJQUVDQyxHQUFHLEdBQUcsZUFGUDtFQUFBLElBSUM7RUFDQUMsUUFBUSxHQUFHLCtCQUxaO0VBQUEsSUFPQztFQUNBQyxjQUFjLEdBQUcsMkRBUmxCO0VBQUEsSUFTQ0MsVUFBVSxHQUFHLGdCQVRkO0VBQUEsSUFVQ0MsU0FBUyxHQUFHLE9BVmI7RUFBQSxJQVdDQyxJQUFJLEdBQUcsMkRBWFI7O0VBYUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0MvRyxVQUFVLEdBQUcsRUF0QmQ7O0VBd0JDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7RUFDQ2dILFVBQVUsR0FBRyxFQTdCZDtFQUFBLElBK0JDO0VBQ0FDLFFBQVEsR0FBRyxLQUFLMytCLE1BQUwsQ0FBYSxHQUFiLENBaENaO0VBQUEsSUFrQ0M7RUFDQTQrQixZQUFZLEdBQUczckIsUUFBUSxDQUFDRyxJQW5DekI7RUFBQSxJQXFDQztFQUNBeXJCLFlBQVksR0FBR0osSUFBSSxDQUFDanpCLElBQUwsQ0FBV296QixZQUFZLENBQUNuNUIsV0FBYixFQUFYLEtBQTJDLEVBdEMzRCxDQXgxUjhFLENBZzRSOUU7O0VBQ0EsU0FBU3E1QiwyQkFBVCxDQUFzQ0MsU0FBdEMsRUFBa0Q7SUFFakQ7SUFDQSxPQUFPLFVBQVVDLGtCQUFWLEVBQThCNWpCLElBQTlCLEVBQXFDO01BRTNDLElBQUssT0FBTzRqQixrQkFBUCxLQUE4QixRQUFuQyxFQUE4QztRQUM3QzVqQixJQUFJLEdBQUc0akIsa0JBQVA7UUFDQUEsa0JBQWtCLEdBQUcsR0FBckI7TUFDQTs7TUFFRCxJQUFJQyxRQUFKO01BQUEsSUFDQzM4QixDQUFDLEdBQUcsQ0FETDtNQUFBLElBRUM0OEIsU0FBUyxHQUFHRixrQkFBa0IsQ0FBQ3Y1QixXQUFuQixHQUFpQzBGLEtBQWpDLENBQXdDNk8sU0FBeEMsS0FBdUQsRUFGcEU7O01BSUEsSUFBS3ZaLE1BQU0sQ0FBQ2lELFVBQVAsQ0FBbUIwWCxJQUFuQixDQUFMLEVBQWlDO1FBRWhDO1FBQ0EsT0FBVTZqQixRQUFRLEdBQUdDLFNBQVMsQ0FBRTU4QixDQUFDLEVBQUgsQ0FBOUIsRUFBMEM7VUFFekM7VUFDQSxJQUFLMjhCLFFBQVEsQ0FBQzVtQixNQUFULENBQWlCLENBQWpCLE1BQXlCLEdBQTlCLEVBQW9DO1lBQ25DNG1CLFFBQVEsR0FBR0EsUUFBUSxDQUFDbC9CLEtBQVQsQ0FBZ0IsQ0FBaEIsS0FBdUIsR0FBbEM7WUFDQSxDQUFFZy9CLFNBQVMsQ0FBRUUsUUFBRixDQUFULEdBQXdCRixTQUFTLENBQUVFLFFBQUYsQ0FBVCxJQUF5QixFQUFuRCxFQUF3RC91QixPQUF4RCxDQUFpRWtMLElBQWpFLEVBRm1DLENBSXBDO1VBQ0MsQ0FMRCxNQUtPO1lBQ04sQ0FBRTJqQixTQUFTLENBQUVFLFFBQUYsQ0FBVCxHQUF3QkYsU0FBUyxDQUFFRSxRQUFGLENBQVQsSUFBeUIsRUFBbkQsRUFBd0RoL0IsSUFBeEQsQ0FBOERtYixJQUE5RDtVQUNBO1FBQ0Q7TUFDRDtJQUNELENBM0JEO0VBNEJBLENBaDZSNkUsQ0FrNlI5RTs7O0VBQ0EsU0FBUytqQiw2QkFBVCxDQUF3Q0osU0FBeEMsRUFBbUR6N0IsT0FBbkQsRUFBNEQwMEIsZUFBNUQsRUFBNkVvSCxLQUE3RSxFQUFxRjtJQUVwRixJQUFJQyxTQUFTLEdBQUcsRUFBaEI7SUFBQSxJQUNDQyxnQkFBZ0IsR0FBS1AsU0FBUyxLQUFLTCxVQURwQzs7SUFHQSxTQUFTYSxPQUFULENBQWtCTixRQUFsQixFQUE2QjtNQUM1QixJQUFJenJCLFFBQUo7TUFDQTZyQixTQUFTLENBQUVKLFFBQUYsQ0FBVCxHQUF3QixJQUF4QjtNQUNBeCtCLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYTY4QixTQUFTLENBQUVFLFFBQUYsQ0FBVCxJQUF5QixFQUF0QyxFQUEwQyxVQUFVMzBCLENBQVYsRUFBYWsxQixrQkFBYixFQUFrQztRQUMzRSxJQUFJQyxtQkFBbUIsR0FBR0Qsa0JBQWtCLENBQUVsOEIsT0FBRixFQUFXMDBCLGVBQVgsRUFBNEJvSCxLQUE1QixDQUE1Qzs7UUFDQSxJQUFLLE9BQU9LLG1CQUFQLEtBQStCLFFBQS9CLElBQ0osQ0FBQ0gsZ0JBREcsSUFDaUIsQ0FBQ0QsU0FBUyxDQUFFSSxtQkFBRixDQURoQyxFQUMwRDtVQUV6RG44QixPQUFPLENBQUM0N0IsU0FBUixDQUFrQmh2QixPQUFsQixDQUEyQnV2QixtQkFBM0I7VUFDQUYsT0FBTyxDQUFFRSxtQkFBRixDQUFQO1VBQ0EsT0FBTyxLQUFQO1FBQ0EsQ0FORCxNQU1PLElBQUtILGdCQUFMLEVBQXdCO1VBQzlCLE9BQU8sRUFBRzlyQixRQUFRLEdBQUdpc0IsbUJBQWQsQ0FBUDtRQUNBO01BQ0QsQ0FYRDtNQVlBLE9BQU9qc0IsUUFBUDtJQUNBOztJQUVELE9BQU8rckIsT0FBTyxDQUFFajhCLE9BQU8sQ0FBQzQ3QixTQUFSLENBQW1CLENBQW5CLENBQUYsQ0FBUCxJQUFxQyxDQUFDRyxTQUFTLENBQUUsR0FBRixDQUFWLElBQXFCRSxPQUFPLENBQUUsR0FBRixDQUF4RTtFQUNBLENBMzdSNkUsQ0E2N1I5RTtFQUNBO0VBQ0E7OztFQUNBLFNBQVNHLFVBQVQsQ0FBcUJsOEIsTUFBckIsRUFBNkJOLEdBQTdCLEVBQW1DO0lBQ2xDLElBQUlPLElBQUo7SUFBQSxJQUFVcUIsR0FBVjtJQUFBLElBQ0M2NkIsV0FBVyxHQUFHbC9CLE1BQU0sQ0FBQ20vQixZQUFQLENBQW9CRCxXQUFwQixJQUFtQyxFQURsRDs7SUFHQSxLQUFNNzZCLEdBQU4sSUFBYTVCLEdBQWIsRUFBbUI7TUFDbEIsSUFBS0EsR0FBRyxDQUFFNEIsR0FBRixDQUFILEtBQWVqQixTQUFwQixFQUFnQztRQUMvQixDQUFFODdCLFdBQVcsQ0FBRTc2QixHQUFGLENBQVgsR0FBcUJ0QixNQUFyQixHQUFnQ0MsSUFBSSxLQUFNQSxJQUFJLEdBQUcsRUFBYixDQUF0QyxFQUE2RHFCLEdBQTdELElBQXFFNUIsR0FBRyxDQUFFNEIsR0FBRixDQUF4RTtNQUNBO0lBQ0Q7O0lBQ0QsSUFBS3JCLElBQUwsRUFBWTtNQUNYaEQsTUFBTSxDQUFDd0MsTUFBUCxDQUFlLElBQWYsRUFBcUJPLE1BQXJCLEVBQTZCQyxJQUE3QjtJQUNBOztJQUVELE9BQU9ELE1BQVA7RUFDQTtFQUVEO0FBQ0E7QUFDQTtBQUNBOzs7RUFDQSxTQUFTcThCLG1CQUFULENBQThCQyxDQUE5QixFQUFpQ1YsS0FBakMsRUFBd0NXLFNBQXhDLEVBQW9EO0lBQ25ELElBQUlDLGFBQUo7SUFBQSxJQUFtQkMsRUFBbkI7SUFBQSxJQUF1QkMsYUFBdkI7SUFBQSxJQUFzQzM3QixJQUF0QztJQUFBLElBQ0NvVSxRQUFRLEdBQUdtbkIsQ0FBQyxDQUFDbm5CLFFBRGQ7SUFBQSxJQUVDdW1CLFNBQVMsR0FBR1ksQ0FBQyxDQUFDWixTQUZmLENBRG1ELENBS25EOztJQUNBLE9BQVFBLFNBQVMsQ0FBRSxDQUFGLENBQVQsS0FBbUIsR0FBM0IsRUFBaUM7TUFDaENBLFNBQVMsQ0FBQ3Z5QixLQUFWOztNQUNBLElBQUtzekIsRUFBRSxLQUFLcDhCLFNBQVosRUFBd0I7UUFDdkJvOEIsRUFBRSxHQUFHSCxDQUFDLENBQUNLLFFBQUYsSUFBY2YsS0FBSyxDQUFDZ0IsaUJBQU4sQ0FBeUIsY0FBekIsQ0FBbkI7TUFDQTtJQUNELENBWGtELENBYW5EOzs7SUFDQSxJQUFLSCxFQUFMLEVBQVU7TUFDVCxLQUFNMTdCLElBQU4sSUFBY29VLFFBQWQsRUFBeUI7UUFDeEIsSUFBS0EsUUFBUSxDQUFFcFUsSUFBRixDQUFSLElBQW9Cb1UsUUFBUSxDQUFFcFUsSUFBRixDQUFSLENBQWlCdUgsSUFBakIsQ0FBdUJtMEIsRUFBdkIsQ0FBekIsRUFBdUQ7VUFDdERmLFNBQVMsQ0FBQ2h2QixPQUFWLENBQW1CM0wsSUFBbkI7VUFDQTtRQUNBO01BQ0Q7SUFDRCxDQXJCa0QsQ0F1Qm5EOzs7SUFDQSxJQUFLMjZCLFNBQVMsQ0FBRSxDQUFGLENBQVQsSUFBa0JhLFNBQXZCLEVBQW1DO01BQ2xDRyxhQUFhLEdBQUdoQixTQUFTLENBQUUsQ0FBRixDQUF6QjtJQUNBLENBRkQsTUFFTztNQUVOO01BQ0EsS0FBTTM2QixJQUFOLElBQWN3N0IsU0FBZCxFQUEwQjtRQUN6QixJQUFLLENBQUNiLFNBQVMsQ0FBRSxDQUFGLENBQVYsSUFBbUJZLENBQUMsQ0FBQ08sVUFBRixDQUFjOTdCLElBQUksR0FBRyxHQUFQLEdBQWEyNkIsU0FBUyxDQUFFLENBQUYsQ0FBcEMsQ0FBeEIsRUFBc0U7VUFDckVnQixhQUFhLEdBQUczN0IsSUFBaEI7VUFDQTtRQUNBOztRQUNELElBQUssQ0FBQ3k3QixhQUFOLEVBQXNCO1VBQ3JCQSxhQUFhLEdBQUd6N0IsSUFBaEI7UUFDQTtNQUNELENBWEssQ0FhTjs7O01BQ0EyN0IsYUFBYSxHQUFHQSxhQUFhLElBQUlGLGFBQWpDO0lBQ0EsQ0F6Q2tELENBMkNuRDtJQUNBO0lBQ0E7OztJQUNBLElBQUtFLGFBQUwsRUFBcUI7TUFDcEIsSUFBS0EsYUFBYSxLQUFLaEIsU0FBUyxDQUFFLENBQUYsQ0FBaEMsRUFBd0M7UUFDdkNBLFNBQVMsQ0FBQ2h2QixPQUFWLENBQW1CZ3dCLGFBQW5CO01BQ0E7O01BQ0QsT0FBT0gsU0FBUyxDQUFFRyxhQUFGLENBQWhCO0lBQ0E7RUFDRDtFQUVEO0FBQ0E7QUFDQTs7O0VBQ0EsU0FBU0ksV0FBVCxDQUFzQlIsQ0FBdEIsRUFBeUJTLFFBQXpCLEVBQW1DbkIsS0FBbkMsRUFBMENvQixTQUExQyxFQUFzRDtJQUNyRCxJQUFJQyxLQUFKO0lBQUEsSUFBV0MsT0FBWDtJQUFBLElBQW9CQyxJQUFwQjtJQUFBLElBQTBCOTVCLEdBQTFCO0lBQUEsSUFBK0JnUyxJQUEvQjtJQUFBLElBQ0N3bkIsVUFBVSxHQUFHLEVBRGQ7SUFBQSxJQUdDO0lBQ0FuQixTQUFTLEdBQUdZLENBQUMsQ0FBQ1osU0FBRixDQUFZbi9CLEtBQVosRUFKYixDQURxRCxDQU9yRDs7SUFDQSxJQUFLbS9CLFNBQVMsQ0FBRSxDQUFGLENBQWQsRUFBc0I7TUFDckIsS0FBTXlCLElBQU4sSUFBY2IsQ0FBQyxDQUFDTyxVQUFoQixFQUE2QjtRQUM1QkEsVUFBVSxDQUFFTSxJQUFJLENBQUNsN0IsV0FBTCxFQUFGLENBQVYsR0FBbUNxNkIsQ0FBQyxDQUFDTyxVQUFGLENBQWNNLElBQWQsQ0FBbkM7TUFDQTtJQUNEOztJQUVERCxPQUFPLEdBQUd4QixTQUFTLENBQUN2eUIsS0FBVixFQUFWLENBZHFELENBZ0JyRDs7SUFDQSxPQUFRK3pCLE9BQVIsRUFBa0I7TUFFakIsSUFBS1osQ0FBQyxDQUFDYyxjQUFGLENBQWtCRixPQUFsQixDQUFMLEVBQW1DO1FBQ2xDdEIsS0FBSyxDQUFFVSxDQUFDLENBQUNjLGNBQUYsQ0FBa0JGLE9BQWxCLENBQUYsQ0FBTCxHQUF1Q0gsUUFBdkM7TUFDQSxDQUpnQixDQU1qQjs7O01BQ0EsSUFBSyxDQUFDMW5CLElBQUQsSUFBUzJuQixTQUFULElBQXNCVixDQUFDLENBQUNlLFVBQTdCLEVBQTBDO1FBQ3pDTixRQUFRLEdBQUdULENBQUMsQ0FBQ2UsVUFBRixDQUFjTixRQUFkLEVBQXdCVCxDQUFDLENBQUNiLFFBQTFCLENBQVg7TUFDQTs7TUFFRHBtQixJQUFJLEdBQUc2bkIsT0FBUDtNQUNBQSxPQUFPLEdBQUd4QixTQUFTLENBQUN2eUIsS0FBVixFQUFWOztNQUVBLElBQUsrekIsT0FBTCxFQUFlO1FBRWQ7UUFDQSxJQUFLQSxPQUFPLEtBQUssR0FBakIsRUFBdUI7VUFFdEJBLE9BQU8sR0FBRzduQixJQUFWLENBRnNCLENBSXZCO1FBQ0MsQ0FMRCxNQUtPLElBQUtBLElBQUksS0FBSyxHQUFULElBQWdCQSxJQUFJLEtBQUs2bkIsT0FBOUIsRUFBd0M7VUFFOUM7VUFDQUMsSUFBSSxHQUFHTixVQUFVLENBQUV4bkIsSUFBSSxHQUFHLEdBQVAsR0FBYTZuQixPQUFmLENBQVYsSUFBc0NMLFVBQVUsQ0FBRSxPQUFPSyxPQUFULENBQXZELENBSDhDLENBSzlDOztVQUNBLElBQUssQ0FBQ0MsSUFBTixFQUFhO1lBQ1osS0FBTUYsS0FBTixJQUFlSixVQUFmLEVBQTRCO2NBRTNCO2NBQ0F4NUIsR0FBRyxHQUFHNDVCLEtBQUssQ0FBQ3Y1QixLQUFOLENBQWEsR0FBYixDQUFOOztjQUNBLElBQUtMLEdBQUcsQ0FBRSxDQUFGLENBQUgsS0FBYTY1QixPQUFsQixFQUE0QjtnQkFFM0I7Z0JBQ0FDLElBQUksR0FBR04sVUFBVSxDQUFFeG5CLElBQUksR0FBRyxHQUFQLEdBQWFoUyxHQUFHLENBQUUsQ0FBRixDQUFsQixDQUFWLElBQ053NUIsVUFBVSxDQUFFLE9BQU94NUIsR0FBRyxDQUFFLENBQUYsQ0FBWixDQURYOztnQkFFQSxJQUFLODVCLElBQUwsRUFBWTtrQkFFWDtrQkFDQSxJQUFLQSxJQUFJLEtBQUssSUFBZCxFQUFxQjtvQkFDcEJBLElBQUksR0FBR04sVUFBVSxDQUFFSSxLQUFGLENBQWpCLENBRG9CLENBR3JCO2tCQUNDLENBSkQsTUFJTyxJQUFLSixVQUFVLENBQUVJLEtBQUYsQ0FBVixLQUF3QixJQUE3QixFQUFvQztvQkFDMUNDLE9BQU8sR0FBRzc1QixHQUFHLENBQUUsQ0FBRixDQUFiO29CQUNBcTRCLFNBQVMsQ0FBQ2h2QixPQUFWLENBQW1CckosR0FBRyxDQUFFLENBQUYsQ0FBdEI7a0JBQ0E7O2tCQUNEO2dCQUNBO2NBQ0Q7WUFDRDtVQUNELENBL0I2QyxDQWlDOUM7OztVQUNBLElBQUs4NUIsSUFBSSxLQUFLLElBQWQsRUFBcUI7WUFFcEI7WUFDQSxJQUFLQSxJQUFJLElBQUliLENBQUMsQ0FBRSxRQUFGLENBQWQsRUFBNkI7Y0FBRTtjQUM5QlMsUUFBUSxHQUFHSSxJQUFJLENBQUVKLFFBQUYsQ0FBZjtZQUNBLENBRkQsTUFFTztjQUNOLElBQUk7Z0JBQ0hBLFFBQVEsR0FBR0ksSUFBSSxDQUFFSixRQUFGLENBQWY7Y0FDQSxDQUZELENBRUUsT0FBUXY3QixDQUFSLEVBQVk7Z0JBQ2IsT0FBTztrQkFDTnNXLEtBQUssRUFBRSxhQUREO2tCQUVOblgsS0FBSyxFQUFFdzhCLElBQUksR0FBRzM3QixDQUFILEdBQU8sd0JBQXdCNlQsSUFBeEIsR0FBK0IsTUFBL0IsR0FBd0M2bkI7Z0JBRnBELENBQVA7Y0FJQTtZQUNEO1VBQ0Q7UUFDRDtNQUNEO0lBQ0Q7O0lBRUQsT0FBTztNQUFFcGxCLEtBQUssRUFBRSxTQUFUO01BQW9CblcsSUFBSSxFQUFFbzdCO0lBQTFCLENBQVA7RUFDQTs7RUFFRDkvQixNQUFNLENBQUN3QyxNQUFQLENBQWU7SUFFZDtJQUNBNjlCLE1BQU0sRUFBRSxDQUhNO0lBS2Q7SUFDQUMsWUFBWSxFQUFFLEVBTkE7SUFPZEMsSUFBSSxFQUFFLEVBUFE7SUFTZHBCLFlBQVksRUFBRTtNQUNicUIsR0FBRyxFQUFFckMsWUFEUTtNQUVicjZCLElBQUksRUFBRSxLQUZPO01BR2IyOEIsT0FBTyxFQUFFNUMsY0FBYyxDQUFDeHlCLElBQWYsQ0FBcUIreUIsWUFBWSxDQUFFLENBQUYsQ0FBakMsQ0FISTtNQUlieC9CLE1BQU0sRUFBRSxJQUpLO01BS2I4aEMsV0FBVyxFQUFFLElBTEE7TUFNYmxELEtBQUssRUFBRSxJQU5NO01BT2JtRCxXQUFXLEVBQUUsa0RBUEE7O01BUWI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUVFQyxPQUFPLEVBQUU7UUFDUixLQUFLMUMsUUFERztRQUVSaDVCLElBQUksRUFBRSxZQUZFO1FBR1I2bkIsSUFBSSxFQUFFLFdBSEU7UUFJUnpiLEdBQUcsRUFBRSwyQkFKRztRQUtSdXZCLElBQUksRUFBRTtNQUxFLENBcEJJO01BNEJiM29CLFFBQVEsRUFBRTtRQUNUNUcsR0FBRyxFQUFFLFNBREk7UUFFVHliLElBQUksRUFBRSxRQUZHO1FBR1Q4VCxJQUFJLEVBQUU7TUFIRyxDQTVCRztNQWtDYlYsY0FBYyxFQUFFO1FBQ2Y3dUIsR0FBRyxFQUFFLGFBRFU7UUFFZnBNLElBQUksRUFBRSxjQUZTO1FBR2YyN0IsSUFBSSxFQUFFO01BSFMsQ0FsQ0g7TUF3Q2I7TUFDQTtNQUNBakIsVUFBVSxFQUFFO1FBRVg7UUFDQSxVQUFVMzFCLE1BSEM7UUFLWDtRQUNBLGFBQWEsSUFORjtRQVFYO1FBQ0EsYUFBYWpLLE1BQU0sQ0FBQ3NlLFNBVFQ7UUFXWDtRQUNBLFlBQVl0ZSxNQUFNLENBQUNvOUI7TUFaUixDQTFDQztNQXlEYjtNQUNBO01BQ0E7TUFDQTtNQUNBOEIsV0FBVyxFQUFFO1FBQ1pzQixHQUFHLEVBQUUsSUFETztRQUVadGdDLE9BQU8sRUFBRTtNQUZHO0lBN0RBLENBVEE7SUE0RWQ7SUFDQTtJQUNBO0lBQ0E0Z0MsU0FBUyxFQUFFLG1CQUFVLzlCLE1BQVYsRUFBa0JnK0IsUUFBbEIsRUFBNkI7TUFDdkMsT0FBT0EsUUFBUSxHQUVkO01BQ0E5QixVQUFVLENBQUVBLFVBQVUsQ0FBRWw4QixNQUFGLEVBQVUvQyxNQUFNLENBQUNtL0IsWUFBakIsQ0FBWixFQUE2QzRCLFFBQTdDLENBSEksR0FLZDtNQUNBOUIsVUFBVSxDQUFFai9CLE1BQU0sQ0FBQ20vQixZQUFULEVBQXVCcDhCLE1BQXZCLENBTlg7SUFPQSxDQXZGYTtJQXlGZGkrQixhQUFhLEVBQUUzQywyQkFBMkIsQ0FBRXBILFVBQUYsQ0F6RjVCO0lBMEZkZ0ssYUFBYSxFQUFFNUMsMkJBQTJCLENBQUVKLFVBQUYsQ0ExRjVCO0lBNEZkO0lBQ0FpRCxJQUFJLEVBQUUsY0FBVVYsR0FBVixFQUFlMzlCLE9BQWYsRUFBeUI7TUFFOUI7TUFDQSxJQUFLLFFBQU8yOUIsR0FBUCxNQUFlLFFBQXBCLEVBQStCO1FBQzlCMzlCLE9BQU8sR0FBRzI5QixHQUFWO1FBQ0FBLEdBQUcsR0FBR3A5QixTQUFOO01BQ0EsQ0FONkIsQ0FROUI7OztNQUNBUCxPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQjs7TUFFQSxJQUVDO01BQ0F5eEIsS0FIRDtNQUFBLElBS0M7TUFDQXp5QixDQU5EO01BQUEsSUFRQztNQUNBcy9CLFFBVEQ7TUFBQSxJQVdDO01BQ0FDLHFCQVpEO01BQUEsSUFjQztNQUNBQyxZQWZEO01BQUEsSUFpQkM7TUFDQUMsV0FsQkQ7TUFBQSxJQW9CQ0MsU0FwQkQ7TUFBQSxJQXNCQztNQUNBQyxlQXZCRDtNQUFBLElBeUJDO01BQ0FuQyxDQUFDLEdBQUdyL0IsTUFBTSxDQUFDOGdDLFNBQVAsQ0FBa0IsRUFBbEIsRUFBc0JqK0IsT0FBdEIsQ0ExQkw7TUFBQSxJQTRCQztNQUNBNCtCLGVBQWUsR0FBR3BDLENBQUMsQ0FBQ24vQixPQUFGLElBQWFtL0IsQ0E3QmhDO01BQUEsSUErQkM7TUFDQXFDLGtCQUFrQixHQUFHckMsQ0FBQyxDQUFDbi9CLE9BQUYsS0FDbEJ1aEMsZUFBZSxDQUFDbjlCLFFBQWhCLElBQTRCbTlCLGVBQWUsQ0FBQzVnQyxNQUQxQixJQUVuQmIsTUFBTSxDQUFFeWhDLGVBQUYsQ0FGYSxHQUduQnpoQyxNQUFNLENBQUNtZCxLQW5DVjtNQUFBLElBcUNDO01BQ0FuQyxRQUFRLEdBQUdoYixNQUFNLENBQUMwYSxRQUFQLEVBdENaO01BQUEsSUF1Q0NpbkIsZ0JBQWdCLEdBQUczaEMsTUFBTSxDQUFDMlosU0FBUCxDQUFrQixhQUFsQixDQXZDcEI7TUFBQSxJQXlDQztNQUNBaW9CLFdBQVUsR0FBR3ZDLENBQUMsQ0FBQ3VDLFVBQUYsSUFBZ0IsRUExQzlCO01BQUEsSUE0Q0M7TUFDQUMsY0FBYyxHQUFHLEVBN0NsQjtNQUFBLElBOENDQyxtQkFBbUIsR0FBRyxFQTlDdkI7TUFBQSxJQWdEQztNQUNBam5CLEtBQUssR0FBRyxDQWpEVDtNQUFBLElBbURDO01BQ0FrbkIsUUFBUSxHQUFHLFVBcERaO01BQUEsSUFzREM7TUFDQXBELEtBQUssR0FBRztRQUNQdmhCLFVBQVUsRUFBRSxDQURMO1FBR1A7UUFDQXVpQixpQkFBaUIsRUFBRSwyQkFBVXQ3QixHQUFWLEVBQWdCO1VBQ2xDLElBQUlxRyxLQUFKOztVQUNBLElBQUttUSxLQUFLLEtBQUssQ0FBZixFQUFtQjtZQUNsQixJQUFLLENBQUMybUIsZUFBTixFQUF3QjtjQUN2QkEsZUFBZSxHQUFHLEVBQWxCOztjQUNBLE9BQVU5MkIsS0FBSyxHQUFHa3pCLFFBQVEsQ0FBQzd5QixJQUFULENBQWVxMkIscUJBQWYsQ0FBbEIsRUFBNkQ7Z0JBQzVESSxlQUFlLENBQUU5MkIsS0FBSyxDQUFFLENBQUYsQ0FBTCxDQUFXMUYsV0FBWCxFQUFGLENBQWYsR0FBOEMwRixLQUFLLENBQUUsQ0FBRixDQUFuRDtjQUNBO1lBQ0Q7O1lBQ0RBLEtBQUssR0FBRzgyQixlQUFlLENBQUVuOUIsR0FBRyxDQUFDVyxXQUFKLEVBQUYsQ0FBdkI7VUFDQTs7VUFDRCxPQUFPMEYsS0FBSyxJQUFJLElBQVQsR0FBZ0IsSUFBaEIsR0FBdUJBLEtBQTlCO1FBQ0EsQ0FoQk07UUFrQlA7UUFDQXMzQixxQkFBcUIsRUFBRSxpQ0FBVztVQUNqQyxPQUFPbm5CLEtBQUssS0FBSyxDQUFWLEdBQWN1bUIscUJBQWQsR0FBc0MsSUFBN0M7UUFDQSxDQXJCTTtRQXVCUDtRQUNBYSxnQkFBZ0IsRUFBRSwwQkFBVXIvQixJQUFWLEVBQWdCb0QsS0FBaEIsRUFBd0I7VUFDekMsSUFBSWs4QixLQUFLLEdBQUd0L0IsSUFBSSxDQUFDb0MsV0FBTCxFQUFaOztVQUNBLElBQUssQ0FBQzZWLEtBQU4sRUFBYztZQUNialksSUFBSSxHQUFHay9CLG1CQUFtQixDQUFFSSxLQUFGLENBQW5CLEdBQStCSixtQkFBbUIsQ0FBRUksS0FBRixDQUFuQixJQUFnQ3QvQixJQUF0RTtZQUNBaS9CLGNBQWMsQ0FBRWovQixJQUFGLENBQWQsR0FBeUJvRCxLQUF6QjtVQUNBOztVQUNELE9BQU8sSUFBUDtRQUNBLENBL0JNO1FBaUNQO1FBQ0FtOEIsZ0JBQWdCLEVBQUUsMEJBQVVyK0IsSUFBVixFQUFpQjtVQUNsQyxJQUFLLENBQUMrVyxLQUFOLEVBQWM7WUFDYndrQixDQUFDLENBQUNLLFFBQUYsR0FBYTU3QixJQUFiO1VBQ0E7O1VBQ0QsT0FBTyxJQUFQO1FBQ0EsQ0F2Q007UUF5Q1A7UUFDQTg5QixVQUFVLEVBQUUsb0JBQVVqZ0MsR0FBVixFQUFnQjtVQUMzQixJQUFJeWdDLElBQUo7O1VBQ0EsSUFBS3pnQyxHQUFMLEVBQVc7WUFDVixJQUFLa1osS0FBSyxHQUFHLENBQWIsRUFBaUI7Y0FDaEIsS0FBTXVuQixJQUFOLElBQWN6Z0MsR0FBZCxFQUFvQjtnQkFFbkI7Z0JBQ0FpZ0MsV0FBVSxDQUFFUSxJQUFGLENBQVYsR0FBcUIsQ0FBRVIsV0FBVSxDQUFFUSxJQUFGLENBQVosRUFBc0J6Z0MsR0FBRyxDQUFFeWdDLElBQUYsQ0FBekIsQ0FBckI7Y0FDQTtZQUNELENBTkQsTUFNTztjQUVOO2NBQ0F6RCxLQUFLLENBQUM1akIsTUFBTixDQUFjcFosR0FBRyxDQUFFZzlCLEtBQUssQ0FBQzBELE1BQVIsQ0FBakI7WUFDQTtVQUNEOztVQUNELE9BQU8sSUFBUDtRQUNBLENBMURNO1FBNERQO1FBQ0FDLEtBQUssRUFBRSxlQUFVQyxVQUFWLEVBQXVCO1VBQzdCLElBQUlDLFNBQVMsR0FBR0QsVUFBVSxJQUFJUixRQUE5Qjs7VUFDQSxJQUFLUixTQUFMLEVBQWlCO1lBQ2hCQSxTQUFTLENBQUNlLEtBQVYsQ0FBaUJFLFNBQWpCO1VBQ0E7O1VBQ0Q1NkIsSUFBSSxDQUFFLENBQUYsRUFBSzQ2QixTQUFMLENBQUo7VUFDQSxPQUFPLElBQVA7UUFDQTtNQXBFTSxDQXZEVCxDQVg4QixDQXlJOUI7OztNQUNBeG5CLFFBQVEsQ0FBQ0YsT0FBVCxDQUFrQjZqQixLQUFsQixFQUEwQmhILFFBQTFCLEdBQXFDZ0ssZ0JBQWdCLENBQUMvb0IsR0FBdEQ7TUFDQStsQixLQUFLLENBQUM4RCxPQUFOLEdBQWdCOUQsS0FBSyxDQUFDLzJCLElBQXRCO01BQ0ErMkIsS0FBSyxDQUFDajdCLEtBQU4sR0FBY2k3QixLQUFLLENBQUMxakIsSUFBcEIsQ0E1SThCLENBOEk5QjtNQUNBO01BQ0E7TUFDQTs7TUFDQW9rQixDQUFDLENBQUNtQixHQUFGLEdBQVEsQ0FBRSxDQUFFQSxHQUFHLElBQUluQixDQUFDLENBQUNtQixHQUFULElBQWdCckMsWUFBbEIsSUFBbUMsRUFBckMsRUFDTjM2QixPQURNLENBQ0drNkIsS0FESCxFQUNVLEVBRFYsRUFFTmw2QixPQUZNLENBRUd1NkIsU0FGSCxFQUVjSyxZQUFZLENBQUUsQ0FBRixDQUFaLEdBQW9CLElBRmxDLENBQVIsQ0FsSjhCLENBc0o5Qjs7TUFDQWlCLENBQUMsQ0FBQ3Y3QixJQUFGLEdBQVNqQixPQUFPLENBQUM2L0IsTUFBUixJQUFrQjcvQixPQUFPLENBQUNpQixJQUExQixJQUFrQ3U3QixDQUFDLENBQUNxRCxNQUFwQyxJQUE4Q3JELENBQUMsQ0FBQ3Y3QixJQUF6RCxDQXZKOEIsQ0F5SjlCOztNQUNBdTdCLENBQUMsQ0FBQ1osU0FBRixHQUFjeitCLE1BQU0sQ0FBQzJFLElBQVAsQ0FBYTA2QixDQUFDLENBQUNiLFFBQUYsSUFBYyxHQUEzQixFQUFpQ3g1QixXQUFqQyxHQUErQzBGLEtBQS9DLENBQXNENk8sU0FBdEQsS0FBcUUsQ0FBRSxFQUFGLENBQW5GLENBMUo4QixDQTRKOUI7O01BQ0EsSUFBSzhsQixDQUFDLENBQUNzRCxXQUFGLElBQWlCLElBQXRCLEVBQTZCO1FBQzVCck8sS0FBSyxHQUFHMEosSUFBSSxDQUFDanpCLElBQUwsQ0FBV3MwQixDQUFDLENBQUNtQixHQUFGLENBQU14N0IsV0FBTixFQUFYLENBQVI7UUFDQXE2QixDQUFDLENBQUNzRCxXQUFGLEdBQWdCLENBQUMsRUFBR3JPLEtBQUssS0FDdEJBLEtBQUssQ0FBRSxDQUFGLENBQUwsS0FBZThKLFlBQVksQ0FBRSxDQUFGLENBQTNCLElBQW9DOUosS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlOEosWUFBWSxDQUFFLENBQUYsQ0FBL0QsSUFDRCxDQUFFOUosS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFnQkEsS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlLE9BQWYsR0FBeUIsSUFBekIsR0FBZ0MsS0FBaEQsQ0FBRixPQUNHOEosWUFBWSxDQUFFLENBQUYsQ0FBWixLQUF1QkEsWUFBWSxDQUFFLENBQUYsQ0FBWixLQUFzQixPQUF0QixHQUFnQyxJQUFoQyxHQUF1QyxLQUE5RCxDQURILENBRnVCLENBQVIsQ0FBakI7TUFLQSxDQXBLNkIsQ0FzSzlCOzs7TUFDQSxJQUFLaUIsQ0FBQyxDQUFDMzZCLElBQUYsSUFBVTI2QixDQUFDLENBQUNxQixXQUFaLElBQTJCLE9BQU9yQixDQUFDLENBQUMzNkIsSUFBVCxLQUFrQixRQUFsRCxFQUE2RDtRQUM1RDI2QixDQUFDLENBQUMzNkIsSUFBRixHQUFTMUUsTUFBTSxDQUFDK2lCLEtBQVAsQ0FBY3NjLENBQUMsQ0FBQzM2QixJQUFoQixFQUFzQjI2QixDQUFDLENBQUN1RCxXQUF4QixDQUFUO01BQ0EsQ0F6SzZCLENBMks5Qjs7O01BQ0FsRSw2QkFBNkIsQ0FBRXpILFVBQUYsRUFBY29JLENBQWQsRUFBaUJ4OEIsT0FBakIsRUFBMEI4N0IsS0FBMUIsQ0FBN0IsQ0E1SzhCLENBOEs5Qjs7TUFDQSxJQUFLOWpCLEtBQUssS0FBSyxDQUFmLEVBQW1CO1FBQ2xCLE9BQU84akIsS0FBUDtNQUNBLENBakw2QixDQW1MOUI7TUFDQTs7O01BQ0EyQyxXQUFXLEdBQUd0aEMsTUFBTSxDQUFDbWQsS0FBUCxJQUFnQmtpQixDQUFDLENBQUN6Z0MsTUFBaEMsQ0FyTDhCLENBdUw5Qjs7TUFDQSxJQUFLMGlDLFdBQVcsSUFBSXRoQyxNQUFNLENBQUNxZ0MsTUFBUCxPQUFvQixDQUF4QyxFQUE0QztRQUMzQ3JnQyxNQUFNLENBQUNtZCxLQUFQLENBQWE4SixPQUFiLENBQXNCLFdBQXRCO01BQ0EsQ0ExTDZCLENBNEw5Qjs7O01BQ0FvWSxDQUFDLENBQUN2N0IsSUFBRixHQUFTdTdCLENBQUMsQ0FBQ3Y3QixJQUFGLENBQU9uRCxXQUFQLEVBQVQsQ0E3TDhCLENBK0w5Qjs7TUFDQTArQixDQUFDLENBQUN3RCxVQUFGLEdBQWUsQ0FBQy9FLFVBQVUsQ0FBQ3p5QixJQUFYLENBQWlCZzBCLENBQUMsQ0FBQ3Y3QixJQUFuQixDQUFoQixDQWhNOEIsQ0FrTTlCO01BQ0E7O01BQ0FxOUIsUUFBUSxHQUFHOUIsQ0FBQyxDQUFDbUIsR0FBYixDQXBNOEIsQ0FzTTlCOztNQUNBLElBQUssQ0FBQ25CLENBQUMsQ0FBQ3dELFVBQVIsRUFBcUI7UUFFcEI7UUFDQSxJQUFLeEQsQ0FBQyxDQUFDMzZCLElBQVAsRUFBYztVQUNieThCLFFBQVEsR0FBSzlCLENBQUMsQ0FBQ21CLEdBQUYsSUFBUyxDQUFFOUQsTUFBTSxDQUFDcnhCLElBQVAsQ0FBYTgxQixRQUFiLElBQTBCLEdBQTFCLEdBQWdDLEdBQWxDLElBQTBDOUIsQ0FBQyxDQUFDMzZCLElBQWxFLENBRGEsQ0FHYjs7VUFDQSxPQUFPMjZCLENBQUMsQ0FBQzM2QixJQUFUO1FBQ0EsQ0FSbUIsQ0FVcEI7OztRQUNBLElBQUsyNkIsQ0FBQyxDQUFDcnpCLEtBQUYsS0FBWSxLQUFqQixFQUF5QjtVQUN4QnF6QixDQUFDLENBQUNtQixHQUFGLEdBQVE3QyxHQUFHLENBQUN0eUIsSUFBSixDQUFVODFCLFFBQVYsSUFFUDtVQUNBQSxRQUFRLENBQUMzOUIsT0FBVCxDQUFrQm02QixHQUFsQixFQUF1QixTQUFTbEIsS0FBSyxFQUFyQyxDQUhPLEdBS1A7VUFDQTBFLFFBQVEsSUFBS3pFLE1BQU0sQ0FBQ3J4QixJQUFQLENBQWE4MUIsUUFBYixJQUEwQixHQUExQixHQUFnQyxHQUFyQyxDQUFSLEdBQXFELElBQXJELEdBQTREMUUsS0FBSyxFQU5sRTtRQU9BO01BQ0QsQ0EzTjZCLENBNk45Qjs7O01BQ0EsSUFBSzRDLENBQUMsQ0FBQ3lELFVBQVAsRUFBb0I7UUFDbkIsSUFBSzlpQyxNQUFNLENBQUNzZ0MsWUFBUCxDQUFxQmEsUUFBckIsQ0FBTCxFQUF1QztVQUN0Q3hDLEtBQUssQ0FBQ3NELGdCQUFOLENBQXdCLG1CQUF4QixFQUE2Q2ppQyxNQUFNLENBQUNzZ0MsWUFBUCxDQUFxQmEsUUFBckIsQ0FBN0M7UUFDQTs7UUFDRCxJQUFLbmhDLE1BQU0sQ0FBQ3VnQyxJQUFQLENBQWFZLFFBQWIsQ0FBTCxFQUErQjtVQUM5QnhDLEtBQUssQ0FBQ3NELGdCQUFOLENBQXdCLGVBQXhCLEVBQXlDamlDLE1BQU0sQ0FBQ3VnQyxJQUFQLENBQWFZLFFBQWIsQ0FBekM7UUFDQTtNQUNELENBck82QixDQXVPOUI7OztNQUNBLElBQUs5QixDQUFDLENBQUMzNkIsSUFBRixJQUFVMjZCLENBQUMsQ0FBQ3dELFVBQVosSUFBMEJ4RCxDQUFDLENBQUNzQixXQUFGLEtBQWtCLEtBQTVDLElBQXFEOTlCLE9BQU8sQ0FBQzg5QixXQUFsRSxFQUFnRjtRQUMvRWhDLEtBQUssQ0FBQ3NELGdCQUFOLENBQXdCLGNBQXhCLEVBQXdDNUMsQ0FBQyxDQUFDc0IsV0FBMUM7TUFDQSxDQTFPNkIsQ0E0TzlCOzs7TUFDQWhDLEtBQUssQ0FBQ3NELGdCQUFOLENBQ0MsUUFERCxFQUVDNUMsQ0FBQyxDQUFDWixTQUFGLENBQWEsQ0FBYixLQUFvQlksQ0FBQyxDQUFDdUIsT0FBRixDQUFXdkIsQ0FBQyxDQUFDWixTQUFGLENBQWEsQ0FBYixDQUFYLENBQXBCLEdBQ0NZLENBQUMsQ0FBQ3VCLE9BQUYsQ0FBV3ZCLENBQUMsQ0FBQ1osU0FBRixDQUFhLENBQWIsQ0FBWCxLQUNHWSxDQUFDLENBQUNaLFNBQUYsQ0FBYSxDQUFiLE1BQXFCLEdBQXJCLEdBQTJCLE9BQU9QLFFBQVAsR0FBa0IsVUFBN0MsR0FBMEQsRUFEN0QsQ0FERCxHQUdDbUIsQ0FBQyxDQUFDdUIsT0FBRixDQUFXLEdBQVgsQ0FMRixFQTdPOEIsQ0FxUDlCOztNQUNBLEtBQU0vK0IsQ0FBTixJQUFXdzlCLENBQUMsQ0FBQzBELE9BQWIsRUFBdUI7UUFDdEJwRSxLQUFLLENBQUNzRCxnQkFBTixDQUF3QnBnQyxDQUF4QixFQUEyQnc5QixDQUFDLENBQUMwRCxPQUFGLENBQVdsaEMsQ0FBWCxDQUEzQjtNQUNBLENBeFA2QixDQTBQOUI7OztNQUNBLElBQUt3OUIsQ0FBQyxDQUFDMkQsVUFBRixLQUNGM0QsQ0FBQyxDQUFDMkQsVUFBRixDQUFhL2hDLElBQWIsQ0FBbUJ3Z0MsZUFBbkIsRUFBb0M5QyxLQUFwQyxFQUEyQ1UsQ0FBM0MsTUFBbUQsS0FBbkQsSUFBNER4a0IsS0FBSyxLQUFLLENBRHBFLENBQUwsRUFDK0U7UUFFOUU7UUFDQSxPQUFPOGpCLEtBQUssQ0FBQzJELEtBQU4sRUFBUDtNQUNBLENBaFE2QixDQWtROUI7OztNQUNBUCxRQUFRLEdBQUcsT0FBWCxDQW5ROEIsQ0FxUTlCOztNQUNBLEtBQU1sZ0MsQ0FBTixJQUFXO1FBQUU0Z0MsT0FBTyxFQUFFLENBQVg7UUFBYy8rQixLQUFLLEVBQUUsQ0FBckI7UUFBd0JpMEIsUUFBUSxFQUFFO01BQWxDLENBQVgsRUFBbUQ7UUFDbERnSCxLQUFLLENBQUU5OEIsQ0FBRixDQUFMLENBQVl3OUIsQ0FBQyxDQUFFeDlCLENBQUYsQ0FBYjtNQUNBLENBeFE2QixDQTBROUI7OztNQUNBMC9CLFNBQVMsR0FBRzdDLDZCQUE2QixDQUFFVCxVQUFGLEVBQWNvQixDQUFkLEVBQWlCeDhCLE9BQWpCLEVBQTBCODdCLEtBQTFCLENBQXpDLENBM1E4QixDQTZROUI7O01BQ0EsSUFBSyxDQUFDNEMsU0FBTixFQUFrQjtRQUNqQjM1QixJQUFJLENBQUUsQ0FBQyxDQUFILEVBQU0sY0FBTixDQUFKO01BQ0EsQ0FGRCxNQUVPO1FBQ04rMkIsS0FBSyxDQUFDdmhCLFVBQU4sR0FBbUIsQ0FBbkIsQ0FETSxDQUdOOztRQUNBLElBQUtra0IsV0FBTCxFQUFtQjtVQUNsQkksa0JBQWtCLENBQUN6YSxPQUFuQixDQUE0QixVQUE1QixFQUF3QyxDQUFFMFgsS0FBRixFQUFTVSxDQUFULENBQXhDO1FBQ0EsQ0FOSyxDQVFOOzs7UUFDQSxJQUFLeGtCLEtBQUssS0FBSyxDQUFmLEVBQW1CO1VBQ2xCLE9BQU84akIsS0FBUDtRQUNBLENBWEssQ0FhTjs7O1FBQ0EsSUFBS1UsQ0FBQyxDQUFDN0IsS0FBRixJQUFXNkIsQ0FBQyxDQUFDOUYsT0FBRixHQUFZLENBQTVCLEVBQWdDO1VBQy9COEgsWUFBWSxHQUFHbGlDLE1BQU0sQ0FBQ21lLFVBQVAsQ0FBbUIsWUFBVztZQUM1Q3FoQixLQUFLLENBQUMyRCxLQUFOLENBQWEsU0FBYjtVQUNBLENBRmMsRUFFWmpELENBQUMsQ0FBQzlGLE9BRlUsQ0FBZjtRQUdBOztRQUVELElBQUk7VUFDSDFlLEtBQUssR0FBRyxDQUFSO1VBQ0EwbUIsU0FBUyxDQUFDMEIsSUFBVixDQUFnQnBCLGNBQWhCLEVBQWdDajZCLElBQWhDO1FBQ0EsQ0FIRCxDQUdFLE9BQVFyRCxDQUFSLEVBQVk7VUFFYjtVQUNBLElBQUtzVyxLQUFLLEdBQUcsQ0FBYixFQUFpQjtZQUNoQmpULElBQUksQ0FBRSxDQUFDLENBQUgsRUFBTXJELENBQU4sQ0FBSixDQURnQixDQUdqQjtVQUNDLENBSkQsTUFJTztZQUNOLE1BQU1BLENBQU47VUFDQTtRQUNEO01BQ0QsQ0FsVDZCLENBb1Q5Qjs7O01BQ0EsU0FBU3FELElBQVQsQ0FBZXk2QixNQUFmLEVBQXVCYSxnQkFBdkIsRUFBeUM1RCxTQUF6QyxFQUFvRHlELE9BQXBELEVBQThEO1FBQzdELElBQUloRCxTQUFKO1FBQUEsSUFBZTBDLE9BQWY7UUFBQSxJQUF3Qi8rQixLQUF4QjtRQUFBLElBQStCbzhCLFFBQS9CO1FBQUEsSUFBeUNxRCxRQUF6QztRQUFBLElBQ0NaLFVBQVUsR0FBR1csZ0JBRGQsQ0FENkQsQ0FJN0Q7O1FBQ0EsSUFBS3JvQixLQUFLLEtBQUssQ0FBZixFQUFtQjtVQUNsQjtRQUNBLENBUDRELENBUzdEOzs7UUFDQUEsS0FBSyxHQUFHLENBQVIsQ0FWNkQsQ0FZN0Q7O1FBQ0EsSUFBS3dtQixZQUFMLEVBQW9CO1VBQ25CbGlDLE1BQU0sQ0FBQ3E2QixZQUFQLENBQXFCNkgsWUFBckI7UUFDQSxDQWY0RCxDQWlCN0Q7UUFDQTs7O1FBQ0FFLFNBQVMsR0FBR24rQixTQUFaLENBbkI2RCxDQXFCN0Q7O1FBQ0FnK0IscUJBQXFCLEdBQUcyQixPQUFPLElBQUksRUFBbkMsQ0F0QjZELENBd0I3RDs7UUFDQXBFLEtBQUssQ0FBQ3ZoQixVQUFOLEdBQW1CaWxCLE1BQU0sR0FBRyxDQUFULEdBQWEsQ0FBYixHQUFpQixDQUFwQyxDQXpCNkQsQ0EyQjdEOztRQUNBdEMsU0FBUyxHQUFHc0MsTUFBTSxJQUFJLEdBQVYsSUFBaUJBLE1BQU0sR0FBRyxHQUExQixJQUFpQ0EsTUFBTSxLQUFLLEdBQXhELENBNUI2RCxDQThCN0Q7O1FBQ0EsSUFBSy9DLFNBQUwsRUFBaUI7VUFDaEJRLFFBQVEsR0FBR1YsbUJBQW1CLENBQUVDLENBQUYsRUFBS1YsS0FBTCxFQUFZVyxTQUFaLENBQTlCO1FBQ0EsQ0FqQzRELENBbUM3RDs7O1FBQ0FRLFFBQVEsR0FBR0QsV0FBVyxDQUFFUixDQUFGLEVBQUtTLFFBQUwsRUFBZW5CLEtBQWYsRUFBc0JvQixTQUF0QixDQUF0QixDQXBDNkQsQ0FzQzdEOztRQUNBLElBQUtBLFNBQUwsRUFBaUI7VUFFaEI7VUFDQSxJQUFLVixDQUFDLENBQUN5RCxVQUFQLEVBQW9CO1lBQ25CSyxRQUFRLEdBQUd4RSxLQUFLLENBQUNnQixpQkFBTixDQUF5QixlQUF6QixDQUFYOztZQUNBLElBQUt3RCxRQUFMLEVBQWdCO2NBQ2ZuakMsTUFBTSxDQUFDc2dDLFlBQVAsQ0FBcUJhLFFBQXJCLElBQWtDZ0MsUUFBbEM7WUFDQTs7WUFDREEsUUFBUSxHQUFHeEUsS0FBSyxDQUFDZ0IsaUJBQU4sQ0FBeUIsTUFBekIsQ0FBWDs7WUFDQSxJQUFLd0QsUUFBTCxFQUFnQjtjQUNmbmpDLE1BQU0sQ0FBQ3VnQyxJQUFQLENBQWFZLFFBQWIsSUFBMEJnQyxRQUExQjtZQUNBO1VBQ0QsQ0FaZSxDQWNoQjs7O1VBQ0EsSUFBS2QsTUFBTSxLQUFLLEdBQVgsSUFBa0JoRCxDQUFDLENBQUN2N0IsSUFBRixLQUFXLE1BQWxDLEVBQTJDO1lBQzFDeStCLFVBQVUsR0FBRyxXQUFiLENBRDBDLENBRzNDO1VBQ0MsQ0FKRCxNQUlPLElBQUtGLE1BQU0sS0FBSyxHQUFoQixFQUFzQjtZQUM1QkUsVUFBVSxHQUFHLGFBQWIsQ0FENEIsQ0FHN0I7VUFDQyxDQUpNLE1BSUE7WUFDTkEsVUFBVSxHQUFHekMsUUFBUSxDQUFDamxCLEtBQXRCO1lBQ0E0bkIsT0FBTyxHQUFHM0MsUUFBUSxDQUFDcDdCLElBQW5CO1lBQ0FoQixLQUFLLEdBQUdvOEIsUUFBUSxDQUFDcDhCLEtBQWpCO1lBQ0FxOEIsU0FBUyxHQUFHLENBQUNyOEIsS0FBYjtVQUNBO1FBQ0QsQ0E3QkQsTUE2Qk87VUFFTjtVQUNBO1VBQ0FBLEtBQUssR0FBRzYrQixVQUFSOztVQUNBLElBQUtGLE1BQU0sSUFBSSxDQUFDRSxVQUFoQixFQUE2QjtZQUM1QkEsVUFBVSxHQUFHLE9BQWI7O1lBQ0EsSUFBS0YsTUFBTSxHQUFHLENBQWQsRUFBa0I7Y0FDakJBLE1BQU0sR0FBRyxDQUFUO1lBQ0E7VUFDRDtRQUNELENBL0U0RCxDQWlGN0Q7OztRQUNBMUQsS0FBSyxDQUFDMEQsTUFBTixHQUFlQSxNQUFmO1FBQ0ExRCxLQUFLLENBQUM0RCxVQUFOLEdBQW1CLENBQUVXLGdCQUFnQixJQUFJWCxVQUF0QixJQUFxQyxFQUF4RCxDQW5GNkQsQ0FxRjdEOztRQUNBLElBQUt4QyxTQUFMLEVBQWlCO1VBQ2hCL2tCLFFBQVEsQ0FBQ3FCLFdBQVQsQ0FBc0JvbEIsZUFBdEIsRUFBdUMsQ0FBRWdCLE9BQUYsRUFBV0YsVUFBWCxFQUF1QjVELEtBQXZCLENBQXZDO1FBQ0EsQ0FGRCxNQUVPO1VBQ04zakIsUUFBUSxDQUFDeWMsVUFBVCxDQUFxQmdLLGVBQXJCLEVBQXNDLENBQUU5QyxLQUFGLEVBQVM0RCxVQUFULEVBQXFCNytCLEtBQXJCLENBQXRDO1FBQ0EsQ0ExRjRELENBNEY3RDs7O1FBQ0FpN0IsS0FBSyxDQUFDaUQsVUFBTixDQUFrQkEsV0FBbEI7UUFDQUEsV0FBVSxHQUFHeCtCLFNBQWI7O1FBRUEsSUFBS2srQixXQUFMLEVBQW1CO1VBQ2xCSSxrQkFBa0IsQ0FBQ3phLE9BQW5CLENBQTRCOFksU0FBUyxHQUFHLGFBQUgsR0FBbUIsV0FBeEQsRUFDQyxDQUFFcEIsS0FBRixFQUFTVSxDQUFULEVBQVlVLFNBQVMsR0FBRzBDLE9BQUgsR0FBYS8rQixLQUFsQyxDQUREO1FBRUEsQ0FuRzRELENBcUc3RDs7O1FBQ0FpK0IsZ0JBQWdCLENBQUNsbkIsUUFBakIsQ0FBMkJnbkIsZUFBM0IsRUFBNEMsQ0FBRTlDLEtBQUYsRUFBUzRELFVBQVQsQ0FBNUM7O1FBRUEsSUFBS2pCLFdBQUwsRUFBbUI7VUFDbEJJLGtCQUFrQixDQUFDemEsT0FBbkIsQ0FBNEIsY0FBNUIsRUFBNEMsQ0FBRTBYLEtBQUYsRUFBU1UsQ0FBVCxDQUE1QyxFQURrQixDQUdsQjs7VUFDQSxJQUFLLENBQUcsR0FBRXIvQixNQUFNLENBQUNxZ0MsTUFBakIsRUFBNEI7WUFDM0JyZ0MsTUFBTSxDQUFDbWQsS0FBUCxDQUFhOEosT0FBYixDQUFzQixVQUF0QjtVQUNBO1FBQ0Q7TUFDRDs7TUFFRCxPQUFPMFgsS0FBUDtJQUNBLENBcmdCYTtJQXVnQmR5RSxPQUFPLEVBQUUsaUJBQVU1QyxHQUFWLEVBQWU5N0IsSUFBZixFQUFxQmhELFFBQXJCLEVBQWdDO01BQ3hDLE9BQU8xQixNQUFNLENBQUNrQixHQUFQLENBQVlzL0IsR0FBWixFQUFpQjk3QixJQUFqQixFQUF1QmhELFFBQXZCLEVBQWlDLE1BQWpDLENBQVA7SUFDQSxDQXpnQmE7SUEyZ0JkMmhDLFNBQVMsRUFBRSxtQkFBVTdDLEdBQVYsRUFBZTkrQixRQUFmLEVBQTBCO01BQ3BDLE9BQU8xQixNQUFNLENBQUNrQixHQUFQLENBQVlzL0IsR0FBWixFQUFpQnA5QixTQUFqQixFQUE0QjFCLFFBQTVCLEVBQXNDLFFBQXRDLENBQVA7SUFDQTtFQTdnQmEsQ0FBZjtFQWdoQkExQixNQUFNLENBQUN5QixJQUFQLENBQWEsQ0FBRSxLQUFGLEVBQVMsTUFBVCxDQUFiLEVBQWdDLFVBQVVJLENBQVYsRUFBYTZnQyxNQUFiLEVBQXNCO0lBQ3JEMWlDLE1BQU0sQ0FBRTBpQyxNQUFGLENBQU4sR0FBbUIsVUFBVWxDLEdBQVYsRUFBZTk3QixJQUFmLEVBQXFCaEQsUUFBckIsRUFBK0JvQyxJQUEvQixFQUFzQztNQUV4RDtNQUNBLElBQUs5RCxNQUFNLENBQUNpRCxVQUFQLENBQW1CeUIsSUFBbkIsQ0FBTCxFQUFpQztRQUNoQ1osSUFBSSxHQUFHQSxJQUFJLElBQUlwQyxRQUFmO1FBQ0FBLFFBQVEsR0FBR2dELElBQVg7UUFDQUEsSUFBSSxHQUFHdEIsU0FBUDtNQUNBLENBUHVELENBU3hEOzs7TUFDQSxPQUFPcEQsTUFBTSxDQUFDa2hDLElBQVAsQ0FBYWxoQyxNQUFNLENBQUN3QyxNQUFQLENBQWU7UUFDbENnK0IsR0FBRyxFQUFFQSxHQUQ2QjtRQUVsQzE4QixJQUFJLEVBQUU0K0IsTUFGNEI7UUFHbENsRSxRQUFRLEVBQUUxNkIsSUFId0I7UUFJbENZLElBQUksRUFBRUEsSUFKNEI7UUFLbEMrOUIsT0FBTyxFQUFFL2dDO01BTHlCLENBQWYsRUFNakIxQixNQUFNLENBQUNrRCxhQUFQLENBQXNCczlCLEdBQXRCLEtBQStCQSxHQU5kLENBQWIsQ0FBUDtJQU9BLENBakJEO0VBa0JBLENBbkJEOztFQXNCQXhnQyxNQUFNLENBQUNndEIsUUFBUCxHQUFrQixVQUFVd1QsR0FBVixFQUFnQjtJQUNqQyxPQUFPeGdDLE1BQU0sQ0FBQ2toQyxJQUFQLENBQWE7TUFDbkJWLEdBQUcsRUFBRUEsR0FEYztNQUduQjtNQUNBMThCLElBQUksRUFBRSxLQUphO01BS25CMDZCLFFBQVEsRUFBRSxRQUxTO01BTW5CeHlCLEtBQUssRUFBRSxJQU5ZO01BT25Cd3hCLEtBQUssRUFBRSxLQVBZO01BUW5CNStCLE1BQU0sRUFBRSxLQVJXO01BU25CLFVBQVU7SUFUUyxDQUFiLENBQVA7RUFXQSxDQVpEOztFQWVBb0IsTUFBTSxDQUFDRyxFQUFQLENBQVVxQyxNQUFWLENBQWtCO0lBQ2pCOGdDLE9BQU8sRUFBRSxpQkFBVXZXLElBQVYsRUFBaUI7TUFDekIsSUFBSy9zQixNQUFNLENBQUNpRCxVQUFQLENBQW1COHBCLElBQW5CLENBQUwsRUFBaUM7UUFDaEMsT0FBTyxLQUFLdHJCLElBQUwsQ0FBVyxVQUFVSSxDQUFWLEVBQWM7VUFDL0I3QixNQUFNLENBQUUsSUFBRixDQUFOLENBQWVzakMsT0FBZixDQUF3QnZXLElBQUksQ0FBQzlyQixJQUFMLENBQVcsSUFBWCxFQUFpQlksQ0FBakIsQ0FBeEI7UUFDQSxDQUZNLENBQVA7TUFHQTs7TUFFRCxJQUFLLEtBQU0sQ0FBTixDQUFMLEVBQWlCO1FBRWhCO1FBQ0EsSUFBSXlpQixJQUFJLEdBQUd0a0IsTUFBTSxDQUFFK3NCLElBQUYsRUFBUSxLQUFNLENBQU4sRUFBVWppQixhQUFsQixDQUFOLENBQXdDN0ksRUFBeEMsQ0FBNEMsQ0FBNUMsRUFBZ0RhLEtBQWhELENBQXVELElBQXZELENBQVg7O1FBRUEsSUFBSyxLQUFNLENBQU4sRUFBVTZJLFVBQWYsRUFBNEI7VUFDM0IyWSxJQUFJLENBQUNvSixZQUFMLENBQW1CLEtBQU0sQ0FBTixDQUFuQjtRQUNBOztRQUVEcEosSUFBSSxDQUFDM2lCLEdBQUwsQ0FBVSxZQUFXO1VBQ3BCLElBQUlDLElBQUksR0FBRyxJQUFYOztVQUVBLE9BQVFBLElBQUksQ0FBQ3dPLFVBQUwsSUFBbUJ4TyxJQUFJLENBQUN3TyxVQUFMLENBQWdCOUwsUUFBaEIsS0FBNkIsQ0FBeEQsRUFBNEQ7WUFDM0QxQyxJQUFJLEdBQUdBLElBQUksQ0FBQ3dPLFVBQVo7VUFDQTs7VUFFRCxPQUFPeE8sSUFBUDtRQUNBLENBUkQsRUFRSTRyQixNQVJKLENBUVksSUFSWjtNQVNBOztNQUVELE9BQU8sSUFBUDtJQUNBLENBN0JnQjtJQStCakIrVixTQUFTLEVBQUUsbUJBQVV4VyxJQUFWLEVBQWlCO01BQzNCLElBQUsvc0IsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQjhwQixJQUFuQixDQUFMLEVBQWlDO1FBQ2hDLE9BQU8sS0FBS3RyQixJQUFMLENBQVcsVUFBVUksQ0FBVixFQUFjO1VBQy9CN0IsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFldWpDLFNBQWYsQ0FBMEJ4VyxJQUFJLENBQUM5ckIsSUFBTCxDQUFXLElBQVgsRUFBaUJZLENBQWpCLENBQTFCO1FBQ0EsQ0FGTSxDQUFQO01BR0E7O01BRUQsT0FBTyxLQUFLSixJQUFMLENBQVcsWUFBVztRQUM1QixJQUFJZ1csSUFBSSxHQUFHelgsTUFBTSxDQUFFLElBQUYsQ0FBakI7UUFBQSxJQUNDa1ksUUFBUSxHQUFHVCxJQUFJLENBQUNTLFFBQUwsRUFEWjs7UUFHQSxJQUFLQSxRQUFRLENBQUNuWCxNQUFkLEVBQXVCO1VBQ3RCbVgsUUFBUSxDQUFDb3JCLE9BQVQsQ0FBa0J2VyxJQUFsQjtRQUVBLENBSEQsTUFHTztVQUNOdFYsSUFBSSxDQUFDK1YsTUFBTCxDQUFhVCxJQUFiO1FBQ0E7TUFDRCxDQVZNLENBQVA7SUFXQSxDQWpEZ0I7SUFtRGpCekksSUFBSSxFQUFFLGNBQVV5SSxJQUFWLEVBQWlCO01BQ3RCLElBQUk5cEIsVUFBVSxHQUFHakQsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQjhwQixJQUFuQixDQUFqQjtNQUVBLE9BQU8sS0FBS3RyQixJQUFMLENBQVcsVUFBVUksQ0FBVixFQUFjO1FBQy9CN0IsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlc2pDLE9BQWYsQ0FBd0JyZ0MsVUFBVSxHQUFHOHBCLElBQUksQ0FBQzlyQixJQUFMLENBQVcsSUFBWCxFQUFpQlksQ0FBakIsQ0FBSCxHQUEwQmtyQixJQUE1RDtNQUNBLENBRk0sQ0FBUDtJQUdBLENBekRnQjtJQTJEakJ5VyxNQUFNLEVBQUUsa0JBQVc7TUFDbEIsT0FBTyxLQUFLLzFCLE1BQUwsR0FBY2hNLElBQWQsQ0FBb0IsWUFBVztRQUNyQyxJQUFLLENBQUN6QixNQUFNLENBQUMrRSxRQUFQLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLENBQU4sRUFBd0M7VUFDdkMvRSxNQUFNLENBQUUsSUFBRixDQUFOLENBQWU2dEIsV0FBZixDQUE0QixLQUFLempCLFVBQWpDO1FBQ0E7TUFDRCxDQUpNLEVBSUgvSCxHQUpHLEVBQVA7SUFLQTtFQWpFZ0IsQ0FBbEI7O0VBcUVBLFNBQVNvaEMsVUFBVCxDQUFxQjdoQyxJQUFyQixFQUE0QjtJQUMzQixPQUFPQSxJQUFJLENBQUNnYyxLQUFMLElBQWNoYyxJQUFJLENBQUNnYyxLQUFMLENBQVc2USxPQUF6QixJQUFvQ3p1QixNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQixTQUFsQixDQUEzQztFQUNBOztFQUVELFNBQVM4aEMsWUFBVCxDQUF1QjloQyxJQUF2QixFQUE4QjtJQUM3QixPQUFRQSxJQUFJLElBQUlBLElBQUksQ0FBQzBDLFFBQUwsS0FBa0IsQ0FBbEMsRUFBc0M7TUFDckMsSUFBS20vQixVQUFVLENBQUU3aEMsSUFBRixDQUFWLEtBQXVCLE1BQXZCLElBQWlDQSxJQUFJLENBQUNrQyxJQUFMLEtBQWMsUUFBcEQsRUFBK0Q7UUFDOUQsT0FBTyxJQUFQO01BQ0E7O01BQ0RsQyxJQUFJLEdBQUdBLElBQUksQ0FBQytKLFVBQVo7SUFDQTs7SUFDRCxPQUFPLEtBQVA7RUFDQTs7RUFFRDNMLE1BQU0sQ0FBQzBQLElBQVAsQ0FBWThELE9BQVosQ0FBb0JxZixNQUFwQixHQUE2QixVQUFVanhCLElBQVYsRUFBaUI7SUFFN0M7SUFDQTtJQUNBLE9BQU85QixPQUFPLENBQUNnd0IscUJBQVIsS0FDSmx1QixJQUFJLENBQUNtYyxXQUFMLElBQW9CLENBQXBCLElBQXlCbmMsSUFBSSxDQUFDOHVCLFlBQUwsSUFBcUIsQ0FBOUMsSUFDRCxDQUFDOXVCLElBQUksQ0FBQzZ1QixjQUFMLEdBQXNCMXZCLE1BRmxCLEdBR0wyaUMsWUFBWSxDQUFFOWhDLElBQUYsQ0FIZDtFQUlBLENBUkQ7O0VBVUE1QixNQUFNLENBQUMwUCxJQUFQLENBQVk4RCxPQUFaLENBQW9CbXdCLE9BQXBCLEdBQThCLFVBQVUvaEMsSUFBVixFQUFpQjtJQUM5QyxPQUFPLENBQUM1QixNQUFNLENBQUMwUCxJQUFQLENBQVk4RCxPQUFaLENBQW9CcWYsTUFBcEIsQ0FBNEJqeEIsSUFBNUIsQ0FBUjtFQUNBLENBRkQ7O0VBT0EsSUFBSWdpQyxHQUFHLEdBQUcsTUFBVjtFQUFBLElBQ0NDLFFBQVEsR0FBRyxPQURaO0VBQUEsSUFFQ0MsS0FBSyxHQUFHLFFBRlQ7RUFBQSxJQUdDQyxlQUFlLEdBQUcsdUNBSG5CO0VBQUEsSUFJQ0MsWUFBWSxHQUFHLG9DQUpoQjs7RUFNQSxTQUFTQyxXQUFULENBQXNCL1AsTUFBdEIsRUFBOEJyd0IsR0FBOUIsRUFBbUMrK0IsV0FBbkMsRUFBZ0RocUIsR0FBaEQsRUFBc0Q7SUFDckQsSUFBSWhXLElBQUo7O0lBRUEsSUFBSzVDLE1BQU0sQ0FBQ21ELE9BQVAsQ0FBZ0JVLEdBQWhCLENBQUwsRUFBNkI7TUFFNUI7TUFDQTdELE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYW9DLEdBQWIsRUFBa0IsVUFBVWhDLENBQVYsRUFBYXFpQyxDQUFiLEVBQWlCO1FBQ2xDLElBQUt0QixXQUFXLElBQUlpQixRQUFRLENBQUN4NEIsSUFBVCxDQUFlNm9CLE1BQWYsQ0FBcEIsRUFBOEM7VUFFN0M7VUFDQXRiLEdBQUcsQ0FBRXNiLE1BQUYsRUFBVWdRLENBQVYsQ0FBSDtRQUVBLENBTEQsTUFLTztVQUVOO1VBQ0FELFdBQVcsQ0FDVi9QLE1BQU0sR0FBRyxHQUFULElBQWlCLFFBQU9nUSxDQUFQLE1BQWEsUUFBYixJQUF5QkEsQ0FBQyxJQUFJLElBQTlCLEdBQXFDcmlDLENBQXJDLEdBQXlDLEVBQTFELElBQWlFLEdBRHZELEVBRVZxaUMsQ0FGVSxFQUdWdEIsV0FIVSxFQUlWaHFCLEdBSlUsQ0FBWDtRQU1BO01BQ0QsQ0FoQkQ7SUFrQkEsQ0FyQkQsTUFxQk8sSUFBSyxDQUFDZ3FCLFdBQUQsSUFBZ0I1aUMsTUFBTSxDQUFDOEQsSUFBUCxDQUFhRCxHQUFiLE1BQXVCLFFBQTVDLEVBQXVEO01BRTdEO01BQ0EsS0FBTWpCLElBQU4sSUFBY2lCLEdBQWQsRUFBb0I7UUFDbkJvZ0MsV0FBVyxDQUFFL1AsTUFBTSxHQUFHLEdBQVQsR0FBZXR4QixJQUFmLEdBQXNCLEdBQXhCLEVBQTZCaUIsR0FBRyxDQUFFakIsSUFBRixDQUFoQyxFQUEwQ2dnQyxXQUExQyxFQUF1RGhxQixHQUF2RCxDQUFYO01BQ0E7SUFFRCxDQVBNLE1BT0E7TUFFTjtNQUNBQSxHQUFHLENBQUVzYixNQUFGLEVBQVVyd0IsR0FBVixDQUFIO0lBQ0E7RUFDRCxDQWh6VDZFLENBa3pUOUU7RUFDQTs7O0VBQ0E3RCxNQUFNLENBQUMraUIsS0FBUCxHQUFlLFVBQVU3YSxDQUFWLEVBQWEwNkIsV0FBYixFQUEyQjtJQUN6QyxJQUFJMU8sTUFBSjtJQUFBLElBQ0NtTCxDQUFDLEdBQUcsRUFETDtJQUFBLElBRUN6bUIsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBVXZVLEdBQVYsRUFBZTJCLEtBQWYsRUFBdUI7TUFFNUI7TUFDQUEsS0FBSyxHQUFHaEcsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQitDLEtBQW5CLElBQTZCQSxLQUFLLEVBQWxDLEdBQXlDQSxLQUFLLElBQUksSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBdEU7TUFDQXE1QixDQUFDLENBQUVBLENBQUMsQ0FBQ3QrQixNQUFKLENBQUQsR0FBZ0JvakMsa0JBQWtCLENBQUU5L0IsR0FBRixDQUFsQixHQUE0QixHQUE1QixHQUFrQzgvQixrQkFBa0IsQ0FBRW4rQixLQUFGLENBQXBFO0lBQ0EsQ0FQRixDQUR5QyxDQVV6Qzs7O0lBQ0EsSUFBSzQ4QixXQUFXLEtBQUt4L0IsU0FBckIsRUFBaUM7TUFDaEN3L0IsV0FBVyxHQUFHNWlDLE1BQU0sQ0FBQ20vQixZQUFQLElBQXVCbi9CLE1BQU0sQ0FBQ20vQixZQUFQLENBQW9CeUQsV0FBekQ7SUFDQSxDQWJ3QyxDQWV6Qzs7O0lBQ0EsSUFBSzVpQyxNQUFNLENBQUNtRCxPQUFQLENBQWdCK0UsQ0FBaEIsS0FBeUJBLENBQUMsQ0FBQ3JILE1BQUYsSUFBWSxDQUFDYixNQUFNLENBQUNrRCxhQUFQLENBQXNCZ0YsQ0FBdEIsQ0FBM0MsRUFBeUU7TUFFeEU7TUFDQWxJLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYXlHLENBQWIsRUFBZ0IsWUFBVztRQUMxQjBRLEdBQUcsQ0FBRSxLQUFLaFcsSUFBUCxFQUFhLEtBQUtvRCxLQUFsQixDQUFIO01BQ0EsQ0FGRDtJQUlBLENBUEQsTUFPTztNQUVOO01BQ0E7TUFDQSxLQUFNa3VCLE1BQU4sSUFBZ0Joc0IsQ0FBaEIsRUFBb0I7UUFDbkIrN0IsV0FBVyxDQUFFL1AsTUFBRixFQUFVaHNCLENBQUMsQ0FBRWdzQixNQUFGLENBQVgsRUFBdUIwTyxXQUF2QixFQUFvQ2hxQixHQUFwQyxDQUFYO01BQ0E7SUFDRCxDQTlCd0MsQ0FnQ3pDOzs7SUFDQSxPQUFPeW1CLENBQUMsQ0FBQzV6QixJQUFGLENBQVEsR0FBUixFQUFjakksT0FBZCxDQUF1Qm9nQyxHQUF2QixFQUE0QixHQUE1QixDQUFQO0VBQ0EsQ0FsQ0Q7O0VBb0NBNWpDLE1BQU0sQ0FBQ0csRUFBUCxDQUFVcUMsTUFBVixDQUFrQjtJQUNqQjRoQyxTQUFTLEVBQUUscUJBQVc7TUFDckIsT0FBT3BrQyxNQUFNLENBQUMraUIsS0FBUCxDQUFjLEtBQUtzaEIsY0FBTCxFQUFkLENBQVA7SUFDQSxDQUhnQjtJQUlqQkEsY0FBYyxFQUFFLDBCQUFXO01BQzFCLE9BQU8sS0FBSzFpQyxHQUFMLENBQVUsWUFBVztRQUUzQjtRQUNBLElBQUlnTyxRQUFRLEdBQUczUCxNQUFNLENBQUN3Z0IsSUFBUCxDQUFhLElBQWIsRUFBbUIsVUFBbkIsQ0FBZjtRQUNBLE9BQU83USxRQUFRLEdBQUczUCxNQUFNLENBQUNtRixTQUFQLENBQWtCd0ssUUFBbEIsQ0FBSCxHQUFrQyxJQUFqRDtNQUNBLENBTE0sRUFNTnRCLE1BTk0sQ0FNRSxZQUFXO1FBQ25CLElBQUl2SyxJQUFJLEdBQUcsS0FBS0EsSUFBaEIsQ0FEbUIsQ0FHbkI7O1FBQ0EsT0FBTyxLQUFLbEIsSUFBTCxJQUFhLENBQUM1QyxNQUFNLENBQUUsSUFBRixDQUFOLENBQWUrVyxFQUFmLENBQW1CLFdBQW5CLENBQWQsSUFDTml0QixZQUFZLENBQUMzNEIsSUFBYixDQUFtQixLQUFLdEcsUUFBeEIsQ0FETSxJQUNnQyxDQUFDZy9CLGVBQWUsQ0FBQzE0QixJQUFoQixDQUFzQnZILElBQXRCLENBRGpDLEtBRUosS0FBS2dQLE9BQUwsSUFBZ0IsQ0FBQzBPLGNBQWMsQ0FBQ25XLElBQWYsQ0FBcUJ2SCxJQUFyQixDQUZiLENBQVA7TUFHQSxDQWJNLEVBY05uQyxHQWRNLENBY0QsVUFBVUUsQ0FBVixFQUFhRCxJQUFiLEVBQW9CO1FBQ3pCLElBQUlpTyxHQUFHLEdBQUc3UCxNQUFNLENBQUUsSUFBRixDQUFOLENBQWU2UCxHQUFmLEVBQVY7UUFFQSxPQUFPQSxHQUFHLElBQUksSUFBUCxHQUNOLElBRE0sR0FFTjdQLE1BQU0sQ0FBQ21ELE9BQVAsQ0FBZ0IwTSxHQUFoQixJQUNDN1AsTUFBTSxDQUFDMkIsR0FBUCxDQUFZa08sR0FBWixFQUFpQixVQUFVQSxHQUFWLEVBQWdCO1VBQ2hDLE9BQU87WUFBRWpOLElBQUksRUFBRWhCLElBQUksQ0FBQ2dCLElBQWI7WUFBbUJvRCxLQUFLLEVBQUU2SixHQUFHLENBQUNyTSxPQUFKLENBQWFzZ0MsS0FBYixFQUFvQixNQUFwQjtVQUExQixDQUFQO1FBQ0EsQ0FGRCxDQURELEdBSUM7VUFBRWxoQyxJQUFJLEVBQUVoQixJQUFJLENBQUNnQixJQUFiO1VBQW1Cb0QsS0FBSyxFQUFFNkosR0FBRyxDQUFDck0sT0FBSixDQUFhc2dDLEtBQWIsRUFBb0IsTUFBcEI7UUFBMUIsQ0FORjtNQU9BLENBeEJNLEVBd0JINWlDLEdBeEJHLEVBQVA7SUF5QkE7RUE5QmdCLENBQWxCLEVBeDFUOEUsQ0EwM1Q5RTtFQUNBOztFQUNBbEIsTUFBTSxDQUFDbS9CLFlBQVAsQ0FBb0JtRixHQUFwQixHQUEwQm5sQyxNQUFNLENBQUNvK0IsYUFBUCxLQUF5Qm42QixTQUF6QixHQUV6QjtFQUNBLFlBQVc7SUFFVjtJQUNBLElBQUssS0FBS3E5QixPQUFWLEVBQW9CO01BQ25CLE9BQU84RCxlQUFlLEVBQXRCO0lBQ0EsQ0FMUyxDQU9WO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTs7O0lBQ0EsSUFBS3ZsQyxRQUFRLENBQUN3bEMsWUFBVCxHQUF3QixDQUE3QixFQUFpQztNQUNoQyxPQUFPQyxpQkFBaUIsRUFBeEI7SUFDQSxDQWZTLENBaUJWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTs7O0lBQ0EsT0FBTyx3Q0FBd0NwNUIsSUFBeEMsQ0FBOEMsS0FBS3ZILElBQW5ELEtBQ04yZ0MsaUJBQWlCLEVBRFgsSUFDaUJGLGVBQWUsRUFEdkM7RUFFQSxDQTVCd0IsR0E4QnpCO0VBQ0FFLGlCQS9CRDtFQWlDQSxJQUFJQyxLQUFLLEdBQUcsQ0FBWjtFQUFBLElBQ0NDLFlBQVksR0FBRyxFQURoQjtFQUFBLElBRUNDLFlBQVksR0FBRzVrQyxNQUFNLENBQUNtL0IsWUFBUCxDQUFvQm1GLEdBQXBCLEVBRmhCLENBNzVUOEUsQ0FpNlQ5RTtFQUNBO0VBQ0E7O0VBQ0EsSUFBS25sQyxNQUFNLENBQUMyTyxXQUFaLEVBQTBCO0lBQ3pCM08sTUFBTSxDQUFDMk8sV0FBUCxDQUFvQixVQUFwQixFQUFnQyxZQUFXO01BQzFDLEtBQU0sSUFBSXpKLEdBQVYsSUFBaUJzZ0MsWUFBakIsRUFBZ0M7UUFDL0JBLFlBQVksQ0FBRXRnQyxHQUFGLENBQVosQ0FBcUJqQixTQUFyQixFQUFnQyxJQUFoQztNQUNBO0lBQ0QsQ0FKRDtFQUtBLENBMTZUNkUsQ0E0NlQ5RTs7O0VBQ0F0RCxPQUFPLENBQUMra0MsSUFBUixHQUFlLENBQUMsQ0FBQ0QsWUFBRixJQUFvQixxQkFBcUJBLFlBQXhEO0VBQ0FBLFlBQVksR0FBRzlrQyxPQUFPLENBQUNvaEMsSUFBUixHQUFlLENBQUMsQ0FBQzBELFlBQWhDLENBOTZUOEUsQ0FnN1Q5RTs7RUFDQSxJQUFLQSxZQUFMLEVBQW9CO0lBRW5CNWtDLE1BQU0sQ0FBQ2loQyxhQUFQLENBQXNCLFVBQVVwK0IsT0FBVixFQUFvQjtNQUV6QztNQUNBLElBQUssQ0FBQ0EsT0FBTyxDQUFDOC9CLFdBQVQsSUFBd0I3aUMsT0FBTyxDQUFDK2tDLElBQXJDLEVBQTRDO1FBRTNDLElBQUluakMsU0FBSjs7UUFFQSxPQUFPO1VBQ051aEMsSUFBSSxFQUFFLGNBQVVGLE9BQVYsRUFBbUJwTCxRQUFuQixFQUE4QjtZQUNuQyxJQUFJOTFCLENBQUo7WUFBQSxJQUNDeWlDLEdBQUcsR0FBR3poQyxPQUFPLENBQUN5aEMsR0FBUixFQURQO1lBQUEsSUFFQ3I1QixFQUFFLEdBQUcsRUFBRXk1QixLQUZSLENBRG1DLENBS25DOztZQUNBSixHQUFHLENBQUNwSCxJQUFKLENBQ0NyNkIsT0FBTyxDQUFDaUIsSUFEVCxFQUVDakIsT0FBTyxDQUFDMjlCLEdBRlQsRUFHQzM5QixPQUFPLENBQUMyNkIsS0FIVCxFQUlDMzZCLE9BQU8sQ0FBQ2lpQyxRQUpULEVBS0NqaUMsT0FBTyxDQUFDdVEsUUFMVCxFQU5tQyxDQWNuQzs7WUFDQSxJQUFLdlEsT0FBTyxDQUFDa2lDLFNBQWIsRUFBeUI7Y0FDeEIsS0FBTWxqQyxDQUFOLElBQVdnQixPQUFPLENBQUNraUMsU0FBbkIsRUFBK0I7Z0JBQzlCVCxHQUFHLENBQUV6aUMsQ0FBRixDQUFILEdBQVdnQixPQUFPLENBQUNraUMsU0FBUixDQUFtQmxqQyxDQUFuQixDQUFYO2NBQ0E7WUFDRCxDQW5Ca0MsQ0FxQm5DOzs7WUFDQSxJQUFLZ0IsT0FBTyxDQUFDNjhCLFFBQVIsSUFBb0I0RSxHQUFHLENBQUNuQyxnQkFBN0IsRUFBZ0Q7Y0FDL0NtQyxHQUFHLENBQUNuQyxnQkFBSixDQUFzQnQvQixPQUFPLENBQUM2OEIsUUFBOUI7WUFDQSxDQXhCa0MsQ0EwQm5DO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7OztZQUNBLElBQUssQ0FBQzc4QixPQUFPLENBQUM4L0IsV0FBVCxJQUF3QixDQUFDSSxPQUFPLENBQUUsa0JBQUYsQ0FBckMsRUFBOEQ7Y0FDN0RBLE9BQU8sQ0FBRSxrQkFBRixDQUFQLEdBQWdDLGdCQUFoQztZQUNBLENBakNrQyxDQW1DbkM7OztZQUNBLEtBQU1saEMsQ0FBTixJQUFXa2hDLE9BQVgsRUFBcUI7Y0FFcEI7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtjQUNBO2NBQ0EsSUFBS0EsT0FBTyxDQUFFbGhDLENBQUYsQ0FBUCxLQUFpQnVCLFNBQXRCLEVBQWtDO2dCQUNqQ2toQyxHQUFHLENBQUNyQyxnQkFBSixDQUFzQnBnQyxDQUF0QixFQUF5QmtoQyxPQUFPLENBQUVsaEMsQ0FBRixDQUFQLEdBQWUsRUFBeEM7Y0FDQTtZQUNELENBL0NrQyxDQWlEbkM7WUFDQTtZQUNBOzs7WUFDQXlpQyxHQUFHLENBQUNyQixJQUFKLENBQVlwZ0MsT0FBTyxDQUFDZ2dDLFVBQVIsSUFBc0JoZ0MsT0FBTyxDQUFDNkIsSUFBaEMsSUFBMEMsSUFBcEQsRUFwRG1DLENBc0RuQzs7WUFDQWhELFNBQVEsR0FBRyxrQkFBVW1JLENBQVYsRUFBYW03QixPQUFiLEVBQXVCO2NBQ2pDLElBQUkzQyxNQUFKLEVBQVlFLFVBQVosRUFBd0JqRCxTQUF4QixDQURpQyxDQUdqQzs7Y0FDQSxJQUFLNTlCLFNBQVEsS0FBTXNqQyxPQUFPLElBQUlWLEdBQUcsQ0FBQ2xuQixVQUFKLEtBQW1CLENBQXBDLENBQWIsRUFBdUQ7Z0JBRXREO2dCQUNBLE9BQU91bkIsWUFBWSxDQUFFMTVCLEVBQUYsQ0FBbkI7Z0JBQ0F2SixTQUFRLEdBQUcwQixTQUFYO2dCQUNBa2hDLEdBQUcsQ0FBQ1csa0JBQUosR0FBeUJqbEMsTUFBTSxDQUFDNEQsSUFBaEMsQ0FMc0QsQ0FPdEQ7O2dCQUNBLElBQUtvaEMsT0FBTCxFQUFlO2tCQUNkLElBQUtWLEdBQUcsQ0FBQ2xuQixVQUFKLEtBQW1CLENBQXhCLEVBQTRCO29CQUMzQmtuQixHQUFHLENBQUNoQyxLQUFKO2tCQUNBO2dCQUNELENBSkQsTUFJTztrQkFDTmhELFNBQVMsR0FBRyxFQUFaO2tCQUNBK0MsTUFBTSxHQUFHaUMsR0FBRyxDQUFDakMsTUFBYixDQUZNLENBSU47a0JBQ0E7a0JBQ0E7O2tCQUNBLElBQUssT0FBT2lDLEdBQUcsQ0FBQ1ksWUFBWCxLQUE0QixRQUFqQyxFQUE0QztvQkFDM0M1RixTQUFTLENBQUNwNkIsSUFBVixHQUFpQm8vQixHQUFHLENBQUNZLFlBQXJCO2tCQUNBLENBVEssQ0FXTjtrQkFDQTs7O2tCQUNBLElBQUk7b0JBQ0gzQyxVQUFVLEdBQUcrQixHQUFHLENBQUMvQixVQUFqQjtrQkFDQSxDQUZELENBRUUsT0FBUWgrQixDQUFSLEVBQVk7b0JBRWI7b0JBQ0FnK0IsVUFBVSxHQUFHLEVBQWI7a0JBQ0EsQ0FuQkssQ0FxQk47a0JBRUE7a0JBQ0E7a0JBQ0E7OztrQkFDQSxJQUFLLENBQUNGLE1BQUQsSUFBV3gvQixPQUFPLENBQUM0OUIsT0FBbkIsSUFBOEIsQ0FBQzU5QixPQUFPLENBQUM4L0IsV0FBNUMsRUFBMEQ7b0JBQ3pETixNQUFNLEdBQUcvQyxTQUFTLENBQUNwNkIsSUFBVixHQUFpQixHQUFqQixHQUF1QixHQUFoQyxDQUR5RCxDQUcxRDtrQkFDQyxDQUpELE1BSU8sSUFBS205QixNQUFNLEtBQUssSUFBaEIsRUFBdUI7b0JBQzdCQSxNQUFNLEdBQUcsR0FBVDtrQkFDQTtnQkFDRDtjQUNELENBbERnQyxDQW9EakM7OztjQUNBLElBQUsvQyxTQUFMLEVBQWlCO2dCQUNoQjNILFFBQVEsQ0FBRTBLLE1BQUYsRUFBVUUsVUFBVixFQUFzQmpELFNBQXRCLEVBQWlDZ0YsR0FBRyxDQUFDdEMscUJBQUosRUFBakMsQ0FBUjtjQUNBO1lBQ0QsQ0F4REQsQ0F2RG1DLENBaUhuQztZQUNBO1lBQ0E7OztZQUNBLElBQUssQ0FBQ24vQixPQUFPLENBQUMyNkIsS0FBZCxFQUFzQjtjQUVyQjtjQUNBOTdCLFNBQVE7WUFDUixDQUpELE1BSU8sSUFBSzRpQyxHQUFHLENBQUNsbkIsVUFBSixLQUFtQixDQUF4QixFQUE0QjtjQUVsQztjQUNBO2NBQ0FqZSxNQUFNLENBQUNtZSxVQUFQLENBQW1CNWIsU0FBbkI7WUFDQSxDQUxNLE1BS0E7Y0FFTjtjQUNBO2NBQ0E0aUMsR0FBRyxDQUFDVyxrQkFBSixHQUF5Qk4sWUFBWSxDQUFFMTVCLEVBQUYsQ0FBWixHQUFxQnZKLFNBQTlDO1lBQ0E7VUFDRCxDQXBJSztVQXNJTjRnQyxLQUFLLEVBQUUsaUJBQVc7WUFDakIsSUFBSzVnQyxTQUFMLEVBQWdCO2NBQ2ZBLFNBQVEsQ0FBRTBCLFNBQUYsRUFBYSxJQUFiLENBQVI7WUFDQTtVQUNEO1FBMUlLLENBQVA7TUE0SUE7SUFDRCxDQXBKRDtFQXFKQSxDQXhrVTZFLENBMGtVOUU7OztFQUNBLFNBQVNxaEMsaUJBQVQsR0FBNkI7SUFDNUIsSUFBSTtNQUNILE9BQU8sSUFBSXRsQyxNQUFNLENBQUNnbUMsY0FBWCxFQUFQO0lBQ0EsQ0FGRCxDQUVFLE9BQVE1Z0MsQ0FBUixFQUFZLENBQUU7RUFDaEI7O0VBRUQsU0FBU2dnQyxlQUFULEdBQTJCO0lBQzFCLElBQUk7TUFDSCxPQUFPLElBQUlwbEMsTUFBTSxDQUFDbytCLGFBQVgsQ0FBMEIsbUJBQTFCLENBQVA7SUFDQSxDQUZELENBRUUsT0FBUWg1QixDQUFSLEVBQVksQ0FBRTtFQUNoQixDQXJsVTZFLENBMGxVOUU7OztFQUNBdkUsTUFBTSxDQUFDOGdDLFNBQVAsQ0FBa0I7SUFDakJGLE9BQU8sRUFBRTtNQUNSd0UsTUFBTSxFQUFFLDhDQUNQO0lBRk8sQ0FEUTtJQUtqQmx0QixRQUFRLEVBQUU7TUFDVGt0QixNQUFNLEVBQUU7SUFEQyxDQUxPO0lBUWpCeEYsVUFBVSxFQUFFO01BQ1gsZUFBZSxvQkFBVTE2QixJQUFWLEVBQWlCO1FBQy9CbEYsTUFBTSxDQUFDeUUsVUFBUCxDQUFtQlMsSUFBbkI7UUFDQSxPQUFPQSxJQUFQO01BQ0E7SUFKVTtFQVJLLENBQWxCLEVBM2xVOEUsQ0EybVU5RTs7RUFDQWxGLE1BQU0sQ0FBQ2doQyxhQUFQLENBQXNCLFFBQXRCLEVBQWdDLFVBQVUzQixDQUFWLEVBQWM7SUFDN0MsSUFBS0EsQ0FBQyxDQUFDcnpCLEtBQUYsS0FBWTVJLFNBQWpCLEVBQTZCO01BQzVCaThCLENBQUMsQ0FBQ3J6QixLQUFGLEdBQVUsS0FBVjtJQUNBOztJQUNELElBQUtxekIsQ0FBQyxDQUFDc0QsV0FBUCxFQUFxQjtNQUNwQnRELENBQUMsQ0FBQ3Y3QixJQUFGLEdBQVMsS0FBVDtNQUNBdTdCLENBQUMsQ0FBQ3pnQyxNQUFGLEdBQVcsS0FBWDtJQUNBO0VBQ0QsQ0FSRCxFQTVtVThFLENBc25VOUU7O0VBQ0FvQixNQUFNLENBQUNpaEMsYUFBUCxDQUFzQixRQUF0QixFQUFnQyxVQUFVNUIsQ0FBVixFQUFjO0lBRTdDO0lBQ0EsSUFBS0EsQ0FBQyxDQUFDc0QsV0FBUCxFQUFxQjtNQUVwQixJQUFJeUMsTUFBSjtNQUFBLElBQ0NDLElBQUksR0FBR3JtQyxRQUFRLENBQUNxbUMsSUFBVCxJQUFpQnJsQyxNQUFNLENBQUUsTUFBRixDQUFOLENBQWtCLENBQWxCLENBQWpCLElBQTBDaEIsUUFBUSxDQUFDc08sZUFEM0Q7TUFHQSxPQUFPO1FBRU4yMUIsSUFBSSxFQUFFLGNBQVVwNUIsQ0FBVixFQUFhbkksUUFBYixFQUF3QjtVQUU3QjBqQyxNQUFNLEdBQUdwbUMsUUFBUSxDQUFDc04sYUFBVCxDQUF3QixRQUF4QixDQUFUO1VBRUE4NEIsTUFBTSxDQUFDNUgsS0FBUCxHQUFlLElBQWY7O1VBRUEsSUFBSzZCLENBQUMsQ0FBQ2lHLGFBQVAsRUFBdUI7WUFDdEJGLE1BQU0sQ0FBQ0csT0FBUCxHQUFpQmxHLENBQUMsQ0FBQ2lHLGFBQW5CO1VBQ0E7O1VBRURGLE1BQU0sQ0FBQzNpQyxHQUFQLEdBQWE0OEIsQ0FBQyxDQUFDbUIsR0FBZixDQVY2QixDQVk3Qjs7VUFDQTRFLE1BQU0sQ0FBQ0ksTUFBUCxHQUFnQkosTUFBTSxDQUFDSCxrQkFBUCxHQUE0QixVQUFVcDdCLENBQVYsRUFBYW03QixPQUFiLEVBQXVCO1lBRWxFLElBQUtBLE9BQU8sSUFBSSxDQUFDSSxNQUFNLENBQUNob0IsVUFBbkIsSUFBaUMsa0JBQWtCL1IsSUFBbEIsQ0FBd0IrNUIsTUFBTSxDQUFDaG9CLFVBQS9CLENBQXRDLEVBQW9GO2NBRW5GO2NBQ0Fnb0IsTUFBTSxDQUFDSSxNQUFQLEdBQWdCSixNQUFNLENBQUNILGtCQUFQLEdBQTRCLElBQTVDLENBSG1GLENBS25GOztjQUNBLElBQUtHLE1BQU0sQ0FBQ3o1QixVQUFaLEVBQXlCO2dCQUN4Qnk1QixNQUFNLENBQUN6NUIsVUFBUCxDQUFrQlksV0FBbEIsQ0FBK0I2NEIsTUFBL0I7Y0FDQSxDQVJrRixDQVVuRjs7O2NBQ0FBLE1BQU0sR0FBRyxJQUFULENBWG1GLENBYW5GOztjQUNBLElBQUssQ0FBQ0osT0FBTixFQUFnQjtnQkFDZnRqQyxRQUFRLENBQUUsR0FBRixFQUFPLFNBQVAsQ0FBUjtjQUNBO1lBQ0Q7VUFDRCxDQXBCRCxDQWI2QixDQW1DN0I7VUFDQTs7O1VBQ0EyakMsSUFBSSxDQUFDM1gsWUFBTCxDQUFtQjBYLE1BQW5CLEVBQTJCQyxJQUFJLENBQUNqMUIsVUFBaEM7UUFDQSxDQXhDSztRQTBDTmt5QixLQUFLLEVBQUUsaUJBQVc7VUFDakIsSUFBSzhDLE1BQUwsRUFBYztZQUNiQSxNQUFNLENBQUNJLE1BQVAsQ0FBZXBpQyxTQUFmLEVBQTBCLElBQTFCO1VBQ0E7UUFDRDtNQTlDSyxDQUFQO0lBZ0RBO0VBQ0QsQ0F6REQ7RUE4REEsSUFBSXFpQyxZQUFZLEdBQUcsRUFBbkI7RUFBQSxJQUNDQyxNQUFNLEdBQUcsbUJBRFYsQ0FyclU4RSxDQXdyVTlFOztFQUNBMWxDLE1BQU0sQ0FBQzhnQyxTQUFQLENBQWtCO0lBQ2pCNkUsS0FBSyxFQUFFLFVBRFU7SUFFakJDLGFBQWEsRUFBRSx5QkFBVztNQUN6QixJQUFJbGtDLFFBQVEsR0FBRytqQyxZQUFZLENBQUNwOUIsR0FBYixNQUF3QnJJLE1BQU0sQ0FBQ3FELE9BQVAsR0FBaUIsR0FBakIsR0FBeUJvNUIsS0FBSyxFQUFyRTtNQUNBLEtBQU0vNkIsUUFBTixJQUFtQixJQUFuQjtNQUNBLE9BQU9BLFFBQVA7SUFDQTtFQU5nQixDQUFsQixFQXpyVThFLENBa3NVOUU7O0VBQ0ExQixNQUFNLENBQUNnaEMsYUFBUCxDQUFzQixZQUF0QixFQUFvQyxVQUFVM0IsQ0FBVixFQUFhd0csZ0JBQWIsRUFBK0JsSCxLQUEvQixFQUF1QztJQUUxRSxJQUFJbUgsWUFBSjtJQUFBLElBQWtCQyxXQUFsQjtJQUFBLElBQStCQyxpQkFBL0I7SUFBQSxJQUNDQyxRQUFRLEdBQUc1RyxDQUFDLENBQUNzRyxLQUFGLEtBQVksS0FBWixLQUF1QkQsTUFBTSxDQUFDcjZCLElBQVAsQ0FBYWcwQixDQUFDLENBQUNtQixHQUFmLElBQ2pDLEtBRGlDLEdBRWpDLE9BQU9uQixDQUFDLENBQUMzNkIsSUFBVCxLQUFrQixRQUFsQixJQUNDLENBQUUyNkIsQ0FBQyxDQUFDc0IsV0FBRixJQUFpQixFQUFuQixFQUNFbGhDLE9BREYsQ0FDVyxtQ0FEWCxNQUNxRCxDQUZ0RCxJQUdDaW1DLE1BQU0sQ0FBQ3I2QixJQUFQLENBQWFnMEIsQ0FBQyxDQUFDMzZCLElBQWYsQ0FIRCxJQUcwQixNQUxoQixDQURaLENBRjBFLENBVzFFOztJQUNBLElBQUt1aEMsUUFBUSxJQUFJNUcsQ0FBQyxDQUFDWixTQUFGLENBQWEsQ0FBYixNQUFxQixPQUF0QyxFQUFnRDtNQUUvQztNQUNBcUgsWUFBWSxHQUFHekcsQ0FBQyxDQUFDdUcsYUFBRixHQUFrQjVsQyxNQUFNLENBQUNpRCxVQUFQLENBQW1CbzhCLENBQUMsQ0FBQ3VHLGFBQXJCLElBQ2hDdkcsQ0FBQyxDQUFDdUcsYUFBRixFQURnQyxHQUVoQ3ZHLENBQUMsQ0FBQ3VHLGFBRkgsQ0FIK0MsQ0FPL0M7O01BQ0EsSUFBS0ssUUFBTCxFQUFnQjtRQUNmNUcsQ0FBQyxDQUFFNEcsUUFBRixDQUFELEdBQWdCNUcsQ0FBQyxDQUFFNEcsUUFBRixDQUFELENBQWN6aUMsT0FBZCxDQUF1QmtpQyxNQUF2QixFQUErQixPQUFPSSxZQUF0QyxDQUFoQjtNQUNBLENBRkQsTUFFTyxJQUFLekcsQ0FBQyxDQUFDc0csS0FBRixLQUFZLEtBQWpCLEVBQXlCO1FBQy9CdEcsQ0FBQyxDQUFDbUIsR0FBRixJQUFTLENBQUU5RCxNQUFNLENBQUNyeEIsSUFBUCxDQUFhZzBCLENBQUMsQ0FBQ21CLEdBQWYsSUFBdUIsR0FBdkIsR0FBNkIsR0FBL0IsSUFBdUNuQixDQUFDLENBQUNzRyxLQUF6QyxHQUFpRCxHQUFqRCxHQUF1REcsWUFBaEU7TUFDQSxDQVo4QyxDQWMvQzs7O01BQ0F6RyxDQUFDLENBQUNPLFVBQUYsQ0FBYyxhQUFkLElBQWdDLFlBQVc7UUFDMUMsSUFBSyxDQUFDb0csaUJBQU4sRUFBMEI7VUFDekJobUMsTUFBTSxDQUFDMEQsS0FBUCxDQUFjb2lDLFlBQVksR0FBRyxpQkFBN0I7UUFDQTs7UUFDRCxPQUFPRSxpQkFBaUIsQ0FBRSxDQUFGLENBQXhCO01BQ0EsQ0FMRCxDQWYrQyxDQXNCL0M7OztNQUNBM0csQ0FBQyxDQUFDWixTQUFGLENBQWEsQ0FBYixJQUFtQixNQUFuQixDQXZCK0MsQ0F5Qi9DOztNQUNBc0gsV0FBVyxHQUFHNW1DLE1BQU0sQ0FBRTJtQyxZQUFGLENBQXBCOztNQUNBM21DLE1BQU0sQ0FBRTJtQyxZQUFGLENBQU4sR0FBeUIsWUFBVztRQUNuQ0UsaUJBQWlCLEdBQUdqa0MsU0FBcEI7TUFDQSxDQUZELENBM0IrQyxDQStCL0M7OztNQUNBNDhCLEtBQUssQ0FBQzVqQixNQUFOLENBQWMsWUFBVztRQUV4QjtRQUNBLElBQUtnckIsV0FBVyxLQUFLM2lDLFNBQXJCLEVBQWlDO1VBQ2hDcEQsTUFBTSxDQUFFYixNQUFGLENBQU4sQ0FBaUJvOEIsVUFBakIsQ0FBNkJ1SyxZQUE3QixFQURnQyxDQUdqQztRQUNDLENBSkQsTUFJTztVQUNOM21DLE1BQU0sQ0FBRTJtQyxZQUFGLENBQU4sR0FBeUJDLFdBQXpCO1FBQ0EsQ0FUdUIsQ0FXeEI7OztRQUNBLElBQUsxRyxDQUFDLENBQUV5RyxZQUFGLENBQU4sRUFBeUI7VUFFeEI7VUFDQXpHLENBQUMsQ0FBQ3VHLGFBQUYsR0FBa0JDLGdCQUFnQixDQUFDRCxhQUFuQyxDQUh3QixDQUt4Qjs7VUFDQUgsWUFBWSxDQUFDam1DLElBQWIsQ0FBbUJzbUMsWUFBbkI7UUFDQSxDQW5CdUIsQ0FxQnhCOzs7UUFDQSxJQUFLRSxpQkFBaUIsSUFBSWhtQyxNQUFNLENBQUNpRCxVQUFQLENBQW1COGlDLFdBQW5CLENBQTFCLEVBQTZEO1VBQzVEQSxXQUFXLENBQUVDLGlCQUFpQixDQUFFLENBQUYsQ0FBbkIsQ0FBWDtRQUNBOztRQUVEQSxpQkFBaUIsR0FBR0QsV0FBVyxHQUFHM2lDLFNBQWxDO01BQ0EsQ0EzQkQsRUFoQytDLENBNkQvQzs7TUFDQSxPQUFPLFFBQVA7SUFDQTtFQUNELENBNUVELEVBbnNVOEUsQ0FveFU5RTtFQUNBO0VBQ0E7RUFDQTs7RUFDQXBELE1BQU0sQ0FBQzZYLFNBQVAsR0FBbUIsVUFBVW5ULElBQVYsRUFBZ0J4RSxPQUFoQixFQUF5QmdtQyxXQUF6QixFQUF1QztJQUN6RCxJQUFLLENBQUN4aEMsSUFBRCxJQUFTLE9BQU9BLElBQVAsS0FBZ0IsUUFBOUIsRUFBeUM7TUFDeEMsT0FBTyxJQUFQO0lBQ0E7O0lBQ0QsSUFBSyxPQUFPeEUsT0FBUCxLQUFtQixTQUF4QixFQUFvQztNQUNuQ2dtQyxXQUFXLEdBQUdobUMsT0FBZDtNQUNBQSxPQUFPLEdBQUcsS0FBVjtJQUNBOztJQUNEQSxPQUFPLEdBQUdBLE9BQU8sSUFBSWxCLFFBQXJCO0lBRUEsSUFBSW1uQyxNQUFNLEdBQUcvdUIsVUFBVSxDQUFDck0sSUFBWCxDQUFpQnJHLElBQWpCLENBQWI7SUFBQSxJQUNDeWYsT0FBTyxHQUFHLENBQUMraEIsV0FBRCxJQUFnQixFQUQzQixDQVZ5RCxDQWF6RDs7SUFDQSxJQUFLQyxNQUFMLEVBQWM7TUFDYixPQUFPLENBQUVqbUMsT0FBTyxDQUFDb00sYUFBUixDQUF1QjY1QixNQUFNLENBQUUsQ0FBRixDQUE3QixDQUFGLENBQVA7SUFDQTs7SUFFREEsTUFBTSxHQUFHamlCLGFBQWEsQ0FBRSxDQUFFeGYsSUFBRixDQUFGLEVBQVl4RSxPQUFaLEVBQXFCaWtCLE9BQXJCLENBQXRCOztJQUVBLElBQUtBLE9BQU8sSUFBSUEsT0FBTyxDQUFDcGpCLE1BQXhCLEVBQWlDO01BQ2hDZixNQUFNLENBQUVta0IsT0FBRixDQUFOLENBQWtCOUosTUFBbEI7SUFDQTs7SUFFRCxPQUFPcmEsTUFBTSxDQUFDdUIsS0FBUCxDQUFjLEVBQWQsRUFBa0I0a0MsTUFBTSxDQUFDLzdCLFVBQXpCLENBQVA7RUFDQSxDQXpCRCxDQXh4VThFLENBb3pVOUU7OztFQUNBLElBQUlnOEIsS0FBSyxHQUFHcG1DLE1BQU0sQ0FBQ0csRUFBUCxDQUFVOHBCLElBQXRCO0VBRUE7QUFDQTtBQUNBOztFQUNBanFCLE1BQU0sQ0FBQ0csRUFBUCxDQUFVOHBCLElBQVYsR0FBaUIsVUFBVXVXLEdBQVYsRUFBZTZGLE1BQWYsRUFBdUIza0MsUUFBdkIsRUFBa0M7SUFDbEQsSUFBSyxPQUFPOCtCLEdBQVAsS0FBZSxRQUFmLElBQTJCNEYsS0FBaEMsRUFBd0M7TUFDdkMsT0FBT0EsS0FBSyxDQUFDdGtDLEtBQU4sQ0FBYSxJQUFiLEVBQW1CQyxTQUFuQixDQUFQO0lBQ0E7O0lBRUQsSUFBSTlCLFFBQUo7SUFBQSxJQUFjNkQsSUFBZDtJQUFBLElBQW9CZzhCLFFBQXBCO0lBQUEsSUFDQ3JvQixJQUFJLEdBQUcsSUFEUjtJQUFBLElBRUNxRixHQUFHLEdBQUcwakIsR0FBRyxDQUFDL2dDLE9BQUosQ0FBYSxHQUFiLENBRlA7O0lBSUEsSUFBS3FkLEdBQUcsR0FBRyxDQUFDLENBQVosRUFBZ0I7TUFDZjdjLFFBQVEsR0FBR0QsTUFBTSxDQUFDMkUsSUFBUCxDQUFhNjdCLEdBQUcsQ0FBQ2xoQyxLQUFKLENBQVd3ZCxHQUFYLEVBQWdCMGpCLEdBQUcsQ0FBQ3ovQixNQUFwQixDQUFiLENBQVg7TUFDQXkvQixHQUFHLEdBQUdBLEdBQUcsQ0FBQ2xoQyxLQUFKLENBQVcsQ0FBWCxFQUFjd2QsR0FBZCxDQUFOO0lBQ0EsQ0FaaUQsQ0FjbEQ7OztJQUNBLElBQUs5YyxNQUFNLENBQUNpRCxVQUFQLENBQW1Cb2pDLE1BQW5CLENBQUwsRUFBbUM7TUFFbEM7TUFDQTNrQyxRQUFRLEdBQUcya0MsTUFBWDtNQUNBQSxNQUFNLEdBQUdqakMsU0FBVCxDQUprQyxDQU1uQztJQUNDLENBUEQsTUFPTyxJQUFLaWpDLE1BQU0sSUFBSSxRQUFPQSxNQUFQLE1BQWtCLFFBQWpDLEVBQTRDO01BQ2xEdmlDLElBQUksR0FBRyxNQUFQO0lBQ0EsQ0F4QmlELENBMEJsRDs7O0lBQ0EsSUFBSzJULElBQUksQ0FBQzFXLE1BQUwsR0FBYyxDQUFuQixFQUF1QjtNQUN0QmYsTUFBTSxDQUFDa2hDLElBQVAsQ0FBYTtRQUNaVixHQUFHLEVBQUVBLEdBRE87UUFHWjtRQUNBO1FBQ0E7UUFDQTE4QixJQUFJLEVBQUVBLElBQUksSUFBSSxLQU5GO1FBT1owNkIsUUFBUSxFQUFFLE1BUEU7UUFRWjk1QixJQUFJLEVBQUUyaEM7TUFSTSxDQUFiLEVBU0l6K0IsSUFUSixDQVNVLFVBQVVzOUIsWUFBVixFQUF5QjtRQUVsQztRQUNBcEYsUUFBUSxHQUFHLzlCLFNBQVg7UUFFQTBWLElBQUksQ0FBQ3NWLElBQUwsQ0FBVzlzQixRQUFRLEdBRWxCO1FBQ0E7UUFDQUQsTUFBTSxDQUFFLE9BQUYsQ0FBTixDQUFrQnd0QixNQUFsQixDQUEwQnh0QixNQUFNLENBQUM2WCxTQUFQLENBQWtCcXRCLFlBQWxCLENBQTFCLEVBQTZEOTJCLElBQTdELENBQW1Fbk8sUUFBbkUsQ0FKa0IsR0FNbEI7UUFDQWlsQyxZQVBELEVBTGtDLENBY25DO1FBQ0E7UUFDQTtNQUNDLENBMUJELEVBMEJJbnFCLE1BMUJKLENBMEJZclosUUFBUSxJQUFJLFVBQVVpOUIsS0FBVixFQUFpQjBELE1BQWpCLEVBQTBCO1FBQ2pENXFCLElBQUksQ0FBQ2hXLElBQUwsQ0FBVyxZQUFXO1VBQ3JCQyxRQUFRLENBQUNJLEtBQVQsQ0FBZ0IsSUFBaEIsRUFBc0JnK0IsUUFBUSxJQUFJLENBQUVuQixLQUFLLENBQUN1RyxZQUFSLEVBQXNCN0MsTUFBdEIsRUFBOEIxRCxLQUE5QixDQUFsQztRQUNBLENBRkQ7TUFHQSxDQTlCRDtJQStCQTs7SUFFRCxPQUFPLElBQVA7RUFDQSxDQTlERCxDQTF6VThFLENBNjNVOUU7OztFQUNBMytCLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYSxDQUNaLFdBRFksRUFFWixVQUZZLEVBR1osY0FIWSxFQUlaLFdBSlksRUFLWixhQUxZLEVBTVosVUFOWSxDQUFiLEVBT0csVUFBVUksQ0FBVixFQUFhaUMsSUFBYixFQUFvQjtJQUN0QjlELE1BQU0sQ0FBQ0csRUFBUCxDQUFXMkQsSUFBWCxJQUFvQixVQUFVM0QsRUFBVixFQUFlO01BQ2xDLE9BQU8sS0FBS29sQixFQUFMLENBQVN6aEIsSUFBVCxFQUFlM0QsRUFBZixDQUFQO0lBQ0EsQ0FGRDtFQUdBLENBWEQ7O0VBZ0JBSCxNQUFNLENBQUMwUCxJQUFQLENBQVk4RCxPQUFaLENBQW9COHlCLFFBQXBCLEdBQStCLFVBQVUxa0MsSUFBVixFQUFpQjtJQUMvQyxPQUFPNUIsTUFBTSxDQUFDMEYsSUFBUCxDQUFhMUYsTUFBTSxDQUFDdzRCLE1BQXBCLEVBQTRCLFVBQVVyNEIsRUFBVixFQUFlO01BQ2pELE9BQU95QixJQUFJLEtBQUt6QixFQUFFLENBQUN5QixJQUFuQjtJQUNBLENBRk0sRUFFSGIsTUFGSjtFQUdBLENBSkQ7RUFVQTtBQUNBO0FBQ0E7OztFQUNBLFNBQVN3bEMsU0FBVCxDQUFvQjNrQyxJQUFwQixFQUEyQjtJQUMxQixPQUFPNUIsTUFBTSxDQUFDZ0UsUUFBUCxDQUFpQnBDLElBQWpCLElBQ05BLElBRE0sR0FFTkEsSUFBSSxDQUFDMEMsUUFBTCxLQUFrQixDQUFsQixHQUNDMUMsSUFBSSxDQUFDK0wsV0FBTCxJQUFvQi9MLElBQUksQ0FBQzhsQixZQUQxQixHQUVDLEtBSkY7RUFLQTs7RUFFRDFuQixNQUFNLENBQUN3bUMsTUFBUCxHQUFnQjtJQUNmQyxTQUFTLEVBQUUsbUJBQVU3a0MsSUFBVixFQUFnQmlCLE9BQWhCLEVBQXlCaEIsQ0FBekIsRUFBNkI7TUFDdkMsSUFBSTZrQyxXQUFKO01BQUEsSUFBaUJDLE9BQWpCO01BQUEsSUFBMEJDLFNBQTFCO01BQUEsSUFBcUNDLE1BQXJDO01BQUEsSUFBNkNDLFNBQTdDO01BQUEsSUFBd0RDLFVBQXhEO01BQUEsSUFBb0VDLGlCQUFwRTtNQUFBLElBQ0M5VSxRQUFRLEdBQUdseUIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsVUFBbEIsQ0FEWjtNQUFBLElBRUNxbEMsT0FBTyxHQUFHam5DLE1BQU0sQ0FBRTRCLElBQUYsQ0FGakI7TUFBQSxJQUdDa25CLEtBQUssR0FBRyxFQUhULENBRHVDLENBTXZDOztNQUNBLElBQUtvSixRQUFRLEtBQUssUUFBbEIsRUFBNkI7UUFDNUJ0d0IsSUFBSSxDQUFDZ2MsS0FBTCxDQUFXc1UsUUFBWCxHQUFzQixVQUF0QjtNQUNBOztNQUVENFUsU0FBUyxHQUFHRyxPQUFPLENBQUNULE1BQVIsRUFBWjtNQUNBSSxTQUFTLEdBQUc1bUMsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsS0FBbEIsQ0FBWjtNQUNBbWxDLFVBQVUsR0FBRy9tQyxNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQixNQUFsQixDQUFiO01BQ0FvbEMsaUJBQWlCLEdBQUcsQ0FBRTlVLFFBQVEsS0FBSyxVQUFiLElBQTJCQSxRQUFRLEtBQUssT0FBMUMsS0FDbkJseUIsTUFBTSxDQUFDdUYsT0FBUCxDQUFnQixNQUFoQixFQUF3QixDQUFFcWhDLFNBQUYsRUFBYUcsVUFBYixDQUF4QixJQUFzRCxDQUFDLENBRHhELENBZHVDLENBaUJ2QztNQUNBOztNQUNBLElBQUtDLGlCQUFMLEVBQXlCO1FBQ3hCTixXQUFXLEdBQUdPLE9BQU8sQ0FBQy9VLFFBQVIsRUFBZDtRQUNBMlUsTUFBTSxHQUFHSCxXQUFXLENBQUM5NEIsR0FBckI7UUFDQSs0QixPQUFPLEdBQUdELFdBQVcsQ0FBQ3JWLElBQXRCO01BQ0EsQ0FKRCxNQUlPO1FBQ053VixNQUFNLEdBQUcxaUMsVUFBVSxDQUFFeWlDLFNBQUYsQ0FBVixJQUEyQixDQUFwQztRQUNBRCxPQUFPLEdBQUd4aUMsVUFBVSxDQUFFNGlDLFVBQUYsQ0FBVixJQUE0QixDQUF0QztNQUNBOztNQUVELElBQUsvbUMsTUFBTSxDQUFDaUQsVUFBUCxDQUFtQkosT0FBbkIsQ0FBTCxFQUFvQztRQUVuQztRQUNBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQzVCLElBQVIsQ0FBY1csSUFBZCxFQUFvQkMsQ0FBcEIsRUFBdUI3QixNQUFNLENBQUN3QyxNQUFQLENBQWUsRUFBZixFQUFtQnNrQyxTQUFuQixDQUF2QixDQUFWO01BQ0E7O01BRUQsSUFBS2prQyxPQUFPLENBQUMrSyxHQUFSLElBQWUsSUFBcEIsRUFBMkI7UUFDMUJrYixLQUFLLENBQUNsYixHQUFOLEdBQWMvSyxPQUFPLENBQUMrSyxHQUFSLEdBQWNrNUIsU0FBUyxDQUFDbDVCLEdBQTFCLEdBQWtDaTVCLE1BQTlDO01BQ0E7O01BQ0QsSUFBS2hrQyxPQUFPLENBQUN3dUIsSUFBUixJQUFnQixJQUFyQixFQUE0QjtRQUMzQnZJLEtBQUssQ0FBQ3VJLElBQU4sR0FBZXh1QixPQUFPLENBQUN3dUIsSUFBUixHQUFleVYsU0FBUyxDQUFDelYsSUFBM0IsR0FBb0NzVixPQUFqRDtNQUNBOztNQUVELElBQUssV0FBVzlqQyxPQUFoQixFQUEwQjtRQUN6QkEsT0FBTyxDQUFDcWtDLEtBQVIsQ0FBY2ptQyxJQUFkLENBQW9CVyxJQUFwQixFQUEwQmtuQixLQUExQjtNQUNBLENBRkQsTUFFTztRQUNObWUsT0FBTyxDQUFDM21CLEdBQVIsQ0FBYXdJLEtBQWI7TUFDQTtJQUNEO0VBL0NjLENBQWhCO0VBa0RBOW9CLE1BQU0sQ0FBQ0csRUFBUCxDQUFVcUMsTUFBVixDQUFrQjtJQUNqQmdrQyxNQUFNLEVBQUUsZ0JBQVUzakMsT0FBVixFQUFvQjtNQUMzQixJQUFLZCxTQUFTLENBQUNoQixNQUFmLEVBQXdCO1FBQ3ZCLE9BQU84QixPQUFPLEtBQUtPLFNBQVosR0FDTixJQURNLEdBRU4sS0FBSzNCLElBQUwsQ0FBVyxVQUFVSSxDQUFWLEVBQWM7VUFDeEI3QixNQUFNLENBQUN3bUMsTUFBUCxDQUFjQyxTQUFkLENBQXlCLElBQXpCLEVBQStCNWpDLE9BQS9CLEVBQXdDaEIsQ0FBeEM7UUFDQSxDQUZELENBRkQ7TUFLQTs7TUFFRCxJQUFJd0YsT0FBSjtNQUFBLElBQWE4L0IsR0FBYjtNQUFBLElBQ0NDLEdBQUcsR0FBRztRQUFFeDVCLEdBQUcsRUFBRSxDQUFQO1FBQVV5akIsSUFBSSxFQUFFO01BQWhCLENBRFA7TUFBQSxJQUVDenZCLElBQUksR0FBRyxLQUFNLENBQU4sQ0FGUjtNQUFBLElBR0M4TCxHQUFHLEdBQUc5TCxJQUFJLElBQUlBLElBQUksQ0FBQ2tKLGFBSHBCOztNQUtBLElBQUssQ0FBQzRDLEdBQU4sRUFBWTtRQUNYO01BQ0E7O01BRURyRyxPQUFPLEdBQUdxRyxHQUFHLENBQUNKLGVBQWQsQ0FsQjJCLENBb0IzQjs7TUFDQSxJQUFLLENBQUN0TixNQUFNLENBQUN5SCxRQUFQLENBQWlCSixPQUFqQixFQUEwQnpGLElBQTFCLENBQU4sRUFBeUM7UUFDeEMsT0FBT3dsQyxHQUFQO01BQ0EsQ0F2QjBCLENBeUIzQjtNQUNBOzs7TUFDQSxJQUFLLE9BQU94bEMsSUFBSSxDQUFDNHhCLHFCQUFaLEtBQXNDLFdBQTNDLEVBQXlEO1FBQ3hENFQsR0FBRyxHQUFHeGxDLElBQUksQ0FBQzR4QixxQkFBTCxFQUFOO01BQ0E7O01BQ0QyVCxHQUFHLEdBQUdaLFNBQVMsQ0FBRTc0QixHQUFGLENBQWY7TUFDQSxPQUFPO1FBQ05FLEdBQUcsRUFBRXc1QixHQUFHLENBQUN4NUIsR0FBSixJQUFhdTVCLEdBQUcsQ0FBQ0UsV0FBSixJQUFtQmhnQyxPQUFPLENBQUN3aUIsU0FBeEMsS0FBeUR4aUIsT0FBTyxDQUFDeWlCLFNBQVIsSUFBc0IsQ0FBL0UsQ0FEQztRQUVOdUgsSUFBSSxFQUFFK1YsR0FBRyxDQUFDL1YsSUFBSixJQUFhOFYsR0FBRyxDQUFDRyxXQUFKLElBQW1CamdDLE9BQU8sQ0FBQ29pQixVQUF4QyxLQUF5RHBpQixPQUFPLENBQUNxaUIsVUFBUixJQUFzQixDQUEvRTtNQUZBLENBQVA7SUFJQSxDQXBDZ0I7SUFzQ2pCd0ksUUFBUSxFQUFFLG9CQUFXO01BQ3BCLElBQUssQ0FBQyxLQUFNLENBQU4sQ0FBTixFQUFrQjtRQUNqQjtNQUNBOztNQUVELElBQUlxVixZQUFKO01BQUEsSUFBa0JmLE1BQWxCO01BQUEsSUFDQ2dCLFlBQVksR0FBRztRQUFFNTVCLEdBQUcsRUFBRSxDQUFQO1FBQVV5akIsSUFBSSxFQUFFO01BQWhCLENBRGhCO01BQUEsSUFFQ3p2QixJQUFJLEdBQUcsS0FBTSxDQUFOLENBRlIsQ0FMb0IsQ0FTcEI7TUFDQTs7TUFDQSxJQUFLNUIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsVUFBbEIsTUFBbUMsT0FBeEMsRUFBa0Q7UUFFakQ7UUFDQTRrQyxNQUFNLEdBQUc1a0MsSUFBSSxDQUFDNHhCLHFCQUFMLEVBQVQ7TUFDQSxDQUpELE1BSU87UUFFTjtRQUNBK1QsWUFBWSxHQUFHLEtBQUtBLFlBQUwsRUFBZixDQUhNLENBS047O1FBQ0FmLE1BQU0sR0FBRyxLQUFLQSxNQUFMLEVBQVQ7O1FBQ0EsSUFBSyxDQUFDeG1DLE1BQU0sQ0FBQytFLFFBQVAsQ0FBaUJ3aUMsWUFBWSxDQUFFLENBQUYsQ0FBN0IsRUFBb0MsTUFBcEMsQ0FBTixFQUFxRDtVQUNwREMsWUFBWSxHQUFHRCxZQUFZLENBQUNmLE1BQWIsRUFBZjtRQUNBLENBVEssQ0FXTjs7O1FBQ0FnQixZQUFZLENBQUM1NUIsR0FBYixJQUFxQjVOLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVlpbkIsWUFBWSxDQUFFLENBQUYsQ0FBeEIsRUFBK0IsZ0JBQS9CLEVBQWlELElBQWpELENBQXJCO1FBQ0FDLFlBQVksQ0FBQ25XLElBQWIsSUFBcUJyeEIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWWluQixZQUFZLENBQUUsQ0FBRixDQUF4QixFQUErQixpQkFBL0IsRUFBa0QsSUFBbEQsQ0FBckI7TUFDQSxDQTdCbUIsQ0ErQnBCO01BQ0E7TUFDQTs7O01BQ0EsT0FBTztRQUNOMzVCLEdBQUcsRUFBRzQ0QixNQUFNLENBQUM1NEIsR0FBUCxHQUFjNDVCLFlBQVksQ0FBQzU1QixHQUEzQixHQUFpQzVOLE1BQU0sQ0FBQ3NnQixHQUFQLENBQVkxZSxJQUFaLEVBQWtCLFdBQWxCLEVBQStCLElBQS9CLENBRGpDO1FBRU55dkIsSUFBSSxFQUFFbVYsTUFBTSxDQUFDblYsSUFBUCxHQUFjbVcsWUFBWSxDQUFDblcsSUFBM0IsR0FBa0NyeEIsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWTFlLElBQVosRUFBa0IsWUFBbEIsRUFBZ0MsSUFBaEM7TUFGbEMsQ0FBUDtJQUlBLENBNUVnQjtJQThFakIybEMsWUFBWSxFQUFFLHdCQUFXO01BQ3hCLE9BQU8sS0FBSzVsQyxHQUFMLENBQVUsWUFBVztRQUMzQixJQUFJNGxDLFlBQVksR0FBRyxLQUFLQSxZQUF4Qjs7UUFFQSxPQUFRQSxZQUFZLElBQU0sQ0FBQ3ZuQyxNQUFNLENBQUMrRSxRQUFQLENBQWlCd2lDLFlBQWpCLEVBQStCLE1BQS9CLENBQUQsSUFDekJ2bkMsTUFBTSxDQUFDc2dCLEdBQVAsQ0FBWWluQixZQUFaLEVBQTBCLFVBQTFCLE1BQTJDLFFBRDVDLEVBQ3lEO1VBQ3hEQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0EsWUFBNUI7UUFDQTs7UUFDRCxPQUFPQSxZQUFZLElBQUlqNkIsZUFBdkI7TUFDQSxDQVJNLENBQVA7SUFTQTtFQXhGZ0IsQ0FBbEIsRUFyOVU4RSxDQWdqVjlFOztFQUNBdE4sTUFBTSxDQUFDeUIsSUFBUCxDQUFhO0lBQUVnb0IsVUFBVSxFQUFFLGFBQWQ7SUFBNkJJLFNBQVMsRUFBRTtFQUF4QyxDQUFiLEVBQXNFLFVBQVU2WSxNQUFWLEVBQWtCbGlCLElBQWxCLEVBQXlCO0lBQzlGLElBQUk1UyxHQUFHLEdBQUcsSUFBSXZDLElBQUosQ0FBVW1WLElBQVYsQ0FBVjs7SUFFQXhnQixNQUFNLENBQUNHLEVBQVAsQ0FBV3VpQyxNQUFYLElBQXNCLFVBQVU3eUIsR0FBVixFQUFnQjtNQUNyQyxPQUFPc1IsTUFBTSxDQUFFLElBQUYsRUFBUSxVQUFVdmYsSUFBVixFQUFnQjhnQyxNQUFoQixFQUF3Qjd5QixHQUF4QixFQUE4QjtRQUNsRCxJQUFJczNCLEdBQUcsR0FBR1osU0FBUyxDQUFFM2tDLElBQUYsQ0FBbkI7O1FBRUEsSUFBS2lPLEdBQUcsS0FBS3pNLFNBQWIsRUFBeUI7VUFDeEIsT0FBTytqQyxHQUFHLEdBQUszbUIsSUFBSSxJQUFJMm1CLEdBQVYsR0FBa0JBLEdBQUcsQ0FBRTNtQixJQUFGLENBQXJCLEdBQ1oybUIsR0FBRyxDQUFDbm9DLFFBQUosQ0FBYXNPLGVBQWIsQ0FBOEJvMUIsTUFBOUIsQ0FEUyxHQUVUOWdDLElBQUksQ0FBRThnQyxNQUFGLENBRkw7UUFHQTs7UUFFRCxJQUFLeUUsR0FBTCxFQUFXO1VBQ1ZBLEdBQUcsQ0FBQ00sUUFBSixDQUNDLENBQUM3NUIsR0FBRCxHQUFPaUMsR0FBUCxHQUFhN1AsTUFBTSxDQUFFbW5DLEdBQUYsQ0FBTixDQUFjMWQsVUFBZCxFQURkLEVBRUM3YixHQUFHLEdBQUdpQyxHQUFILEdBQVM3UCxNQUFNLENBQUVtbkMsR0FBRixDQUFOLENBQWN0ZCxTQUFkLEVBRmI7UUFLQSxDQU5ELE1BTU87VUFDTmpvQixJQUFJLENBQUU4Z0MsTUFBRixDQUFKLEdBQWlCN3lCLEdBQWpCO1FBQ0E7TUFDRCxDQWxCWSxFQWtCVjZ5QixNQWxCVSxFQWtCRjd5QixHQWxCRSxFQWtCRzlOLFNBQVMsQ0FBQ2hCLE1BbEJiLEVBa0JxQixJQWxCckIsQ0FBYjtJQW1CQSxDQXBCRDtFQXFCQSxDQXhCRCxFQWpqVjhFLENBMmtWOUU7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUFDQWYsTUFBTSxDQUFDeUIsSUFBUCxDQUFhLENBQUUsS0FBRixFQUFTLE1BQVQsQ0FBYixFQUFnQyxVQUFVSSxDQUFWLEVBQWEyZSxJQUFiLEVBQW9CO0lBQ25EeGdCLE1BQU0sQ0FBQ3l6QixRQUFQLENBQWlCalQsSUFBakIsSUFBMEJrUixZQUFZLENBQUU1eEIsT0FBTyxDQUFDb3dCLGFBQVYsRUFDckMsVUFBVXR1QixJQUFWLEVBQWdCb3ZCLFFBQWhCLEVBQTJCO01BQzFCLElBQUtBLFFBQUwsRUFBZ0I7UUFDZkEsUUFBUSxHQUFHSixNQUFNLENBQUVodkIsSUFBRixFQUFRNGUsSUFBUixDQUFqQixDQURlLENBR2Y7O1FBQ0EsT0FBT3NPLFNBQVMsQ0FBQ3pqQixJQUFWLENBQWdCMmxCLFFBQWhCLElBQ05oeEIsTUFBTSxDQUFFNEIsSUFBRixDQUFOLENBQWVzd0IsUUFBZixHQUEyQjFSLElBQTNCLElBQW9DLElBRDlCLEdBRU53USxRQUZEO01BR0E7SUFDRCxDQVZvQyxDQUF0QztFQVlBLENBYkQsRUFobFY4RSxDQWdtVjlFOztFQUNBaHhCLE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYTtJQUFFaW1DLE1BQU0sRUFBRSxRQUFWO0lBQW9CQyxLQUFLLEVBQUU7RUFBM0IsQ0FBYixFQUFtRCxVQUFVL2tDLElBQVYsRUFBZ0JrQixJQUFoQixFQUF1QjtJQUN6RTlELE1BQU0sQ0FBQ3lCLElBQVAsQ0FBYTtNQUFFdXlCLE9BQU8sRUFBRSxVQUFVcHhCLElBQXJCO01BQTJCc3BCLE9BQU8sRUFBRXBvQixJQUFwQztNQUEwQyxJQUFJLFVBQVVsQjtJQUF4RCxDQUFiLEVBQ0EsVUFBVWdsQyxZQUFWLEVBQXdCQyxRQUF4QixFQUFtQztNQUVsQztNQUNBN25DLE1BQU0sQ0FBQ0csRUFBUCxDQUFXMG5DLFFBQVgsSUFBd0IsVUFBVTlULE1BQVYsRUFBa0IvdEIsS0FBbEIsRUFBMEI7UUFDakQsSUFBSW9iLFNBQVMsR0FBR3JmLFNBQVMsQ0FBQ2hCLE1BQVYsS0FBc0I2bUMsWUFBWSxJQUFJLE9BQU83VCxNQUFQLEtBQWtCLFNBQXhELENBQWhCO1FBQUEsSUFDQ2QsS0FBSyxHQUFHMlUsWUFBWSxLQUFNN1QsTUFBTSxLQUFLLElBQVgsSUFBbUIvdEIsS0FBSyxLQUFLLElBQTdCLEdBQW9DLFFBQXBDLEdBQStDLFFBQXJELENBRHJCO1FBR0EsT0FBT21iLE1BQU0sQ0FBRSxJQUFGLEVBQVEsVUFBVXZmLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQmtDLEtBQXRCLEVBQThCO1VBQ2xELElBQUkwSCxHQUFKOztVQUVBLElBQUsxTixNQUFNLENBQUNnRSxRQUFQLENBQWlCcEMsSUFBakIsQ0FBTCxFQUErQjtZQUU5QjtZQUNBO1lBQ0E7WUFDQSxPQUFPQSxJQUFJLENBQUM1QyxRQUFMLENBQWNzTyxlQUFkLENBQStCLFdBQVcxSyxJQUExQyxDQUFQO1VBQ0EsQ0FUaUQsQ0FXbEQ7OztVQUNBLElBQUtoQixJQUFJLENBQUMwQyxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO1lBQzFCb0osR0FBRyxHQUFHOUwsSUFBSSxDQUFDMEwsZUFBWCxDQUQwQixDQUcxQjtZQUNBO1lBQ0E7WUFDQTs7WUFDQSxPQUFPaEssSUFBSSxDQUFDa0MsR0FBTCxDQUNONUQsSUFBSSxDQUFDOGIsSUFBTCxDQUFXLFdBQVc5YSxJQUF0QixDQURNLEVBQ3dCOEssR0FBRyxDQUFFLFdBQVc5SyxJQUFiLENBRDNCLEVBRU5oQixJQUFJLENBQUM4YixJQUFMLENBQVcsV0FBVzlhLElBQXRCLENBRk0sRUFFd0I4SyxHQUFHLENBQUUsV0FBVzlLLElBQWIsQ0FGM0IsRUFHTjhLLEdBQUcsQ0FBRSxXQUFXOUssSUFBYixDQUhHLENBQVA7VUFLQTs7VUFFRCxPQUFPb0QsS0FBSyxLQUFLNUMsU0FBVixHQUVOO1VBQ0FwRCxNQUFNLENBQUNzZ0IsR0FBUCxDQUFZMWUsSUFBWixFQUFrQmtDLElBQWxCLEVBQXdCbXZCLEtBQXhCLENBSE0sR0FLTjtVQUNBanpCLE1BQU0sQ0FBQzRkLEtBQVAsQ0FBY2hjLElBQWQsRUFBb0JrQyxJQUFwQixFQUEwQmtDLEtBQTFCLEVBQWlDaXRCLEtBQWpDLENBTkQ7UUFPQSxDQWpDWSxFQWlDVm52QixJQWpDVSxFQWlDSnNkLFNBQVMsR0FBRzJTLE1BQUgsR0FBWTN3QixTQWpDakIsRUFpQzRCZ2UsU0FqQzVCLEVBaUN1QyxJQWpDdkMsQ0FBYjtNQWtDQSxDQXRDRDtJQXVDQSxDQTNDRDtFQTRDQSxDQTdDRDtFQWdEQXBoQixNQUFNLENBQUNHLEVBQVAsQ0FBVXFDLE1BQVYsQ0FBa0I7SUFFakJzbEMsSUFBSSxFQUFFLGNBQVV0aUIsS0FBVixFQUFpQjlnQixJQUFqQixFQUF1QnZFLEVBQXZCLEVBQTRCO01BQ2pDLE9BQU8sS0FBS29sQixFQUFMLENBQVNDLEtBQVQsRUFBZ0IsSUFBaEIsRUFBc0I5Z0IsSUFBdEIsRUFBNEJ2RSxFQUE1QixDQUFQO0lBQ0EsQ0FKZ0I7SUFLakI0bkMsTUFBTSxFQUFFLGdCQUFVdmlCLEtBQVYsRUFBaUJybEIsRUFBakIsRUFBc0I7TUFDN0IsT0FBTyxLQUFLMmMsR0FBTCxDQUFVMEksS0FBVixFQUFpQixJQUFqQixFQUF1QnJsQixFQUF2QixDQUFQO0lBQ0EsQ0FQZ0I7SUFTakI2bkMsUUFBUSxFQUFFLGtCQUFVL25DLFFBQVYsRUFBb0J1bEIsS0FBcEIsRUFBMkI5Z0IsSUFBM0IsRUFBaUN2RSxFQUFqQyxFQUFzQztNQUMvQyxPQUFPLEtBQUtvbEIsRUFBTCxDQUFTQyxLQUFULEVBQWdCdmxCLFFBQWhCLEVBQTBCeUUsSUFBMUIsRUFBZ0N2RSxFQUFoQyxDQUFQO0lBQ0EsQ0FYZ0I7SUFZakI4bkMsVUFBVSxFQUFFLG9CQUFVaG9DLFFBQVYsRUFBb0J1bEIsS0FBcEIsRUFBMkJybEIsRUFBM0IsRUFBZ0M7TUFFM0M7TUFDQSxPQUFPNEIsU0FBUyxDQUFDaEIsTUFBVixLQUFxQixDQUFyQixHQUNOLEtBQUsrYixHQUFMLENBQVU3YyxRQUFWLEVBQW9CLElBQXBCLENBRE0sR0FFTixLQUFLNmMsR0FBTCxDQUFVMEksS0FBVixFQUFpQnZsQixRQUFRLElBQUksSUFBN0IsRUFBbUNFLEVBQW5DLENBRkQ7SUFHQTtFQWxCZ0IsQ0FBbEIsRUFqcFY4RSxDQXNxVjlFOztFQUNBSCxNQUFNLENBQUNHLEVBQVAsQ0FBVStuQyxJQUFWLEdBQWlCLFlBQVc7SUFDM0IsT0FBTyxLQUFLbm5DLE1BQVo7RUFDQSxDQUZEOztFQUlBZixNQUFNLENBQUNHLEVBQVAsQ0FBVWdvQyxPQUFWLEdBQW9Cbm9DLE1BQU0sQ0FBQ0csRUFBUCxDQUFVMFksT0FBOUIsQ0EzcVY4RSxDQWdyVjlFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBRUE7RUFDQTtFQUNBO0VBQ0E7O0VBRUEsSUFBSyxJQUFMLEVBQWtEO0lBQ2pEdXZCLGlDQUFrQixFQUFaLG1DQUFnQixZQUFXO01BQ2hDLE9BQU9wb0MsTUFBUDtJQUNBLENBRks7QUFBQSxrR0FBTjtFQUdBOztFQUlELElBRUM7RUFDQXNvQyxPQUFPLEdBQUducEMsTUFBTSxDQUFDYSxNQUhsQjtFQUFBLElBS0M7RUFDQXVvQyxFQUFFLEdBQUdwcEMsTUFBTSxDQUFDcXBDLENBTmI7O0VBUUF4b0MsTUFBTSxDQUFDeW9DLFVBQVAsR0FBb0IsVUFBVXpsQyxJQUFWLEVBQWlCO0lBQ3BDLElBQUs3RCxNQUFNLENBQUNxcEMsQ0FBUCxLQUFheG9DLE1BQWxCLEVBQTJCO01BQzFCYixNQUFNLENBQUNxcEMsQ0FBUCxHQUFXRCxFQUFYO0lBQ0E7O0lBRUQsSUFBS3ZsQyxJQUFJLElBQUk3RCxNQUFNLENBQUNhLE1BQVAsS0FBa0JBLE1BQS9CLEVBQXdDO01BQ3ZDYixNQUFNLENBQUNhLE1BQVAsR0FBZ0Jzb0MsT0FBaEI7SUFDQTs7SUFFRCxPQUFPdG9DLE1BQVA7RUFDQSxDQVZELENBN3NWOEUsQ0F5dFY5RTtFQUNBO0VBQ0E7OztFQUNBLElBQUssQ0FBQ1osUUFBTixFQUFpQjtJQUNoQkQsTUFBTSxDQUFDYSxNQUFQLEdBQWdCYixNQUFNLENBQUNxcEMsQ0FBUCxHQUFXeG9DLE1BQTNCO0VBQ0E7O0VBRUQsT0FBT0EsTUFBUDtBQUNDLENBeHZWQSxDQUFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2pxdWVyeS0xLjEyLjMuanM/ZTY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMTIuM1xuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA0LTA1VDE5OjE2WlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGVsZXRlZElkcyA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBzbGljZSA9IGRlbGV0ZWRJZHMuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBkZWxldGVkSWRzLmNvbmNhdDtcblxudmFyIHB1c2ggPSBkZWxldGVkSWRzLnB1c2g7XG5cbnZhciBpbmRleE9mID0gZGVsZXRlZElkcy5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIxLjEyLjNcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIElFPDlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBkZWxldGVkSWRzLnNvcnQsXG5cdHNwbGljZTogZGVsZXRlZElkcy5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJhcnJheVwiO1xuXHR9LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8qIGpzaGludCBlcWVxZXE6IGZhbHNlICovXG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gTXVzdCBiZSBhbiBPYmplY3QuXG5cdFx0Ly8gQmVjYXVzZSBvZiBJRSwgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiB0aGUgY29uc3RydWN0b3IgcHJvcGVydHkuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgRE9NIG5vZGVzIGFuZCB3aW5kb3cgb2JqZWN0cyBkb24ndCBwYXNzIHRocm91Z2gsIGFzIHdlbGxcblx0XHRpZiAoICFvYmogfHwgalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cblx0XHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLCBcImNvbnN0cnVjdG9yXCIgKSAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0Ly8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEhhbmRsZSBpdGVyYXRpb24gb3ZlciBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuXG5cdFx0aWYgKCAhc3VwcG9ydC5vd25GaXJzdCApIHtcblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdHJldHVybiBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIFdvcmthcm91bmRzIGJhc2VkIG9uIGZpbmRpbmdzIGJ5IEppbSBEcmlzY29sbFxuXHQvLyBodHRwOi8vd2VibG9ncy5qYXZhLm5ldC9ibG9nL2RyaXNjb2xsL2FyY2hpdmUvMjAwOS8wOS8wOC9ldmFsLWphdmFzY3JpcHQtZ2xvYmFsLWNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCBkYXRhICYmIGpRdWVyeS50cmltKCBkYXRhICkgKSB7XG5cblx0XHRcdC8vIFdlIHVzZSBleGVjU2NyaXB0IG9uIEludGVybmV0IEV4cGxvcmVyXG5cdFx0XHQvLyBXZSB1c2UgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHNvIHRoYXQgY29udGV4dCBpcyB3aW5kb3dcblx0XHRcdC8vIHJhdGhlciB0aGFuIGpRdWVyeSBpbiBGaXJlZm94XG5cdFx0XHQoIHdpbmRvdy5leGVjU2NyaXB0IHx8IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHR3aW5kb3dbIFwiZXZhbFwiIF0uY2FsbCggd2luZG93LCBkYXRhICk7IC8vIGpzY3M6aWdub3JlIHJlcXVpcmVEb3ROb3RhdGlvblxuXHRcdFx0fSApKCBkYXRhICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIElFPDlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHR2YXIgbGVuO1xuXG5cdFx0aWYgKCBhcnIgKSB7XG5cdFx0XHRpZiAoIGluZGV4T2YgKSB7XG5cdFx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0aSA9IGkgPyBpIDwgMCA/IE1hdGgubWF4KCAwLCBsZW4gKyBpICkgOiBpIDogMDtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cblx0XHRcdFx0Ly8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuXHRcdFx0XHRpZiAoIGkgaW4gYXJyICYmIGFyclsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHR3aGlsZSAoIGogPCBsZW4gKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGorKyBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBXb3JrYXJvdW5kIGNhc3Rpbmcgb2YgLmxlbmd0aCB0byBOYU4gb24gb3RoZXJ3aXNlIGFycmF5bGlrZSBvYmplY3RzIChlLmcuLCBOb2RlTGlzdHMpXG5cdFx0aWYgKCBsZW4gIT09IGxlbiApIHtcblx0XHRcdHdoaWxlICggc2Vjb25kWyBqIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciBhcmdzLCBwcm94eSwgdG1wO1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKyggbmV3IERhdGUoKSApO1xuXHR9LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gZGVsZXRlZElkc1sgU3ltYm9sLml0ZXJhdG9yIF07XG59XG4vKiBqc2hpbnQgaWdub3JlOiBlbmQgKi9cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4xXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTEwLTE3XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbmlkc2VsZWN0LCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHRuaWRzZWxlY3QgPSByaWRlbnRpZmllci50ZXN0KCBuaWQgKSA/IFwiI1wiICsgbmlkIDogXCJbaWQ9J1wiICsgbmlkICsgXCInXVwiO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkc2VsZWN0ICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggKHBhcmVudCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBwYXJlbnQudG9wICE9PSBwYXJlbnQgKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTFcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbXFx3LV0rKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBxdWFsaWZpZXIgKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdGxlbiA9IHNlbGYubGVuZ3RoO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdCBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yLmNoYXJBdCggMCApID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5jaGFyQXQoIHNlbGVjdG9yLmxlbmd0aCAtIDEgKSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkICE9PSBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcm9vdGpRdWVyeS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlIGluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3QucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gbWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGxlbiA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluXG5cdC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gaW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KCB0aGlzWyAwIF0sIGpRdWVyeSggZWxlbSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbSwgdGhpcyApO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHRkbyB7XG5cdFx0Y3VyID0gY3VyWyBkaXIgXTtcblx0fSB3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDEgKTtcblxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xuXHRcdFx0ZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50IDpcblx0XHRcdGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0ID0gcmV0LnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIGFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLyoqXG4gKiBDbGVhbi11cCBtZXRob2QgZm9yIGRvbSByZWFkeSBldmVudHNcbiAqL1xuZnVuY3Rpb24gZGV0YWNoKCkge1xuXHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cblx0fSBlbHNlIHtcblx0XHRkb2N1bWVudC5kZXRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG5cdFx0d2luZG93LmRldGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblxuXHQvLyByZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgaXMgZ29vZCBlbm91Z2ggZm9yIHVzIHRvIGNhbGwgdGhlIGRvbSByZWFkeSBpbiBvbGRJRVxuXHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgfHxcblx0XHR3aW5kb3cuZXZlbnQudHlwZSA9PT0gXCJsb2FkXCIgfHxcblx0XHRkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cblx0XHRkZXRhY2goKTtcblx0XHRqUXVlcnkucmVhZHkoKTtcblx0fVxufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTYtMTBcblx0XHQvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHRcdFx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0Ly8gU3RhbmRhcmRzLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnQgRE9NQ29udGVudExvYWRlZFxuXHRcdH0gZWxzZSBpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cblx0XHQvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLCBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcblx0XHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbmxvYWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuXHRcdFx0Ly8gY29udGludWFsbHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBkb2N1bWVudCBpcyByZWFkeVxuXHRcdFx0dmFyIHRvcCA9IGZhbHNlO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0b3AgPSB3aW5kb3cuZnJhbWVFbGVtZW50ID09IG51bGwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHRpZiAoIHRvcCAmJiB0b3AuZG9TY3JvbGwgKSB7XG5cdFx0XHRcdCggZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuaXNSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuXHRcdFx0XHRcdFx0XHR0b3AuZG9TY3JvbGwoIFwibGVmdFwiICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KCBkb1Njcm9sbENoZWNrLCA1MCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBkZXRhY2ggYWxsIGRvbSByZWFkeSBldmVudHNcblx0XHRcdFx0XHRcdGRldGFjaCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBhbmQgZXhlY3V0ZSBhbnkgd2FpdGluZyBmdW5jdGlvbnNcblx0XHRcdFx0XHRcdGpRdWVyeS5yZWFkeSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIEl0ZXJhdGlvbiBvdmVyIG9iamVjdCdzIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBpdHMgb3duXG52YXIgaTtcbmZvciAoIGkgaW4galF1ZXJ5KCBzdXBwb3J0ICkgKSB7XG5cdGJyZWFrO1xufVxuc3VwcG9ydC5vd25GaXJzdCA9IGkgPT09IFwiMFwiO1xuXG4vLyBOb3RlOiBtb3N0IHN1cHBvcnQgdGVzdHMgYXJlIGRlZmluZWQgaW4gdGhlaXIgcmVzcGVjdGl2ZSBtb2R1bGVzLlxuLy8gZmFsc2UgdW50aWwgdGhlIHRlc3QgaXMgcnVuXG5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSBmYWxzZTtcblxuLy8gRXhlY3V0ZSBBU0FQIGluIGNhc2Ugd2UgbmVlZCB0byBzZXQgYm9keS5zdHlsZS56b29tXG5qUXVlcnkoIGZ1bmN0aW9uKCkge1xuXG5cdC8vIE1pbmlmaWVkOiB2YXIgYSxiLGMsZFxuXHR2YXIgdmFsLCBkaXYsIGJvZHksIGNvbnRhaW5lcjtcblxuXHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYm9keVwiIClbIDAgXTtcblx0aWYgKCAhYm9keSB8fCAhYm9keS5zdHlsZSApIHtcblxuXHRcdC8vIFJldHVybiBmb3IgZnJhbWVzZXQgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBib2R5XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU2V0dXBcblx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweFwiO1xuXHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0Ly8gQ2hlY2sgaWYgbmF0aXZlbHkgYmxvY2stbGV2ZWwgZWxlbWVudHMgYWN0IGxpa2UgaW5saW5lLWJsb2NrXG5cdFx0Ly8gZWxlbWVudHMgd2hlbiBzZXR0aW5nIHRoZWlyIGRpc3BsYXkgdG8gJ2lubGluZScgYW5kIGdpdmluZ1xuXHRcdC8vIHRoZW0gbGF5b3V0XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcImRpc3BsYXk6aW5saW5lO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjFcIjtcblxuXHRcdHN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9IHZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMztcblx0XHRpZiAoIHZhbCApIHtcblxuXHRcdFx0Ly8gUHJldmVudCBJRSA2IGZyb20gYWZmZWN0aW5nIGxheW91dCBmb3IgcG9zaXRpb25lZCBlbGVtZW50cyAjMTEwNDhcblx0XHRcdC8vIFByZXZlbnQgSUUgZnJvbSBzaHJpbmtpbmcgdGhlIGJvZHkgaW4gSUUgNyBtb2RlICMxMjg2OVxuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0Ym9keS5zdHlsZS56b29tID0gMTtcblx0XHR9XG5cdH1cblxuXHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcbn0gKTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gdHJ1ZTtcblx0dHJ5IHtcblx0XHRkZWxldGUgZGl2LnRlc3Q7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0ZGl2ID0gbnVsbDtcbn0gKSgpO1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vRGF0YSA9IGpRdWVyeS5ub0RhdGFbICggZWxlbS5ub2RlTmFtZSArIFwiIFwiICkudG9Mb3dlckNhc2UoKSBdLFxuXHRcdG5vZGVUeXBlID0gK2VsZW0ubm9kZVR5cGUgfHwgMTtcblxuXHQvLyBEbyBub3Qgc2V0IGRhdGEgb24gbm9uLWVsZW1lbnQgRE9NIG5vZGVzIGJlY2F1c2UgaXQgd2lsbCBub3QgYmUgY2xlYXJlZCAoIzgzMzUpLlxuXHRyZXR1cm4gbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgP1xuXHRcdGZhbHNlIDpcblxuXHRcdC8vIE5vZGVzIGFjY2VwdCBkYXRhIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkOyByZWplY3Rpb24gY2FuIGJlIGNvbmRpdGlvbmFsXG5cdFx0IW5vRGF0YSB8fCBub0RhdGEgIT09IHRydWUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NpZFwiICkgPT09IG5vRGF0YTtcbn07XG5cblxuXG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHR2YXIgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kMVwiICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRqUXVlcnkuZGF0YSggZWxlbSwga2V5LCBkYXRhICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuLy8gY2hlY2tzIGEgY2FjaGUgb2JqZWN0IGZvciBlbXB0aW5lc3NcbmZ1bmN0aW9uIGlzRW1wdHlEYXRhT2JqZWN0KCBvYmogKSB7XG5cdHZhciBuYW1lO1xuXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblxuXHRcdC8vIGlmIHRoZSBwdWJsaWMgZGF0YSBvYmplY3QgaXMgZW1wdHksIHRoZSBwcml2YXRlIGlzIHN0aWxsIGVtcHR5XG5cdFx0aWYgKCBuYW1lID09PSBcImRhdGFcIiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb2JqWyBuYW1lIF0gKSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoIG5hbWUgIT09IFwidG9KU09OXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgcHZ0IC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJldCwgdGhpc0NhY2hlLFxuXHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cblx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdC8vIGNhbid0IEdDIG9iamVjdCByZWZlcmVuY2VzIHByb3Blcmx5IGFjcm9zcyB0aGUgRE9NLUpTIGJvdW5kYXJ5XG5cdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0Ly8gYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBzbyBHQyBjYW4gb2NjdXIgYXV0b21hdGljYWxseVxuXHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblxuXHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdC8vIHRoZSBjb2RlIHRvIHNob3J0Y3V0IG9uIHRoZSBzYW1lIHBhdGggYXMgYSBET00gbm9kZSB3aXRoIG5vIGNhY2hlXG5cdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogZWxlbVsgaW50ZXJuYWxLZXkgXSAmJiBpbnRlcm5hbEtleTtcblxuXHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHQvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGxcblx0aWYgKCAoICFpZCB8fCAhY2FjaGVbIGlkIF0gfHwgKCAhcHZ0ICYmICFjYWNoZVsgaWQgXS5kYXRhICkgKSAmJlxuXHRcdGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoICFpZCApIHtcblxuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgYSBuZXcgdW5pcXVlIElEIGZvciBlYWNoIGVsZW1lbnQgc2luY2UgdGhlaXIgZGF0YVxuXHRcdC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuXHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdID0gZGVsZXRlZElkcy5wb3AoKSB8fCBqUXVlcnkuZ3VpZCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZCA9IGludGVybmFsS2V5O1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWNhY2hlWyBpZCBdICkge1xuXG5cdFx0Ly8gQXZvaWQgZXhwb3NpbmcgalF1ZXJ5IG1ldGFkYXRhIG9uIHBsYWluIEpTIG9iamVjdHMgd2hlbiB0aGUgb2JqZWN0XG5cdFx0Ly8gaXMgc2VyaWFsaXplZCB1c2luZyBKU09OLnN0cmluZ2lmeVxuXHRcdGNhY2hlWyBpZCBdID0gaXNOb2RlID8ge30gOiB7IHRvSlNPTjogalF1ZXJ5Lm5vb3AgfTtcblx0fVxuXG5cdC8vIEFuIG9iamVjdCBjYW4gYmUgcGFzc2VkIHRvIGpRdWVyeS5kYXRhIGluc3RlYWQgb2YgYSBrZXkvdmFsdWUgcGFpcjsgdGhpcyBnZXRzXG5cdC8vIHNoYWxsb3cgY29waWVkIG92ZXIgb250byB0aGUgZXhpc3RpbmcgY2FjaGVcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdGlmICggcHZ0ICkge1xuXHRcdFx0Y2FjaGVbIGlkIF0gPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWNoZVsgaWQgXS5kYXRhID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0uZGF0YSwgbmFtZSApO1xuXHRcdH1cblx0fVxuXG5cdHRoaXNDYWNoZSA9IGNhY2hlWyBpZCBdO1xuXG5cdC8vIGpRdWVyeSBkYXRhKCkgaXMgc3RvcmVkIGluIGEgc2VwYXJhdGUgb2JqZWN0IGluc2lkZSB0aGUgb2JqZWN0J3MgaW50ZXJuYWwgZGF0YVxuXHQvLyBjYWNoZSBpbiBvcmRlciB0byBhdm9pZCBrZXkgY29sbGlzaW9ucyBiZXR3ZWVuIGludGVybmFsIGRhdGEgYW5kIHVzZXItZGVmaW5lZFxuXHQvLyBkYXRhLlxuXHRpZiAoICFwdnQgKSB7XG5cdFx0aWYgKCAhdGhpc0NhY2hlLmRhdGEgKSB7XG5cdFx0XHR0aGlzQ2FjaGUuZGF0YSA9IHt9O1xuXHRcdH1cblxuXHRcdHRoaXNDYWNoZSA9IHRoaXNDYWNoZS5kYXRhO1xuXHR9XG5cblx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXSA9IGRhdGE7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgYm90aCBjb252ZXJ0ZWQtdG8tY2FtZWwgYW5kIG5vbi1jb252ZXJ0ZWQgZGF0YSBwcm9wZXJ0eSBuYW1lc1xuXHQvLyBJZiBhIGRhdGEgcHJvcGVydHkgd2FzIHNwZWNpZmllZFxuXHRpZiAoIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0Ly8gRmlyc3QgVHJ5IHRvIGZpbmQgYXMtaXMgcHJvcGVydHkgZGF0YVxuXHRcdHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xuXG5cdFx0Ly8gVGVzdCBmb3IgbnVsbHx1bmRlZmluZWQgcHJvcGVydHkgZGF0YVxuXHRcdGlmICggcmV0ID09IG51bGwgKSB7XG5cblx0XHRcdC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XG5cdFx0XHRyZXQgPSB0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXQgPSB0aGlzQ2FjaGU7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFJlbW92ZURhdGEoIGVsZW0sIG5hbWUsIHB2dCApIHtcblx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciB0aGlzQ2FjaGUsIGksXG5cdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblx0XHRpZCA9IGlzTm9kZSA/IGVsZW1bIGpRdWVyeS5leHBhbmRvIF0gOiBqUXVlcnkuZXhwYW5kbztcblxuXHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cblx0Ly8gcHVycG9zZSBpbiBjb250aW51aW5nXG5cdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggbmFtZSApIHtcblxuXHRcdHRoaXNDYWNoZSA9IHB2dCA/IGNhY2hlWyBpZCBdIDogY2FjaGVbIGlkIF0uZGF0YTtcblxuXHRcdGlmICggdGhpc0NhY2hlICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgbmFtZXMgZm9yIGRhdGEga2V5c1xuXHRcdFx0aWYgKCAhalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblxuXHRcdFx0XHQvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIG5hbWUgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHNwbGl0IHRoZSBjYW1lbCBjYXNlZCB2ZXJzaW9uIGJ5IHNwYWNlcyB1bmxlc3MgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0c1xuXHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBbIG5hbWUgXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKFwia2V5XCIsIFwidmFsXCIpIHNpZ25hdHVyZSxcblx0XHRcdFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXG5cdFx0XHRcdC8vIGJvdGggcGxhaW4ga2V5IGFuZCBjYW1lbENhc2Uga2V5LiAjMTI3ODZcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXG5cdFx0XHRcdG5hbWUgPSBuYW1lLmNvbmNhdCggalF1ZXJ5Lm1hcCggbmFtZSwgalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgdGhpc0NhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0IGluIHRoZSBjYWNoZSwgd2Ugd2FudCB0byBjb250aW51ZVxuXHRcdFx0Ly8gYW5kIGxldCB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZiBnZXQgZGVzdHJveWVkXG5cdFx0XHRpZiAoIHB2dCA/ICFpc0VtcHR5RGF0YU9iamVjdCggdGhpc0NhY2hlICkgOiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHRoaXNDYWNoZSApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdGlmICggIXB2dCApIHtcblx0XHRkZWxldGUgY2FjaGVbIGlkIF0uZGF0YTtcblxuXHRcdC8vIERvbid0IGRlc3Ryb3kgdGhlIHBhcmVudCBjYWNoZSB1bmxlc3MgdGhlIGludGVybmFsIGRhdGEgb2JqZWN0XG5cdFx0Ly8gaGFkIGJlZW4gdGhlIG9ubHkgdGhpbmcgbGVmdCBpbiBpdFxuXHRcdGlmICggIWlzRW1wdHlEYXRhT2JqZWN0KCBjYWNoZVsgaWQgXSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdC8vIERlc3Ryb3kgdGhlIGNhY2hlXG5cdGlmICggaXNOb2RlICkge1xuXHRcdGpRdWVyeS5jbGVhbkRhdGEoIFsgZWxlbSBdLCB0cnVlICk7XG5cblx0Ly8gVXNlIGRlbGV0ZSB3aGVuIHN1cHBvcnRlZCBmb3IgZXhwYW5kb3Mgb3IgYGNhY2hlYCBpcyBub3QgYSB3aW5kb3cgcGVyIGlzV2luZG93ICgjMTAwODApXG5cdC8qIGpzaGludCBlcWVxZXE6IGZhbHNlICovXG5cdH0gZWxzZSBpZiAoIHN1cHBvcnQuZGVsZXRlRXhwYW5kbyB8fCBjYWNoZSAhPSBjYWNoZS53aW5kb3cgKSB7XG5cdFx0LyoganNoaW50IGVxZXFlcTogdHJ1ZSAqL1xuXHRcdGRlbGV0ZSBjYWNoZVsgaWQgXTtcblxuXHQvLyBXaGVuIGFsbCBlbHNlIGZhaWxzLCB1bmRlZmluZWRcblx0fSBlbHNlIHtcblx0XHRjYWNoZVsgaWQgXSA9IHVuZGVmaW5lZDtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGNhY2hlOiB7fSxcblxuXHQvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIChzcGFjZS1zdWZmaXhlZCB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlIGNvbGxpc2lvbnMpXG5cdC8vIHRocm93IHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMgaWYgeW91IGF0dGVtcHQgdG8gc2V0IGV4cGFuZG8gcHJvcGVydGllc1xuXHRub0RhdGE6IHtcblx0XHRcImFwcGxldCBcIjogdHJ1ZSxcblx0XHRcImVtYmVkIFwiOiB0cnVlLFxuXG5cdFx0Ly8gLi4uYnV0IEZsYXNoIG9iamVjdHMgKHdoaWNoIGhhdmUgdGhpcyBjbGFzc2lkKSAqY2FuKiBoYW5kbGUgZXhwYW5kb3Ncblx0XHRcIm9iamVjdCBcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIlxuXHR9LFxuXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGVsZW0gPSBlbGVtLm5vZGVUeXBlID8galF1ZXJ5LmNhY2hlWyBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdIF0gOiBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuXHRcdHJldHVybiAhIWVsZW0gJiYgIWlzRW1wdHlEYXRhT2JqZWN0KCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBpbnRlcm5hbFJlbW92ZURhdGEoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCB0cnVlICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBpbnRlcm5hbFJlbW92ZURhdGEoIGVsZW0sIG5hbWUsIHRydWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBTcGVjaWFsIGV4cGVjdGlvbnMgb2YgLmRhdGEgYmFzaWNhbGx5IHRod2FydCBqUXVlcnkuYWNjZXNzLFxuXHRcdC8vIHNvIGltcGxlbWVudCB0aGUgcmVsZXZhbnQgYmVoYXZpb3Igb3Vyc2VsdmVzXG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID9cblxuXHRcdFx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kYXRhKCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICkgOlxuXG5cdFx0XHQvLyBHZXRzIG9uZSB2YWx1ZVxuXHRcdFx0Ly8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XG5cdFx0XHRlbGVtID8gZGF0YUF0dHIoIGVsZW0sIGtleSwgalF1ZXJ5LmRhdGEoIGVsZW0sIGtleSApICkgOiB1bmRlZmluZWQ7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyBjb25zdW1wdGlvbiAtIGdlbmVyYXRlcyBhIHF1ZXVlSG9va3Mgb2JqZWN0LFxuXHQvLyBvciByZXR1cm5zIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4galF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXkgKSB8fCBqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArIFwicXVldWVcIiApO1xuXHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIGtleSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBlbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGpRdWVyeS5fZGF0YSggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXG5cdHN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggc2hyaW5rV3JhcEJsb2Nrc1ZhbCAhPSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNocmlua1dyYXBCbG9ja3NWYWw7XG5cdFx0fVxuXG5cdFx0Ly8gV2lsbCBiZSBjaGFuZ2VkIGxhdGVyIGlmIG5lZWRlZC5cblx0XHRzaHJpbmtXcmFwQmxvY2tzVmFsID0gZmFsc2U7XG5cblx0XHQvLyBNaW5pZmllZDogdmFyIGIsYyxkXG5cdFx0dmFyIGRpdiwgYm9keSwgY29udGFpbmVyO1xuXG5cdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdFx0aWYgKCAhYm9keSB8fCAhYm9keS5zdHlsZSApIHtcblxuXHRcdFx0Ly8gVGVzdCBmaXJlZCB0b28gZWFybHkgb3IgaW4gYW4gdW5zdXBwb3J0ZWQgZW52aXJvbm1lbnQsIGV4aXQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXBcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweFwiO1xuXHRcdGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFNlxuXHRcdC8vIENoZWNrIGlmIGVsZW1lbnRzIHdpdGggbGF5b3V0IHNocmluay13cmFwIHRoZWlyIGNoaWxkcmVuXG5cdFx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cblx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXJcblx0XHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7XCIgK1xuXHRcdFx0XHRcInBhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjFcIjtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICkuc3R5bGUud2lkdGggPSBcIjVweFwiO1xuXHRcdFx0c2hyaW5rV3JhcEJsb2Nrc1ZhbCA9IGRpdi5vZmZzZXRXaWR0aCAhPT0gMztcblx0XHR9XG5cblx0XHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHJldHVybiBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXHR9O1xuXG59ICkoKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHxcblx0XHRcdCFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0d2Vlbi5jdXIoKTsgfSA6XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTsgfSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRyYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW5ndGggPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW1xcdzotXSspLyApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxudmFyIHJsZWFkaW5nV2hpdGVzcGFjZSA9ICggL15cXHMrLyApO1xuXG52YXIgbm9kZU5hbWVzID0gXCJhYmJyfGFydGljbGV8YXNpZGV8YXVkaW98YmRpfGNhbnZhc3xkYXRhfGRhdGFsaXN0fFwiICtcblx0XHRcImRldGFpbHN8ZGlhbG9nfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnxoZWFkZXJ8aGdyb3VwfG1haW58XCIgK1xuXHRcdFwibWFya3xtZXRlcnxuYXZ8b3V0cHV0fHBpY3R1cmV8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRlbXBsYXRlfHRpbWV8dmlkZW9cIjtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSB7XG5cdHZhciBsaXN0ID0gbm9kZU5hbWVzLnNwbGl0KCBcInxcIiApLFxuXHRcdHNhZmVGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdGlmICggc2FmZUZyYWcuY3JlYXRlRWxlbWVudCApIHtcblx0XHR3aGlsZSAoIGxpc3QubGVuZ3RoICkge1xuXHRcdFx0c2FmZUZyYWcuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0bGlzdC5wb3AoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHNhZmVGcmFnO1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTZXR1cFxuXHRkaXYuaW5uZXJIVE1MID0gXCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIjtcblxuXHQvLyBJRSBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gLmlubmVySFRNTCBpcyB1c2VkXG5cdHN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgPSBkaXYuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMztcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuXHQvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXG5cdHN1cHBvcnQudGJvZHkgPSAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKS5sZW5ndGg7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG5cdC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcblx0c3VwcG9ydC5odG1sU2VyaWFsaXplID0gISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwibGlua1wiICkubGVuZ3RoO1xuXG5cdC8vIE1ha2VzIHN1cmUgY2xvbmluZyBhbiBodG1sNSBlbGVtZW50IGRvZXMgbm90IGNhdXNlIHByb2JsZW1zXG5cdC8vIFdoZXJlIG91dGVySFRNTCBpcyB1bmRlZmluZWQsIHRoaXMgc3RpbGwgd29ya3Ncblx0c3VwcG9ydC5odG1sNUNsb25lID1cblx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm5hdlwiICkuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSBcIjw6bmF2PjwvOm5hdj5cIjtcblxuXHQvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuXHQvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXHRpbnB1dC5jaGVja2VkID0gdHJ1ZTtcblx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdHN1cHBvcnQuYXBwZW5kQ2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0Ly8gU3VwcG9ydDogSUU2LUlFMTErXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gIzExMjE3IC0gV2ViS2l0IGxvc2VzIGNoZWNrIHdoZW4gdGhlIG5hbWUgaXMgYWZ0ZXIgdGhlIGNoZWNrZWQgYXR0cmlidXRlXG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDUuMSwgaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXG5cdC8vIG9sZCBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gQ2xvbmVkIGVsZW1lbnRzIGtlZXAgYXR0YWNoRXZlbnQgaGFuZGxlcnMsIHdlIHVzZSBhZGRFdmVudExpc3RlbmVyIG9uIElFOStcblx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSAhIWRpdi5hZGRFdmVudExpc3RlbmVyO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gU2luY2UgYXR0cmlidXRlcyBhbmQgcHJvcGVydGllcyBhcmUgdGhlIHNhbWUgaW4gSUUsXG5cdC8vIGNsZWFuRGF0YSBtdXN0IHNldCBwcm9wZXJ0aWVzIHRvIHVuZGVmaW5lZCByYXRoZXIgdGhhbiB1c2UgcmVtb3ZlQXR0cmlidXRlXG5cdGRpdlsgalF1ZXJ5LmV4cGFuZG8gXSA9IDE7XG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9ICFkaXYuZ2V0QXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblx0bGVnZW5kOiBbIDEsIFwiPGZpZWxkc2V0PlwiLCBcIjwvZmllbGRzZXQ+XCIgXSxcblx0YXJlYTogWyAxLCBcIjxtYXA+XCIsIFwiPC9tYXA+XCIgXSxcblxuXHQvLyBTdXBwb3J0OiBJRThcblx0cGFyYW06IFsgMSwgXCI8b2JqZWN0PlwiLCBcIjwvb2JqZWN0PlwiIF0sXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0Ly8gSUU2LTggY2FuJ3Qgc2VyaWFsaXplIGxpbmssIHNjcmlwdCwgc3R5bGUsIG9yIGFueSBodG1sNSAoTm9TY29wZSkgdGFncyxcblx0Ly8gdW5sZXNzIHdyYXBwZWQgaW4gYSBkaXYgd2l0aCBub24tYnJlYWtpbmcgY2hhcmFjdGVycyBpbiBmcm9udCBvZiBpdC5cblx0X2RlZmF1bHQ6IHN1cHBvcnQuaHRtbFNlcmlhbGl6ZSA/IFsgMCwgXCJcIiwgXCJcIiBdIDogWyAxLCBcIlg8ZGl2PlwiLCBcIjwvZGl2PlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOC1JRTlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXHR2YXIgZWxlbXMsIGVsZW0sXG5cdFx0aSA9IDAsXG5cdFx0Zm91bmQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblxuXHRpZiAoICFmb3VuZCApIHtcblx0XHRmb3IgKCBmb3VuZCA9IFtdLCBlbGVtcyA9IGNvbnRleHQuY2hpbGROb2RlcyB8fCBjb250ZXh0O1xuXHRcdFx0KCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7XG5cdFx0XHRpKytcblx0XHQpIHtcblx0XHRcdGlmICggIXRhZyB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIHRhZyApICkge1xuXHRcdFx0XHRmb3VuZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIGZvdW5kLCBnZXRBbGwoIGVsZW0sIHRhZyApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCBmb3VuZCApIDpcblx0XHRmb3VuZDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0aSA9IDA7XG5cdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRqUXVlcnkuX2RhdGEoXG5cdFx0XHRlbGVtLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgalF1ZXJ5Ll9kYXRhKCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cnRib2R5ID0gLzx0Ym9keS9pO1xuXG5mdW5jdGlvbiBmaXhEZWZhdWx0Q2hlY2tlZCggZWxlbSApIHtcblx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbGVtLnR5cGUgKSApIHtcblx0XHRlbGVtLmRlZmF1bHRDaGVja2VkID0gZWxlbS5jaGVja2VkO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBqLCBlbGVtLCBjb250YWlucyxcblx0XHR0bXAsIHRhZywgdGJvZHksIHdyYXAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aCxcblxuXHRcdC8vIEVuc3VyZSBhIHNhZmUgZnJhZ21lbnRcblx0XHRzYWZlID0gY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICksXG5cblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBzYWZlLmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFudWFsbHkgYWRkIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGJ5IElFXG5cdFx0XHRcdGlmICggIXN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgJiYgcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyggZWxlbSApWyAwIF0gKSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIElFJ3MgYXV0b2luc2VydGVkIDx0Ym9keT4gZnJvbSB0YWJsZSBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC50Ym9keSApIHtcblxuXHRcdFx0XHRcdC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cblx0XHRcdFx0XHRlbGVtID0gdGFnID09PSBcInRhYmxlXCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuXHRcdFx0XHRcdFx0dG1wLmZpcnN0Q2hpbGQgOlxuXG5cdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdHdyYXBbIDEgXSA9PT0gXCI8dGFibGU+XCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuXHRcdFx0XHRcdFx0XHR0bXAgOlxuXHRcdFx0XHRcdFx0XHQwO1xuXG5cdFx0XHRcdFx0aiA9IGVsZW0gJiYgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCAoIHRib2R5ID0gZWxlbS5jaGlsZE5vZGVzWyBqIF0gKSwgXCJ0Ym9keVwiICkgJiZcblx0XHRcdFx0XHRcdFx0IXRib2R5LmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIHRib2R5ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBGaXggIzEyMzkyIGZvciBXZWJLaXQgYW5kIElFID4gOVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0XHRcdC8vIEZpeCAjMTIzOTIgZm9yIG9sZElFXG5cdFx0XHRcdHdoaWxlICggdG1wLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdFx0dG1wLnJlbW92ZUNoaWxkKCB0bXAuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgZm9yIHByb3BlciBjbGVhbnVwXG5cdFx0XHRcdHRtcCA9IHNhZmUubGFzdENoaWxkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEZpeCAjMTEzNTY6IENsZWFyIGVsZW1lbnRzIGZyb20gZnJhZ21lbnRcblx0aWYgKCB0bXAgKSB7XG5cdFx0c2FmZS5yZW1vdmVDaGlsZCggdG1wICk7XG5cdH1cblxuXHQvLyBSZXNldCBkZWZhdWx0Q2hlY2tlZCBmb3IgYW55IHJhZGlvcyBhbmQgY2hlY2tib3hlc1xuXHQvLyBhYm91dCB0byBiZSBhcHBlbmRlZCB0byB0aGUgRE9NIGluIElFIDYvNyAoIzgwNjApXG5cdGlmICggIXN1cHBvcnQuYXBwZW5kQ2hlY2tlZCApIHtcblx0XHRqUXVlcnkuZ3JlcCggZ2V0QWxsKCBub2RlcywgXCJpbnB1dFwiICksIGZpeERlZmF1bHRDaGVja2VkICk7XG5cdH1cblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIHNhZmUuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dG1wID0gbnVsbDtcblxuXHRyZXR1cm4gc2FmZTtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaSwgZXZlbnROYW1lLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5IChsYWNrIHN1Ym1pdC9jaGFuZ2UgYnViYmxlKSwgRmlyZWZveCAobGFjayBmb2N1cyhpbiB8IG91dCkgZXZlbnRzKVxuXHRmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCBjaGFuZ2U6IHRydWUsIGZvY3VzaW46IHRydWUgfSApIHtcblx0XHRldmVudE5hbWUgPSBcIm9uXCIgKyBpO1xuXG5cdFx0aWYgKCAhKCBzdXBwb3J0WyBpIF0gPSBldmVudE5hbWUgaW4gd2luZG93ICkgKSB7XG5cblx0XHRcdC8vIEJld2FyZSBvZiBDU1AgcmVzdHJpY3Rpb25zIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9TZWN1cml0eS9DU1ApXG5cdFx0XHRkaXYuc2V0QXR0cmlidXRlKCBldmVudE5hbWUsIFwidFwiICk7XG5cdFx0XHRzdXBwb3J0WyBpIF0gPSBkaXYuYXR0cmlidXRlc1sgZXZlbnROYW1lIF0uZXhwYW5kbyA9PT0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0ZGl2ID0gbnVsbDtcbn0gKSgpO1xuXG5cbnZhciByZm9ybUVsZW1zID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLFxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRyZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXHRcdHZhciB0bXAsIGV2ZW50cywgdCwgaGFuZGxlT2JqSW4sXG5cdFx0XHRzcGVjaWFsLCBldmVudEhhbmRsZSwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBqUXVlcnkuX2RhdGEoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHQoICFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSApID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGV2ZW50SGFuZGxlLmVsZW0sIGFyZ3VtZW50cyApIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZm4gdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrXG5cdFx0XHQvLyB3aXRoIElFIG5vbi1uYXRpdmUgZXZlbnRzXG5cdFx0XHRldmVudEhhbmRsZS5lbGVtID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdC8vIEJpbmQgdGhlIGdsb2JhbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdGVsZW0uYXR0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gTnVsbGlmeSBlbGVtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG5cdFx0ZWxlbSA9IG51bGw7XG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cdFx0dmFyIGosIGhhbmRsZU9iaiwgdG1wLFxuXHRcdFx0b3JpZ0NvdW50LCB0LCBldmVudHMsXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSxcblx0XHRcdG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBqUXVlcnkuaGFzRGF0YSggZWxlbSApICYmIGpRdWVyeS5fZGF0YSggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cblx0XHRcdC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XG5cdFx0XHQvLyBzbyB1c2UgaXQgaW5zdGVhZCBvZiBkZWxldGVcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblx0XHR2YXIgaGFuZGxlLCBvbnR5cGUsIGN1cixcblx0XHRcdGJ1YmJsZVR5cGUsIHNwZWNpYWwsIHRtcCwgaSxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcblxuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2Vcblx0XHRcdFx0KSAmJiBhY2NlcHREYXRhKCBlbGVtIClcblx0XHRcdCkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gQ2FuJ3QgdXNlIGFuIC5pc0Z1bmN0aW9uKCkgY2hlY2sgaGVyZSBiZWNhdXNlIElFNi83IGZhaWxzIHRoYXQgdGVzdC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBlbGVtWyB0eXBlIF0gJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwjMTI1MTgpXG5cdFx0XHRcdFx0XHQvLyBvbmx5IHJlcHJvZHVjaWJsZSBvbiB3aW5YUCBJRTggbmF0aXZlLCBub3QgSUU5IGluIElFOCBtb2RlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGpRdWVyeS5fZGF0YSggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0LyoganNoaW50IGVxZXFlcTogZmFsc2UgKi9cblx0XHRcdGZvciAoIDsgY3VyICE9IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cdFx0XHRcdC8qIGpzaGludCBlcWVxZXE6IHRydWUgKi9cblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBGaXggdGFyZ2V0IHByb3BlcnR5ICgjMTkyNSlcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYtOCtcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzLCBtZXRhS2V5PT1mYWxzZSBpZiBpdCdzIHVuZGVmaW5lZCAoIzMzNjgsICMxMTMyOClcblx0XHRldmVudC5tZXRhS2V5ID0gISFldmVudC5tZXRhS2V5O1xuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBcIiArXG5cdFx0XHRcInBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBib2R5LCBldmVudERvYywgZG9jLFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b24sXG5cdFx0XHRcdGZyb21FbGVtZW50ID0gb3JpZ2luYWwuZnJvbUVsZW1lbnQ7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcblx0XHRcdFx0ZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgP1xuXHRcdFx0XHRcdG9yaWdpbmFsLnRvRWxlbWVudCA6XG5cdFx0XHRcdFx0ZnJvbUVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBlcnJvciBvbiBmb2N1cyB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsICMxMjUxOCksXG5cdFx0XHRcdFx0XHQvLyBsZXQgLnRyaWdnZXIoKSBydW4gdGhlIGhhbmRsZXJzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICYmIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblxuXHRcdFx0XHQvLyBQcmV2aW91c2x5LCBgb3JpZ2luYWxFdmVudDoge31gIHdhcyBzZXQgaGVyZSwgc28gc3RvcFByb3BhZ2F0aW9uIGNhbGxcblx0XHRcdFx0Ly8gd291bGQgbm90IGJlIHRyaWdnZXJlZCBvbiBkb25vciBldmVudCwgc2luY2UgaW4gb3VyIG93blxuXHRcdFx0XHQvLyBqUXVlcnkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGZ1bmN0aW9uIHdlIGhhZCBhIGNoZWNrIGZvciBleGlzdGVuY2Ugb2Zcblx0XHRcdFx0Ly8gb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gbWV0aG9kLCBzbywgY29uc2VxdWVudGx5IGl0IHdvdWxkIGJlIGEgbm9vcC5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gR3VhcmQgZm9yIHNpbXVsYXRlZCBldmVudHMgd2FzIG1vdmVkIHRvIGpRdWVyeS5ldmVudC5zdG9wUHJvcGFnYXRpb24gZnVuY3Rpb25cblx0XHRcdFx0Ly8gc2luY2UgYG9yaWdpbmFsRXZlbnRgIHNob3VsZCBwb2ludCB0byB0aGUgb3JpZ2luYWwgZXZlbnQgZm9yIHRoZVxuXHRcdFx0XHQvLyBjb25zdGFuY3kgd2l0aCBvdGhlciBldmVudHMgYW5kIGZvciBtb3JlIGZvY3VzZWQgbG9naWNcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblxuXHRcdGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyID9cblx0ZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHRcdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0XHR9XG5cdH0gOlxuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdHZhciBuYW1lID0gXCJvblwiICsgdHlwZTtcblxuXHRcdGlmICggZWxlbS5kZXRhY2hFdmVudCApIHtcblxuXHRcdFx0Ly8gIzg1NDUsICM3MDU0LCBwcmV2ZW50aW5nIG1lbW9yeSBsZWFrcyBmb3IgY3VzdG9tIGV2ZW50cyBpbiBJRTYtOFxuXHRcdFx0Ly8gZGV0YWNoRXZlbnQgbmVlZGVkIHByb3BlcnR5IG9uIGVsZW1lbnQsIGJ5IG5hbWUgb2YgdGhhdCBldmVudCxcblx0XHRcdC8vIHRvIHByb3Blcmx5IGV4cG9zZSBpdCB0byBHQ1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbVsgbmFtZSBdID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRlbGVtWyBuYW1lIF0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLmRldGFjaEV2ZW50KCBuYW1lLCBoYW5kbGUgKTtcblx0XHR9XG5cdH07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPCA5LCBBbmRyb2lkIDwgNC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cdFx0aWYgKCAhZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMsIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIE90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoICFlIHx8IHRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5zdG9wUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gU2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIHRydWVcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxuLy8gSUUgc3VibWl0IGRlbGVnYXRpb25cbmlmICggIXN1cHBvcnQuc3VibWl0ICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLnN1Ym1pdCA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMYXp5LWFkZCBhIHN1Ym1pdCBoYW5kbGVyIHdoZW4gYSBkZXNjZW5kYW50IGZvcm0gbWF5IHBvdGVudGlhbGx5IGJlIHN1Ym1pdHRlZFxuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fc3VibWl0IGtleXByZXNzLl9zdWJtaXRcIiwgZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCxcblx0XHRcdFx0XHRmb3JtID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSA/XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHRcdFx0Ly8gV2UgdXNlIGpRdWVyeS5wcm9wIGluc3RlYWQgb2YgZWxlbS5mb3JtXG5cdFx0XHRcdFx0XHQvLyB0byBhbGxvdyBmaXhpbmcgdGhlIElFOCBkZWxlZ2F0ZWQgc3VibWl0IGlzc3VlIChnaC0yMzMyKVxuXHRcdFx0XHRcdFx0Ly8gYnkgM3JkIHBhcnR5IHBvbHlmaWxscy93b3JrYXJvdW5kcy5cblx0XHRcdFx0XHRcdGpRdWVyeS5wcm9wKCBlbGVtLCBcImZvcm1cIiApIDpcblx0XHRcdFx0XHRcdHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIGZvcm0gJiYgIWpRdWVyeS5fZGF0YSggZm9ybSwgXCJzdWJtaXRcIiApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGZvcm0sIFwic3VibWl0Ll9zdWJtaXRcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQuX3N1Ym1pdEJ1YmJsZSA9IHRydWU7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZm9ybSwgXCJzdWJtaXRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UgZG9uJ3QgbmVlZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdH0sXG5cblx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIGV2ZW50Ll9zdWJtaXRCdWJibGUgKSB7XG5cdFx0XHRcdGRlbGV0ZSBldmVudC5fc3VibWl0QnViYmxlO1xuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkZWxlZ2F0ZWQgaGFuZGxlcnM7IGNsZWFuRGF0YSBldmVudHVhbGx5IHJlYXBzIHN1Ym1pdCBoYW5kbGVycyBhdHRhY2hlZCBhYm92ZVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX3N1Ym1pdFwiICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4XG5pZiAoICFzdXBwb3J0LmNoYW5nZSApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG5cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICkgKSB7XG5cblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBmaXJlIGNoYW5nZSBvbiBhIGNoZWNrL3JhZGlvIHVudGlsIGJsdXI7IHRyaWdnZXIgaXQgb24gY2xpY2tcblx0XHRcdFx0Ly8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuXG5cdFx0XHRcdC8vIFRoaXMgc3RpbGwgZmlyZXMgb25jaGFuZ2UgYSBzZWNvbmQgdGltZSBmb3IgY2hlY2svcmFkaW8gYWZ0ZXIgYmx1ci5cblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZSA9PT0gXCJjaGVja2VkXCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5fanVzdENoYW5nZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdENoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQWxsb3cgdHJpZ2dlcmVkLCBzaW11bGF0ZWQgY2hhbmdlIGV2ZW50cyAoIzExNTAwKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLCBldmVudCApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlbGVnYXRlZCBldmVudDsgbGF6eS1hZGQgYSBjaGFuZ2UgaGFuZGxlciBvbiBkZXNjZW5kYW50IGlucHV0c1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VcIiApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzU2ltdWxhdGVkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwiY2hhbmdlXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBlbGVtID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHQvLyBTd2FsbG93IG5hdGl2ZSBjaGFuZ2UgZXZlbnRzIGZyb20gY2hlY2tib3gvcmFkaW8sIHdlIGFscmVhZHkgdHJpZ2dlcmVkIHRoZW0gYWJvdmVcblx0XHRcdGlmICggdGhpcyAhPT0gZWxlbSB8fCBldmVudC5pc1NpbXVsYXRlZCB8fCBldmVudC5pc1RyaWdnZXIgfHxcblx0XHRcdFx0KCBlbGVtLnR5cGUgIT09IFwicmFkaW9cIiAmJiBlbGVtLnR5cGUgIT09IFwiY2hlY2tib3hcIiApICkge1xuXG5cdFx0XHRcdHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xuXG5cdFx0XHRyZXR1cm4gIXJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBqUXVlcnkuX2RhdGEoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGpRdWVyeS5fZGF0YSggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGRvYywgZml4ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG52YXIgcmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLFxuXHRybm9zaGltY2FjaGUgPSBuZXcgUmVnRXhwKCBcIjwoPzpcIiArIG5vZGVOYW1lcyArIFwiKVtcXFxccy8+XVwiLCBcImlcIiApLFxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Oi1dKylbXj5dKilcXC8+L2dpLFxuXG5cdC8vIFN1cHBvcnQ6IElFIDEwLTExLCBFZGdlIDEwMjQwK1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cdHNhZmVGcmFnbWVudCA9IGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSxcblx0ZnJhZ21lbnREaXYgPSBzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggalF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHR5cGUsIGksIGwsXG5cdFx0b2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG5cdFx0Y3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxuXHRcdGV2ZW50cyA9IG9sZERhdGEuZXZlbnRzO1xuXG5cdGlmICggZXZlbnRzICkge1xuXHRcdGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcblx0XHRjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG5cdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIG1ha2UgdGhlIGNsb25lZCBwdWJsaWMgZGF0YSBvYmplY3QgYSBjb3B5IGZyb20gdGhlIG9yaWdpbmFsXG5cdGlmICggY3VyRGF0YS5kYXRhICkge1xuXHRcdGN1ckRhdGEuZGF0YSA9IGpRdWVyeS5leHRlbmQoIHt9LCBjdXJEYXRhLmRhdGEgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBmaXhDbG9uZU5vZGVJc3N1ZXMoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lLCBlLCBkYXRhO1xuXG5cdC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIElFNi04IGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuXHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiBkZXN0WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QgKTtcblxuXHRcdGZvciAoIGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGRlc3QsIGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vXG5cdFx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XG5cdH1cblxuXHQvLyBJRSBibGFua3MgY29udGVudHMgd2hlbiBjbG9uaW5nIHNjcmlwdHMsIGFuZCB0cmllcyB0byBldmFsdWF0ZSBuZXdseS1zZXQgdGV4dFxuXHRpZiAoIG5vZGVOYW1lID09PSBcInNjcmlwdFwiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7XG5cdFx0ZGlzYWJsZVNjcmlwdCggZGVzdCApLnRleHQgPSBzcmMudGV4dDtcblx0XHRyZXN0b3JlU2NyaXB0KCBkZXN0ICk7XG5cblx0Ly8gSUU2LTEwIGltcHJvcGVybHkgY2xvbmVzIGNoaWxkcmVuIG9mIG9iamVjdCBlbGVtZW50cyB1c2luZyBjbGFzc2lkLlxuXHQvLyBJRTEwIHRocm93cyBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciBpZiBwYXJlbnQgaXMgbnVsbCwgIzEyMTMyLlxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRpZiAoIGRlc3QucGFyZW50Tm9kZSApIHtcblx0XHRcdGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcblx0XHR9XG5cblx0XHQvLyBUaGlzIHBhdGggYXBwZWFycyB1bmF2b2lkYWJsZSBmb3IgSUU5LiBXaGVuIGNsb25pbmcgYW4gb2JqZWN0XG5cdFx0Ly8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG5cdFx0Ly8gSWYgdGhlIHNyYyBoYXMgaW5uZXJIVE1MIGFuZCB0aGUgZGVzdGluYXRpb24gZG9lcyBub3QsXG5cdFx0Ly8gY29weSB0aGUgc3JjLmlubmVySFRNTCBpbnRvIHRoZSBkZXN0LmlubmVySFRNTC4gIzEwMzI0XG5cdFx0aWYgKCBzdXBwb3J0Lmh0bWw1Q2xvbmUgJiYgKCBzcmMuaW5uZXJIVE1MICYmICFqUXVlcnkudHJpbSggZGVzdC5pbm5lckhUTUwgKSApICkge1xuXHRcdFx0ZGVzdC5pbm5lckhUTUwgPSBzcmMuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cblx0XHQvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94XG5cdFx0Ly8gb3IgcmFkaW8gYnV0dG9uLiBXb3JzZSwgSUU2LTcgZmFpbCB0byBnaXZlIHRoZSBjbG9uZWQgZWxlbWVudFxuXHRcdC8vIGEgY2hlY2tlZCBhcHBlYXJhbmNlIGlmIHRoZSBkZWZhdWx0Q2hlY2tlZCB2YWx1ZSBpc24ndCBhbHNvIHNldFxuXG5cdFx0ZGVzdC5kZWZhdWx0Q2hlY2tlZCA9IGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdFx0Ly8gSUU2LTcgZ2V0IGNvbmZ1c2VkIGFuZCBlbmQgdXAgc2V0dGluZyB0aGUgdmFsdWUgb2YgYSBjbG9uZWRcblx0XHQvLyBjaGVja2JveC9yYWRpbyBidXR0b24gdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgXCJvblwiXG5cdFx0aWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XG5cdFx0XHRkZXN0LnZhbHVlID0gc3JjLnZhbHVlO1xuXHRcdH1cblxuXHQvLyBJRTYtOCBmYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZFxuXHQvLyBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiApIHtcblx0XHRkZXN0LmRlZmF1bHRTZWxlY3RlZCA9IGRlc3Quc2VsZWN0ZWQgPSBzcmMuZGVmYXVsdFNlbGVjdGVkO1xuXG5cdC8vIElFNi04IGZhaWxzIHRvIHNldCB0aGUgZGVmYXVsdFZhbHVlIHRvIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW5cblx0Ly8gY2xvbmluZyBvdGhlciB0eXBlcyBvZiBpbnB1dCBmaWVsZHNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmaXJzdCwgbm9kZSwgaGFzU2NyaXB0cyxcblx0XHRzY3JpcHRzLCBkb2MsIGZyYWdtZW50LFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWpRdWVyeS5fZGF0YSggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKFxuXHRcdFx0XHRcdFx0XHRcdCggbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lckhUTUwgfHwgXCJcIiApXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiIClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRml4ICMxMTgwOTogQXZvaWQgbGVha2luZyBtZW1vcnlcblx0XHRcdGZyYWdtZW50ID0gZmlyc3QgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0ZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblxuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgZGVzdEVsZW1lbnRzLCBub2RlLCBjbG9uZSwgaSwgc3JjRWxlbWVudHMsXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0aWYgKCBzdXBwb3J0Lmh0bWw1Q2xvbmUgfHwgalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgfHxcblx0XHRcdCFybm9zaGltY2FjaGUudGVzdCggXCI8XCIgKyBlbGVtLm5vZGVOYW1lICsgXCI+XCIgKSApIHtcblxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApO1xuXG5cdFx0Ly8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFnbWVudERpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcblx0XHRcdGZyYWdtZW50RGl2LnJlbW92ZUNoaWxkKCBjbG9uZSA9IGZyYWdtZW50RGl2LmZpcnN0Q2hpbGQgKTtcblx0XHR9XG5cblx0XHRpZiAoICggIXN1cHBvcnQubm9DbG9uZUV2ZW50IHx8ICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICkgJiZcblx0XHRcdFx0KCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiYgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Ly8gRml4IGFsbCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdFx0Zm9yICggaSA9IDA7ICggbm9kZSA9IHNyY0VsZW1lbnRzWyBpIF0gKSAhPSBudWxsOyArK2kgKSB7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIGRlc3RpbmF0aW9uIG5vZGUgaXMgbm90IG51bGw7IEZpeGVzICM5NTg3XG5cdFx0XHRcdGlmICggZGVzdEVsZW1lbnRzWyBpIF0gKSB7XG5cdFx0XHRcdFx0Zml4Q2xvbmVOb2RlSXNzdWVzKCBub2RlLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7ICggbm9kZSA9IHNyY0VsZW1lbnRzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIG5vZGUsIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdGRlc3RFbGVtZW50cyA9IHNyY0VsZW1lbnRzID0gbm9kZSA9IG51bGw7XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMsIC8qIGludGVybmFsICovIGZvcmNlQWNjZXB0RGF0YSApIHtcblx0XHR2YXIgZWxlbSwgdHlwZSwgaWQsIGRhdGEsXG5cdFx0XHRpID0gMCxcblx0XHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cdFx0XHRjYWNoZSA9IGpRdWVyeS5jYWNoZSxcblx0XHRcdGF0dHJpYnV0ZXMgPSBzdXBwb3J0LmF0dHJpYnV0ZXMsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWw7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGZvcmNlQWNjZXB0RGF0YSB8fCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuXHRcdFx0XHRkYXRhID0gaWQgJiYgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBjYWNoZSBvbmx5IGlmIGl0IHdhcyBub3QgYWxyZWFkeSByZW1vdmVkIGJ5IGpRdWVyeS5ldmVudC5yZW1vdmVcblx0XHRcdFx0XHRpZiAoIGNhY2hlWyBpZCBdICkge1xuXG5cdFx0XHRcdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdFx0XHRcdC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2Rlc1xuXHRcdFx0XHRcdFx0Ly8gSUUgY3JlYXRlcyBleHBhbmRvIGF0dHJpYnV0ZXMgYWxvbmcgd2l0aCB0aGUgcHJvcGVydHlcblx0XHRcdFx0XHRcdC8vIElFIGRvZXMgbm90IGhhdmUgYSByZW1vdmVBdHRyaWJ1dGUgZnVuY3Rpb24gb24gRG9jdW1lbnQgbm9kZXNcblx0XHRcdFx0XHRcdGlmICggIWF0dHJpYnV0ZXMgJiYgdHlwZW9mIGVsZW0ucmVtb3ZlQXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggaW50ZXJuYWxLZXkgKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDdcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1bIGludGVybmFsS2V5IF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGRlbGV0ZWRJZHMucHVzaCggaWQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIEtlZXAgZG9tTWFuaXAgZXhwb3NlZCB1bnRpbCAzLjAgKGdoLTIyMjUpXG5cdGRvbU1hbmlwOiBkb21NYW5pcCxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoXG5cdFx0XHRcdFx0KCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKS5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKVxuXHRcdFx0XHQpO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgc2VsZWN0LCBlbnN1cmUgdGhhdCBpdCBkaXNwbGF5cyBlbXB0eSAoIzEyMzM2KVxuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0aWYgKCBlbGVtLm9wdGlvbnMgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInNlbGVjdFwiICkgKSB7XG5cdFx0XHRcdGVsZW0ub3B0aW9ucy5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRcdFx0XHRlbGVtLmlubmVySFRNTC5yZXBsYWNlKCByaW5saW5lalF1ZXJ5LCBcIlwiICkgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCggc3VwcG9ydC5odG1sU2VyaWFsaXplIHx8ICFybm9zaGltY2FjaGUudGVzdCggdmFsdWUgKSAgKSAmJlxuXHRcdFx0XHQoIHN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgIXJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCB2YWx1ZSApICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDE7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gTW9kZXJuIGJyb3dzZXJzIGNhbiBhcHBseSBqUXVlcnkgY29sbGVjdGlvbnMgYXMgYXJyYXlzLCBidXQgb2xkSUUgbmVlZHMgYSAuZ2V0KClcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIFdlIGhhdmUgdG8gcHJlLWRlZmluZSB0aGVzZSB2YWx1ZXMgZm9yIEZGICgjMTAyMjcpXG5cdFx0SFRNTDogXCJibG9ja1wiLFxuXHRcdEJPRFk6IFwiYmxvY2tcIlxuXHR9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG5cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKCBpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApIClcblx0XHRcdFx0LmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gKCBpZnJhbWVbIDAgXS5jb250ZW50V2luZG93IHx8IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudCApLmRvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsLCByZWxpYWJsZU1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcImZsb2F0OmxlZnQ7b3BhY2l0eTouNVwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gTWFrZSBzdXJlIHRoYXQgZWxlbWVudCBvcGFjaXR5IGV4aXN0cyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXIpXG5cdHN1cHBvcnQub3BhY2l0eSA9IGRpdi5zdHlsZS5vcGFjaXR5ID09PSBcIjAuNVwiO1xuXG5cdC8vIFZlcmlmeSBzdHlsZSBmbG9hdCBleGlzdGVuY2Vcblx0Ly8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuXHRzdXBwb3J0LmNzc0Zsb2F0ID0gISFkaXYuc3R5bGUuY3NzRmxvYXQ7XG5cblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRzdXBwb3J0LmJveFNpemluZyA9IGRpdi5zdHlsZS5ib3hTaXppbmcgPT09IFwiXCIgfHwgZGl2LnN0eWxlLk1vekJveFNpemluZyA9PT0gXCJcIiB8fFxuXHRcdGRpdi5zdHlsZS5XZWJraXRCb3hTaXppbmcgPT09IFwiXCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZUhpZGRlbk9mZnNldHNWYWw7XG5cdFx0fSxcblxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIHBpeGVsUG9zaXRpb25WYWwgaGVyZSBpbnN0ZWFkIG9mIGJveFNpemluZ1JlbGlhYmxlVmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggcGl4ZWxQb3NpdGlvblZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zXG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcGl4ZWxQb3NpdGlvblZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblxuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0aWYgKCBwaXhlbFBvc2l0aW9uVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggcGl4ZWxQb3NpdGlvblZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcblxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblx0XHR2YXIgY29udGVudHMsIGRpdlN0eWxlLFxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gU2V0dXBcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEFzc3VtZSByZWFzb25hYmxlIHZhbHVlcyBpbiB0aGUgYWJzZW5jZSBvZiBnZXRDb21wdXRlZFN0eWxlXG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGJveFNpemluZ1JlbGlhYmxlVmFsID0gcmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZmFsc2U7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPSB0cnVlO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGdldENvbXB1dGVkU3R5bGUgc28gdGhhdCB0aGlzIGNvZGUgaXMgbm90IHJ1biBpbiBJRTw5LlxuXHRcdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0XHRkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRcdHBpeGVsUG9zaXRpb25WYWwgPSAoIGRpdlN0eWxlIHx8IHt9ICkudG9wICE9PSBcIjElXCI7XG5cdFx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSAoIGRpdlN0eWxlIHx8IHt9ICkubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gKCBkaXZTdHlsZSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9ICggZGl2U3R5bGUgfHwgeyBtYXJnaW5SaWdodDogXCI0cHhcIiB9ICkubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdC8vIERpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lciAoIzMzMzMpXG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdGNvbnRlbnRzID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0Y29udGVudHMuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRjb250ZW50cy5zdHlsZS5tYXJnaW5SaWdodCA9IGNvbnRlbnRzLnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXG5cdFx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0VmFsID1cblx0XHRcdFx0IXBhcnNlRmxvYXQoICggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGNvbnRlbnRzICkgfHwge30gKS5tYXJnaW5SaWdodCApO1xuXG5cdFx0XHRkaXYucmVtb3ZlQ2hpbGQoIGNvbnRlbnRzICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU2LThcblx0XHQvLyBGaXJzdCBjaGVjayB0aGF0IGdldENsaWVudFJlY3RzIHdvcmtzIGFzIGV4cGVjdGVkXG5cdFx0Ly8gQ2hlY2sgaWYgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB0aGV5IGFyZSBzZXRcblx0XHQvLyB0byBkaXNwbGF5Om5vbmUgYW5kIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB2aXNpYmxlIHRhYmxlIGNlbGxzIGluIGFcblx0XHQvLyB0YWJsZSByb3c7IGlmIHNvLCBvZmZzZXRXaWR0aC9IZWlnaHQgYXJlIG5vdCByZWxpYWJsZSBmb3IgdXNlIHdoZW5cblx0XHQvLyBkZXRlcm1pbmluZyBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIGhpZGRlbiBkaXJlY3RseSB1c2luZ1xuXHRcdC8vIGRpc3BsYXk6bm9uZSAoaXQgaXMgc3RpbGwgc2FmZSB0byB1c2Ugb2Zmc2V0cyBpZiBhIHBhcmVudCBlbGVtZW50IGlzXG5cdFx0Ly8gaGlkZGVuOyBkb24gc2FmZXR5IGdvZ2dsZXMgYW5kIHNlZSBidWcgIzQ1MTIgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlxuXHRcdGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsID0gZGl2LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwO1xuXHRcdGlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsICkge1xuXHRcdFx0ZGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiO1xuXHRcdFx0Y29udGVudHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGRcIiApO1xuXHRcdFx0Y29udGVudHNbIDAgXS5zdHlsZS5jc3NUZXh0ID0gXCJtYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjA7ZGlzcGxheTpub25lXCI7XG5cdFx0XHRyZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgPSBjb250ZW50c1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMDtcblx0XHRcdGlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsICkge1xuXHRcdFx0XHRjb250ZW50c1sgMCBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHRjb250ZW50c1sgMSBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRcdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsID0gY29udGVudHNbIDAgXS5vZmZzZXRIZWlnaHQgPT09IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVGVhcmRvd25cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cbn0gKSgpO1xuXG5cbnZhciBnZXRTdHlsZXMsIGN1ckNTUyxcblx0cnBvc2l0aW9uID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvO1xuXG5pZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cdGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0XHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHRcdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpIGluIElFOSwgc2VlICMxMjUzN1xuXHRcdHJldCA9IGNvbXB1dGVkID8gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF0gOiB1bmRlZmluZWQ7XG5cblx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMi4xeCBvbmx5XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuXHRcdC8vIGNvbXB1dGVkIGlzIHVuZGVmaW5lZCBmb3IgZWxlbXMgb24gZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0aWYgKCAoIHJldCA9PT0gXCJcIiB8fCByZXQgPT09IHVuZGVmaW5lZCApICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdFx0Ly8gQ2hyb21lIDwgMTcgYW5kIFNhZmFyaSA1LjAgdXNlcyBcImNvbXB1dGVkIHZhbHVlXCJcblx0XHRcdC8vIGluc3RlYWQgb2YgXCJ1c2VkIHZhbHVlXCIgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0Ly8gU2FmYXJpIDUuMS43IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLFxuXHRcdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXR1cm4gcmV0ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0cmV0IDpcblx0XHRcdHJldCArIFwiXCI7XG5cdH07XG59IGVsc2UgaWYgKCBkb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICkge1xuXHRnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jdXJyZW50U3R5bGU7XG5cdH07XG5cblx0Y3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHRcdHZhciBsZWZ0LCBycywgcnNMZWZ0LCByZXQsXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdHJldCA9IGNvbXB1dGVkID8gY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDtcblxuXHRcdC8vIEF2b2lkIHNldHRpbmcgcmV0IHRvIGVtcHR5IHN0cmluZyBoZXJlXG5cdFx0Ly8gc28gd2UgZG9uJ3QgZGVmYXVsdCB0byBhdXRvXG5cdFx0aWYgKCByZXQgPT0gbnVsbCAmJiBzdHlsZSAmJiBzdHlsZVsgbmFtZSBdICkge1xuXHRcdFx0cmV0ID0gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG5cdFx0Ly8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG5cdFx0Ly8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG5cdFx0Ly8gYnV0IG5vdCBwb3NpdGlvbiBjc3MgYXR0cmlidXRlcywgYXMgdGhvc2UgYXJlXG5cdFx0Ly8gcHJvcG9ydGlvbmFsIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0ZWFkXG5cdFx0Ly8gYW5kIHdlIGNhbid0IG1lYXN1cmUgdGhlIHBhcmVudCBpbnN0ZWFkIGJlY2F1c2UgaXRcblx0XHQvLyBtaWdodCB0cmlnZ2VyIGEgXCJzdGFja2luZyBkb2xsc1wiIHByb2JsZW1cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiAhcnBvc2l0aW9uLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0bGVmdCA9IHN0eWxlLmxlZnQ7XG5cdFx0XHRycyA9IGVsZW0ucnVudGltZVN0eWxlO1xuXHRcdFx0cnNMZWZ0ID0gcnMgJiYgcnMubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldHVybiByZXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXQgOlxuXHRcdFx0cmV0ICsgXCJcIiB8fCBcImF1dG9cIjtcblx0fTtcbn1cblxuXG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0XHRyYWxwaGEgPSAvYWxwaGFcXChbXildKlxcKS9pLFxuXHRyb3BhY2l0eSA9IC9vcGFjaXR5XFxzKj1cXHMqKFteKV0qKS9pLFxuXG5cdC8vIHN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGUgZXhjZXB0XG5cdC8vIFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczpcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cblxuLy8gcmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gc2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sIGhpZGRlbixcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YWx1ZXNbIGluZGV4IF0gPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgJiYgZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0aGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblx0dmFyIG1hdGNoZXMgPSBybnVtc3BsaXQuZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIGJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0gc3VwcG9ydC5ib3hTaXppbmcgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdC8vIEluIElFIDExIGZ1bGxzY3JlZW4gZWxlbWVudHMgaW5zaWRlIG9mIGFuIGlmcmFtZSBoYXZlXG5cdC8vIDEwMHggdG9vIHNtYWxsIGRpbWVuc2lvbnMgKGdoLTE3NjQpLlxuXHRpZiAoIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHR2YWwgPSBNYXRoLnJvdW5kKCBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF0gKiAxMDAgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBzb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXG5cdFx0Ly8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuXHRcdFwiZmxvYXRcIjogc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpeGVzICM4OTA4LCBpdCBjYW4gYmUgZG9uZSBtb3JlIGNvcnJlY3RseSBieSBzcGVjaWZpbmcgc2V0dGVycyBpbiBjc3NIb29rcyxcblx0XHRcdC8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodFxuXHRcdFx0Ly8gKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0XHQvLyBTd2FsbG93IGVycm9ycyBmcm9tICdpbnZhbGlkJyBDU1MgdmFsdWVzICgjNTUwOSlcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciBudW0sIHZhbCwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4sIGNvbnZlcnRpbmcgdG8gbnVtYmVyIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblx0XHRcdFx0XHRlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRzdXBwb3J0LmJveFNpemluZyAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5pZiAoICFzdXBwb3J0Lm9wYWNpdHkgKSB7XG5cdGpRdWVyeS5jc3NIb29rcy5vcGFjaXR5ID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXG5cdFx0XHQvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcblx0XHRcdHJldHVybiByb3BhY2l0eS50ZXN0KCAoIGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID9cblx0XHRcdFx0ZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDpcblx0XHRcdFx0ZWxlbS5zdHlsZS5maWx0ZXIgKSB8fCBcIlwiICkgP1xuXHRcdFx0XHRcdCggMC4wMSAqIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApICkgKyBcIlwiIDpcblx0XHRcdFx0XHRjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdFx0XHRjdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0b3BhY2l0eSA9IGpRdWVyeS5pc051bWVyaWMoIHZhbHVlICkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiIDogXCJcIixcblx0XHRcdFx0ZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cblx0XHRcdC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuXHRcdFx0Ly8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbFxuXHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtXG5cdFx0XHQvLyBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG5cdFx0XHQvLyBpZiB2YWx1ZSA9PT0gXCJcIiwgdGhlbiByZW1vdmUgaW5saW5lIG9wYWNpdHkgIzEyNjg1XG5cdFx0XHRpZiAoICggdmFsdWUgPj0gMSB8fCB2YWx1ZSA9PT0gXCJcIiApICYmXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICYmXG5cdFx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGVcblx0XHRcdFx0Ly8gb3IgdW5zZXQgaW5saW5lIG9wYWNpdHksIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgfHwgY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIHN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0cGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOCBvbmx5XG5cdFx0XHRcdC8vIGdldENsaWVudFJlY3RzKCkgZXJyb3JzIG9uIGRpc2Nvbm5lY3RlZCBlbGVtc1xuXHRcdFx0XHQoIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgP1xuXHRcdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdDBcblx0XHRcdFx0KVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzXG5cdFx0XHQvLyBzbywgc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzIGlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHNcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfSxcblx0XHRpID0gMDtcblxuXHQvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIGlmIHdlIGRvbid0IGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyB3ZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHQvLyBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gaGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0Ly8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7XG5cdFx0XHQvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuXHRcdFx0aWYgKCAhc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0IHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRpZiAoICFzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MoKSApIHtcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvd1xuXHRcdFx0XHQvLyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoICggZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSApID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXG5cdFx0XHQvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIG5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG5cdFx0XHQvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRpID0gMDtcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcblxualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBhLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdC8vIFNldHVwXG5cdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0ZGl2LnNldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiwgXCJ0XCIgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYVwiIClbIDAgXTtcblxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJjaGVja2JveFwiICk7XG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHRhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImFcIiApWyAwIF07XG5cblx0Ly8gRmlyc3QgYmF0Y2ggb2YgdGVzdHMuXG5cdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweFwiO1xuXG5cdC8vIFRlc3Qgc2V0QXR0cmlidXRlIG9uIGNhbWVsQ2FzZSBjbGFzcy5cblx0Ly8gSWYgaXQgd29ya3MsIHdlIG5lZWQgYXR0ckZpeGVzIHdoZW4gZG9pbmcgZ2V0L3NldEF0dHJpYnV0ZSAoaWU2LzcpXG5cdHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlID0gZGl2LmNsYXNzTmFtZSAhPT0gXCJ0XCI7XG5cblx0Ly8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuXHQvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWFkKVxuXHRzdXBwb3J0LnN0eWxlID0gL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoIFwic3R5bGVcIiApICk7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcblx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0c3VwcG9ydC5ocmVmTm9ybWFsaXplZCA9IGEuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIi9hXCI7XG5cblx0Ly8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gV2ViS2l0OyBcIm9uXCIgZWxzZXdoZXJlKVxuXHRzdXBwb3J0LmNoZWNrT24gPSAhIWlucHV0LnZhbHVlO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGEgc2VsZWN0ZWQtYnktZGVmYXVsdCBvcHRpb24gaGFzIGEgd29ya2luZyBzZWxlY3RlZCBwcm9wZXJ0eS5cblx0Ly8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSAoIzY3NDMpXG5cdHN1cHBvcnQuZW5jdHlwZSA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmb3JtXCIgKS5lbmN0eXBlO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcblx0Ly8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTggb25seVxuXHQvLyBDaGVjayBpZiB3ZSBjYW4gdHJ1c3QgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0c3VwcG9ydC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG5cblx0Ly8gQ2hlY2sgaWYgYW4gaW5wdXQgbWFpbnRhaW5zIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIG9sZElFIGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkIDpcblx0XHRcdFx0XHRcdFx0XHRvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2XG5cdFx0XHRcdFx0XHQvLyBXaGVuIG5ldyBvcHRpb24gZWxlbWVudCBpcyBhZGRlZCB0byBzZWxlY3QgYm94IHdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIGZvcmNlIHJlZmxvdyBvZiBuZXdseSBhZGRlZCBub2RlIGluIG9yZGVyIHRvIHdvcmthcm91bmQgZGVsYXlcblx0XHRcdFx0XHRcdC8vIG9mIGluaXRpYWxpemF0aW9uIHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvblNldCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBfICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFdpbGwgYmUgZXhlY3V0ZWQgb25seSBpbiBJRTZcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnNjcm9sbEhlaWdodDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlLFxuXHRydXNlRGVmYXVsdCA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksXG5cdGdldFNldEF0dHJpYnV0ZSA9IHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLFxuXHRnZXRTZXRJbnB1dCA9IHN1cHBvcnQuaW5wdXQ7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU4LTlcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWUgZHVyaW5nIGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0XHRcdC8vIEFsc28gY2xlYXIgZGVmYXVsdENoZWNrZWQvZGVmYXVsdFNlbGVjdGVkIChpZiBhcHByb3ByaWF0ZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPVxuXHRcdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggZ2V0U2V0QXR0cmlidXRlID8gbmFtZSA6IHByb3BOYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gSUU8OCBuZWVkcyB0aGUgKnByb3BlcnR5KiBuYW1lXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggIWdldFNldEF0dHJpYnV0ZSAmJiBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUsIG5hbWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdC8vIFVzZSBkZWZhdWx0Q2hlY2tlZCBhbmQgZGVmYXVsdFNlbGVjdGVkIGZvciBvbGRJRVxuXHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPSBlbGVtWyBuYW1lIF0gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0aWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuLy8gZml4IG9sZElFIGF0dHJvcGVydGllc1xuaWYgKCAhZ2V0U2V0SW5wdXQgfHwgIWdldFNldEF0dHJpYnV0ZSApIHtcblx0alF1ZXJ5LmF0dHJIb29rcy52YWx1ZSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHQvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG5cdFx0XHRcdGVsZW0uZGVmYXVsdFZhbHVlID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFVzZSBub2RlSG9vayBpZiBkZWZpbmVkICgjMTk1NCk7IG90aGVyd2lzZSBzZXRBdHRyaWJ1dGUgaXMgZmluZVxuXHRcdFx0XHRyZXR1cm4gbm9kZUhvb2sgJiYgbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gSUU2LzcgZG8gbm90IHN1cHBvcnQgZ2V0dGluZy9zZXR0aW5nIHNvbWUgYXR0cmlidXRlcyB3aXRoIGdldC9zZXRBdHRyaWJ1dGVcbmlmICggIWdldFNldEF0dHJpYnV0ZSApIHtcblxuXHQvLyBVc2UgdGhpcyBmb3IgYW55IGF0dHJpYnV0ZSBpbiBJRTYvN1xuXHQvLyBUaGlzIGZpeGVzIGFsbW9zdCBldmVyeSBJRTYvNyBpc3N1ZVxuXHRub2RlSG9vayA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblxuXHRcdFx0Ly8gU2V0IHRoZSBleGlzdGluZyBvciBjcmVhdGUgYSBuZXcgYXR0cmlidXRlIG5vZGVcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGVOb2RlKFxuXHRcdFx0XHRcdCggcmV0ID0gZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0LnZhbHVlID0gdmFsdWUgKz0gXCJcIjtcblxuXHRcdFx0Ly8gQnJlYWsgYXNzb2NpYXRpb24gd2l0aCBjbG9uZWQgZWxlbWVudHMgYnkgYWxzbyB1c2luZyBzZXRBdHRyaWJ1dGUgKCM5NjQ2KVxuXHRcdFx0aWYgKCBuYW1lID09PSBcInZhbHVlXCIgfHwgdmFsdWUgPT09IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gU29tZSBhdHRyaWJ1dGVzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoIGVtcHR5LXN0cmluZyB2YWx1ZXMgd2hlbiBub3QgZGVmaW5lZFxuXHRhdHRySGFuZGxlLmlkID0gYXR0ckhhbmRsZS5uYW1lID0gYXR0ckhhbmRsZS5jb29yZHMgPVxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdHZhciByZXQ7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuICggcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiByZXQudmFsdWUgIT09IFwiXCIgP1xuXHRcdFx0XHRcdHJldC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8vIEZpeGluZyB2YWx1ZSByZXRyaWV2YWwgb24gYSBidXR0b24gcmVxdWlyZXMgdGhpcyBtb2R1bGVcblx0alF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0dmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuXHRcdFx0aWYgKCByZXQgJiYgcmV0LnNwZWNpZmllZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldC52YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldDogbm9kZUhvb2suc2V0XG5cdH07XG5cblx0Ly8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG5cdC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG5cdGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0bm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSA9PT0gXCJcIiA/IGZhbHNlIDogdmFsdWUsIG5hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gU2V0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXV0byBpbnN0ZWFkIG9mIDAgb24gZW1wdHkgc3RyaW5nKCBCdWcgIzgxNTAgKVxuXHQvLyBUaGlzIGlzIGZvciByZW1vdmFsc1xuXHRqUXVlcnkuZWFjaCggWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiYXV0b1wiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxuXG5pZiAoICFzdXBwb3J0LnN0eWxlICkge1xuXHRqUXVlcnkuYXR0ckhvb2tzLnN0eWxlID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBOb3RlOiBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lcywgYnV0IGlmIHdlIHdlcmUgdG8gLnRvTG93ZXJDYXNlKClcblx0XHRcdC8vIC5jc3NUZXh0LCB0aGF0IHdvdWxkIGRlc3Ryb3kgY2FzZSBzZW5zaXRpdml0eSBpbiBVUkwncywgbGlrZSBpbiBcImJhY2tncm91bmRcIlxuXHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dCB8fCB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0uc3R5bGUuY3NzVGV4dCA9IHZhbHVlICsgXCJcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIHRyeS9jYXRjaCBoYW5kbGVzIGNhc2VzIHdoZXJlIElFIGJhbGtzIChzdWNoIGFzIHJlbW92aW5nIGEgcHJvcGVydHkgb24gd2luZG93KVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpc1sgbmFtZSBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRkZWxldGUgdGhpc1sgbmFtZSBdO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHtcblxuXHQvLyBocmVmL3NyYyBwcm9wZXJ0eSBzaG91bGQgZ2V0IHRoZSBmdWxsIG5vcm1hbGl6ZWQgVVJMICgjMTAyOTkvIzEyOTE1KVxuXHRqUXVlcnkuZWFjaCggWyBcImhyZWZcIiwgXCJzcmNcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIDQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSwgSUU5K1xuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMVxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuLy8gSUU2LzcgY2FsbCBlbmN0eXBlIGVuY29kaW5nXG5pZiAoICFzdXBwb3J0LmVuY3R5cGUgKSB7XG5cdGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG59XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuYXR0ciggZWxlbSwgXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmF0dHIoIGVsZW0sIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIFwiZmFsc2VcIixcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRqUXVlcnkuYXR0ciggdGhpcywgXCJjbGFzc1wiLFxuXHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG52YXIgcnZhbGlkdG9rZW5zID0gLygsKXwoXFxbfHspfCh9fF0pfFwiKD86W15cIlxcXFxcXHJcXG5dfFxcXFxbXCJcXFxcXFwvYmZucnRdfFxcXFx1W1xcZGEtZkEtRl17NH0pKlwiXFxzKjo/fHRydWV8ZmFsc2V8bnVsbHwtPyg/ITBcXGQpXFxkKyg/OlxcLlxcZCt8KSg/OltlRV1bKy1dP1xcZCt8KS9nO1xuXG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdGlmICggd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdC8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5cdFx0cmV0dXJuIHdpbmRvdy5KU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xuXHR9XG5cblx0dmFyIHJlcXVpcmVOb25Db21tYSxcblx0XHRkZXB0aCA9IG51bGwsXG5cdFx0c3RyID0galF1ZXJ5LnRyaW0oIGRhdGEgKyBcIlwiICk7XG5cblx0Ly8gR3VhcmQgYWdhaW5zdCBpbnZhbGlkIChhbmQgcG9zc2libHkgZGFuZ2Vyb3VzKSBpbnB1dCBieSBlbnN1cmluZyB0aGF0IG5vdGhpbmcgcmVtYWluc1xuXHQvLyBhZnRlciByZW1vdmluZyB2YWxpZCB0b2tlbnNcblx0cmV0dXJuIHN0ciAmJiAhalF1ZXJ5LnRyaW0oIHN0ci5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIGZ1bmN0aW9uKCB0b2tlbiwgY29tbWEsIG9wZW4sIGNsb3NlICkge1xuXG5cdFx0Ly8gRm9yY2UgdGVybWluYXRpb24gaWYgd2Ugc2VlIGEgbWlzcGxhY2VkIGNvbW1hXG5cdFx0aWYgKCByZXF1aXJlTm9uQ29tbWEgJiYgY29tbWEgKSB7XG5cdFx0XHRkZXB0aCA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyZm9ybSBubyBtb3JlIHJlcGxhY2VtZW50cyBhZnRlciByZXR1cm5pbmcgdG8gb3V0ZXJtb3N0IGRlcHRoXG5cdFx0aWYgKCBkZXB0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0b2tlbjtcblx0XHR9XG5cblx0XHQvLyBDb21tYXMgbXVzdCBub3QgZm9sbG93IFwiW1wiLCBcIntcIiwgb3IgXCIsXCJcblx0XHRyZXF1aXJlTm9uQ29tbWEgPSBvcGVuIHx8IGNvbW1hO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIG5ldyBkZXB0aFxuXHRcdC8vIGFycmF5L29iamVjdCBvcGVuIChcIltcIiBvciBcIntcIik6IGRlcHRoICs9IHRydWUgLSBmYWxzZSAoaW5jcmVtZW50KVxuXHRcdC8vIGFycmF5L29iamVjdCBjbG9zZSAoXCJdXCIgb3IgXCJ9XCIpOiBkZXB0aCArPSBmYWxzZSAtIHRydWUgKGRlY3JlbWVudClcblx0XHQvLyBvdGhlciBjYXNlcyAoXCIsXCIgb3IgcHJpbWl0aXZlKTogZGVwdGggKz0gdHJ1ZSAtIHRydWUgKG51bWVyaWMgY2FzdClcblx0XHRkZXB0aCArPSAhY2xvc2UgLSAhb3BlbjtcblxuXHRcdC8vIFJlbW92ZSB0aGlzIHRva2VuXG5cdFx0cmV0dXJuIFwiXCI7XG5cdH0gKSApID9cblx0XHQoIEZ1bmN0aW9uKCBcInJldHVybiBcIiArIHN0ciApICkoKSA6XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgSlNPTjogXCIgKyBkYXRhICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7IC8vIFN0YW5kYXJkXG5cdFx0XHR0bXAgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuXHRcdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0fSBlbHNlIHsgLy8gSUVcblx0XHRcdHhtbCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcblx0XHRcdHhtbC5sb2FkWE1MKCBkYXRhICk7XG5cdFx0fVxuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKCAheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cblx0Ly8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJ1cmwgPSAvXihbXFx3ListXSs6KSg/OlxcL1xcLyg/OlteXFwvPyNdKkB8KShbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWYsXG5cblx0Ly8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5cdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGUuY2hhckF0KCAwICkgPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIgZGVlcCwga2V5LFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXHR2YXIgZmlyc3REYXRhVHlwZSwgY3QsIGZpbmFsRGF0YVR5cGUsIHR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkgeyAvLyBqc2NzOmlnbm9yZSByZXF1aXJlRG90Tm90YXRpb25cblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXJcblxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnMgYXMgc3RyaW5nXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkICgjNTg2NjogSUU3IGlzc3VlIHdpdGggcHJvdG9jb2wtbGVzcyB1cmxzKVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBhYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIGdldERpc3BsYXkoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJIaWRkZW4oIGVsZW0gKSB7XG5cdHdoaWxlICggZWxlbSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdGlmICggZ2V0RGlzcGxheSggZWxlbSApID09PSBcIm5vbmVcIiB8fCBlbGVtLnR5cGUgPT09IFwiaGlkZGVuXCIgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHRyZXR1cm4gc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMoKSA/XG5cdFx0KCBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMCAmJlxuXHRcdFx0IWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSA6XG5cdFx0XHRmaWx0ZXJIaWRkZW4oIGVsZW0gKTtcbn07XG5cbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoXCI6ZGlzYWJsZWRcIikgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxuLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuLy8gKFRoaXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYWpheFNldHRpbmdzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCAhPT0gdW5kZWZpbmVkID9cblxuXHQvLyBTdXBwb3J0OiBJRTYtSUU4XG5cdGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gWEhSIGNhbm5vdCBhY2Nlc3MgbG9jYWwgZmlsZXMsIGFsd2F5cyB1c2UgQWN0aXZlWCBmb3IgdGhhdCBjYXNlXG5cdFx0aWYgKCB0aGlzLmlzTG9jYWwgKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlQWN0aXZlWEhSKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOS0xMVxuXHRcdC8vIElFIHNlZW1zIHRvIGVycm9yIG9uIGNyb3NzLWRvbWFpbiBQQVRDSCByZXF1ZXN0cyB3aGVuIEFjdGl2ZVggWEhSXG5cdFx0Ly8gaXMgdXNlZC4gSW4gSUUgOSsgYWx3YXlzIHVzZSB0aGUgbmF0aXZlIFhIUi5cblx0XHQvLyBOb3RlOiB0aGlzIGNvbmRpdGlvbiB3b24ndCBjYXRjaCBFZGdlIGFzIGl0IGRvZXNuJ3QgZGVmaW5lXG5cdFx0Ly8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIGJ1dCBpdCBhbHNvIGRvZXNuJ3Qgc3VwcG9ydCBBY3RpdmVYIHNvIGl0IHdvbid0XG5cdFx0Ly8gcmVhY2ggdGhpcyBjb2RlLlxuXHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCApIHtcblx0XHRcdHJldHVybiBjcmVhdGVTdGFuZGFyZFhIUigpO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBvbGRJRSBYSFIgZG9lcyBub3Qgc3VwcG9ydCBub24tUkZDMjYxNiBtZXRob2RzICgjMTMyNDApXG5cdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNjY0OCh2PXZzLjg1KS5hc3B4XG5cdFx0Ly8gYW5kIGh0dHA6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjOS5odG1sI3NlYzlcblx0XHQvLyBBbHRob3VnaCB0aGlzIGNoZWNrIGZvciBzaXggbWV0aG9kcyBpbnN0ZWFkIG9mIGVpZ2h0XG5cdFx0Ly8gc2luY2UgSUUgYWxzbyBkb2VzIG5vdCBzdXBwb3J0IFwidHJhY2VcIiBhbmQgXCJjb25uZWN0XCJcblx0XHRyZXR1cm4gL14oZ2V0fHBvc3R8aGVhZHxwdXR8ZGVsZXRlfG9wdGlvbnMpJC9pLnRlc3QoIHRoaXMudHlwZSApICYmXG5cdFx0XHRjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuXHR9IDpcblxuXHQvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHRjcmVhdGVTdGFuZGFyZFhIUjtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFPDEwXG4vLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxuLy8gU2VlIGh0dHBzOi8vc3VwcG9ydC5taWNyb3NvZnQuY29tL2tiLzI4NTY3NDYgZm9yIG1vcmUgaW5mb1xuaWYgKCB3aW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcblx0XHRcdHhockNhbGxiYWNrc1sga2V5IF0oIHVuZGVmaW5lZCwgdHJ1ZSApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBEZXRlcm1pbmUgc3VwcG9ydCBwcm9wZXJ0aWVzXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG54aHJTdXBwb3J0ZWQgPSBzdXBwb3J0LmFqYXggPSAhIXhoclN1cHBvcnRlZDtcblxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbmlmICggeGhyU3VwcG9ydGVkICkge1xuXG5cdGpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluIHx8IHN1cHBvcnQuY29ycyApIHtcblxuXHRcdFx0dmFyIGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpLFxuXHRcdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdFx0Ly8gT3BlbiB0aGUgc29ja2V0XG5cdFx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJRSdzIEFjdGl2ZVhPYmplY3QgdGhyb3dzIGEgJ1R5cGUgTWlzbWF0Y2gnIGV4Y2VwdGlvbiB3aGVuIHNldHRpbmdcblx0XHRcdFx0XHRcdC8vIHJlcXVlc3QgaGVhZGVyIHRvIGEgbnVsbC12YWx1ZS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBrZWVwIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBYSFIgaW1wbGVtZW50YXRpb25zLCBjYXN0IHRoZSB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gdG8gc3RyaW5nIGFuZCBpZ25vcmUgYHVuZGVmaW5lZGAuXG5cdFx0XHRcdFx0XHRpZiAoIGhlYWRlcnNbIGkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICsgXCJcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcblx0XHRcdFx0XHQvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSlcblx0XHRcdFx0XHR4aHIuc2VuZCggKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhICkgfHwgbnVsbCApO1xuXG5cdFx0XHRcdFx0Ly8gTGlzdGVuZXJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzO1xuXG5cdFx0XHRcdFx0XHQvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIENsZWFuIHVwXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWJvcnQgbWFudWFsbHkgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdGlmICggaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTwxMFxuXHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcblx0XHRcdFx0XHRcdFx0XHQvLyBzdGF0dXNUZXh0IGZvciBmYXVsdHkgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcmVxdWVzdCBpcyBsb2NhbCBhbmQgd2UgaGF2ZSBkYXRhOiBhc3N1bWUgYSBzdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gKHN1Y2Nlc3Mgd2l0aCBubyBkYXRhIHdvbid0IGdldCBub3RpZmllZCwgdGhhdCdzIHRoZSBiZXN0IHdlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIGRvIGdpdmVuIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRcdGlmICggIXN0YXR1cyAmJiBvcHRpb25zLmlzTG9jYWwgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSByZXNwb25zZXMudGV4dCA/IDIwMCA6IDQwNDtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIElFIC0gIzE0NTA6IHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAxMjIzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gMjA0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDYWxsIGNvbXBsZXRlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBzdGF0dXMsIHN0YXR1c1RleHQsIHJlc3BvbnNlcywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBgeGhyLnNlbmRgIG1heSByYWlzZSBhbiBleGNlcHRpb24sIGJ1dCBpdCB3aWxsIGJlXG5cdFx0XHRcdFx0Ly8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5hc3luYyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgaW4gc3luYyBtb2RlIHdlIGZpcmUgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyAoSUU2ICYgSUU3KSBpZiBpdCdzIGluIGNhY2hlIGFuZCBoYXMgYmVlblxuXHRcdFx0XHRcdFx0Ly8gcmV0cmlldmVkIGRpcmVjdGx5IHdlIG5lZWQgdG8gZmlyZSB0aGUgY2FsbGJhY2tcblx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlZ2lzdGVyIHRoZSBjYWxsYmFjaywgYnV0IGRlbGF5IGl0IGluIGNhc2UgYHhoci5zZW5kYCB0aHJvd3Ncblx0XHRcdFx0XHRcdC8vIEFkZCB0byB0aGUgbGlzdCBvZiBhY3RpdmUgeGhyIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhockNhbGxiYWNrc1sgaWQgXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn1cblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBnbG9iYWxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdHMuZ2xvYmFsID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgalF1ZXJ5KCBcImhlYWRcIiApWyAwIF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xuXHRcdFx0XHRcdHNjcmlwdC5jaGFyc2V0ID0gcy5zY3JpcHRDaGFyc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NyaXB0LnNyYyA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG5cdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuXHRcdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0aWYgKCBzY3JpcHQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcblx0XHRcdFx0XHRcdGlmICggIWlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCAyMDAsIFwic3VjY2Vzc1wiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIENpcmN1bXZlbnQgSUU2IGJ1Z3Mgd2l0aCBiYXNlIGVsZW1lbnRzICgjMjcwOSBhbmQgIzQzNzgpIGJ5IHByZXBlbmRpbmdcblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNjcmlwdCApIHtcblx0XHRcdFx0XHRzY3JpcHQub25sb2FkKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImF1dG9cIiwgWyBjdXJDU1NUb3AsIGN1ckNTU0xlZnQgXSApID4gLTE7XG5cblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdFxuXHRcdC8vIGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvclxuXHRcdC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCAgKyAoIHdpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCApICAtICggZG9jRWxlbS5jbGllbnRUb3AgIHx8IDAgKSxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgKCB3aW4ucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0ICkgLSAoIGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwIClcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gd2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG5cdFx0Ly8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnQsIFwiaHRtbFwiICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gL1kvLnRlc3QoIHByb3AgKTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyAoIHByb3AgaW4gd2luICkgPyB3aW5bIHByb3AgXSA6XG5cdFx0XHRcdFx0d2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gOlxuXHRcdFx0XHRcdGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbFRvcCgpXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3LTgrLCBDaHJvbWU8MzctNDQrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0Ly8gdW5mb3J0dW5hdGVseSwgdGhpcyBjYXVzZXMgYnVnICMzODM4IGluIElFNi84IG9ubHksXG5cdFx0XHRcdFx0Ly8gYnV0IHRoZXJlIGlzIGN1cnJlbnRseSBubyBnb29kLCBzbWFsbCB3YXkgdG8gZml4IGl0LlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxuLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiZGVsZXRlZElkcyIsInNsaWNlIiwiY29uY2F0IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInN1cHBvcnQiLCJ2ZXJzaW9uIiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicnRyaW0iLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJ0b0FycmF5IiwiY2FsbCIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImkiLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJzcmMiLCJjb3B5SXNBcnJheSIsImNvcHkiLCJuYW1lIiwib3B0aW9ucyIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInJlYWxTdHJpbmdPYmoiLCJwYXJzZUZsb2F0IiwiaXNFbXB0eU9iamVjdCIsImtleSIsIm5vZGVUeXBlIiwiZSIsIm93bkZpcnN0IiwiZ2xvYmFsRXZhbCIsImRhdGEiLCJ0cmltIiwiZXhlY1NjcmlwdCIsImNhbWVsQ2FzZSIsInN0cmluZyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJpc0FycmF5TGlrZSIsInRleHQiLCJtYWtlQXJyYXkiLCJhcnIiLCJyZXN1bHRzIiwiT2JqZWN0IiwiaW5BcnJheSIsIm1heCIsInNlY29uZCIsImdyZXAiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJwcm94eSIsImFyZ3MiLCJ0bXAiLCJub3ciLCJEYXRlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzcGxpdCIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic29ydE9yZGVyIiwiYSIsImIiLCJNQVhfTkVHQVRJVkUiLCJwb3AiLCJwdXNoX25hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJhdHRyaWJ1dGVRdW90ZXMiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJyZXNjYXBlIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1bmxvYWRIYW5kbGVyIiwiY2hpbGROb2RlcyIsImVscyIsInNlZWQiLCJtIiwibmlkIiwibmlkc2VsZWN0IiwibWF0Y2giLCJncm91cHMiLCJuZXdTZWxlY3RvciIsIm5ld0NvbnRleHQiLCJvd25lckRvY3VtZW50IiwiZXhlYyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0ZXN0IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidG9TZWxlY3RvciIsImpvaW4iLCJ0ZXN0Q29udGV4dCIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsInJlbW92ZUNoaWxkIiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsInBhcmVudCIsImRvYyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVDb21tZW50IiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiZmluZCIsImZpbHRlciIsImF0dHJJZCIsImdldEF0dHJpYnV0ZU5vZGUiLCJ0YWciLCJpbm5lckhUTUwiLCJpbnB1dCIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImJ1cCIsImNvbXBhcmUiLCJzb3J0RGV0YWNoZWQiLCJhdXAiLCJhcCIsImJwIiwidW5zaGlmdCIsImV4cHIiLCJlbGVtZW50cyIsImF0dHIiLCJ2YWwiLCJzcGVjaWZpZWQiLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsImRldGVjdER1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwidGV4dENvbnRlbnQiLCJmaXJzdENoaWxkIiwibm9kZVZhbHVlIiwic2VsZWN0b3JzIiwiY3JlYXRlUHNldWRvIiwicmVsYXRpdmUiLCJkaXIiLCJwcmVGaWx0ZXIiLCJleGNlc3MiLCJ1bnF1b3RlZCIsIm5vZGVOYW1lU2VsZWN0b3IiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsInJlc3VsdCIsIndoYXQiLCJzaW1wbGUiLCJmb3J3YXJkIiwib2ZUeXBlIiwieG1sIiwidW5pcXVlQ2FjaGUiLCJvdXRlckNhY2hlIiwibm9kZUluZGV4Iiwic3RhcnQiLCJ1c2VDYWNoZSIsImxhc3RDaGlsZCIsInVuaXF1ZUlEIiwicHNldWRvIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwiaW5uZXJUZXh0IiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiYWRkQ29tYmluYXRvciIsImNvbWJpbmF0b3IiLCJiYXNlIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJkaXYxIiwiZGVmYXVsdFZhbHVlIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsIm4iLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsInJpc1NpbXBsZSIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJyb290alF1ZXJ5Iiwicm9vdCIsImNoYXJBdCIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJuZXh0IiwicHJldiIsImhhcyIsInRhcmdldHMiLCJjbG9zZXN0IiwibCIsInBvcyIsImluZGV4IiwicHJldkFsbCIsImFkZCIsImFkZEJhY2siLCJzaWJsaW5nIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50V2luZG93IiwicmV2ZXJzZSIsInJub3R3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwicHJvbWlzZSIsImFsd2F5cyIsImRlZmVycmVkIiwiZmFpbCIsInRoZW4iLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInJlc29sdmUiLCJyZWplY3QiLCJwaXBlIiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic3Vib3JkaW5hdGUiLCJyZXNvbHZlVmFsdWVzIiwicmVtYWluaW5nIiwidXBkYXRlRnVuYyIsInZhbHVlcyIsInByb2dyZXNzVmFsdWVzIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvZ3Jlc3NDb250ZXh0cyIsInJlc29sdmVDb250ZXh0cyIsInJlYWR5TGlzdCIsInJlYWR5V2FpdCIsImhvbGRSZWFkeSIsImhvbGQiLCJ3YWl0IiwidHJpZ2dlckhhbmRsZXIiLCJvZmYiLCJkZXRhY2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29tcGxldGVkIiwiZGV0YWNoRXZlbnQiLCJldmVudCIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsInNldFRpbWVvdXQiLCJmcmFtZUVsZW1lbnQiLCJkb1Njcm9sbENoZWNrIiwiaW5saW5lQmxvY2tOZWVkc0xheW91dCIsImJvZHkiLCJjb250YWluZXIiLCJzdHlsZSIsImNzc1RleHQiLCJ6b29tIiwib2Zmc2V0V2lkdGgiLCJkZWxldGVFeHBhbmRvIiwiYWNjZXB0RGF0YSIsIm5vRGF0YSIsInJicmFjZSIsInJtdWx0aURhc2giLCJkYXRhQXR0ciIsInBhcnNlSlNPTiIsImlzRW1wdHlEYXRhT2JqZWN0IiwiaW50ZXJuYWxEYXRhIiwicHZ0IiwidGhpc0NhY2hlIiwiaW50ZXJuYWxLZXkiLCJpc05vZGUiLCJ0b0pTT04iLCJpbnRlcm5hbFJlbW92ZURhdGEiLCJjbGVhbkRhdGEiLCJoYXNEYXRhIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwic2hyaW5rV3JhcEJsb2Nrc1ZhbCIsInNocmlua1dyYXBCbG9ja3MiLCJ3aWR0aCIsInBudW0iLCJzb3VyY2UiLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNIaWRkZW4iLCJlbCIsImNzcyIsImFkanVzdENTUyIsInByb3AiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsImluaXRpYWwiLCJ1bml0IiwiY3NzTnVtYmVyIiwiaW5pdGlhbEluVW5pdCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsInJjaGVja2FibGVUeXBlIiwicnRhZ05hbWUiLCJyc2NyaXB0VHlwZSIsInJsZWFkaW5nV2hpdGVzcGFjZSIsIm5vZGVOYW1lcyIsImNyZWF0ZVNhZmVGcmFnbWVudCIsInNhZmVGcmFnIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImZyYWdtZW50IiwibGVhZGluZ1doaXRlc3BhY2UiLCJ0Ym9keSIsImh0bWxTZXJpYWxpemUiLCJodG1sNUNsb25lIiwiY2xvbmVOb2RlIiwib3V0ZXJIVE1MIiwiYXBwZW5kQ2hlY2tlZCIsIm5vQ2xvbmVDaGVja2VkIiwiY2hlY2tDbG9uZSIsIm5vQ2xvbmVFdmVudCIsIndyYXBNYXAiLCJvcHRpb24iLCJsZWdlbmQiLCJhcmVhIiwicGFyYW0iLCJ0aGVhZCIsInRyIiwiY29sIiwidGQiLCJfZGVmYXVsdCIsIm9wdGdyb3VwIiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsImdldEFsbCIsImZvdW5kIiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwicmh0bWwiLCJydGJvZHkiLCJmaXhEZWZhdWx0Q2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsInNhZmUiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsImV2ZW50TmFtZSIsImNoYW5nZSIsImZvY3VzaW4iLCJyZm9ybUVsZW1zIiwicmtleUV2ZW50Iiwicm1vdXNlRXZlbnQiLCJyZm9jdXNNb3JwaCIsInJ0eXBlbmFtZXNwYWNlIiwicmV0dXJuVHJ1ZSIsInJldHVybkZhbHNlIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJvbiIsInR5cGVzIiwib25lIiwib3JpZ0ZuIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iakluIiwic3BlY2lhbCIsImV2ZW50SGFuZGxlIiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJ0cmlnZ2VyIiwib25seUhhbmRsZXJzIiwib250eXBlIiwiYnViYmxlVHlwZSIsImV2ZW50UGF0aCIsIkV2ZW50IiwiaXNUcmlnZ2VyIiwicm5hbWVzcGFjZSIsIm5vQnViYmxlIiwicGFyZW50V2luZG93IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImZpeCIsImhhbmRsZXJRdWV1ZSIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJzZWwiLCJpc05hTiIsImJ1dHRvbiIsIm9yaWdpbmFsRXZlbnQiLCJmaXhIb29rIiwiZml4SG9va3MiLCJtb3VzZUhvb2tzIiwia2V5SG9va3MiLCJwcm9wcyIsInNyY0VsZW1lbnQiLCJtZXRhS2V5Iiwib3JpZ2luYWwiLCJ3aGljaCIsImNoYXJDb2RlIiwia2V5Q29kZSIsImV2ZW50RG9jIiwiZnJvbUVsZW1lbnQiLCJwYWdlWCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwiY2xpZW50TGVmdCIsInBhZ2VZIiwiY2xpZW50WSIsInNjcm9sbFRvcCIsImNsaWVudFRvcCIsInJlbGF0ZWRUYXJnZXQiLCJ0b0VsZW1lbnQiLCJsb2FkIiwiZm9jdXMiLCJibHVyIiwiY2xpY2siLCJiZWZvcmV1bmxvYWQiLCJyZXR1cm5WYWx1ZSIsInNpbXVsYXRlIiwiaXNTaW11bGF0ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwidGltZVN0YW1wIiwiY2FuY2VsQnViYmxlIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsImZvcm0iLCJfc3VibWl0QnViYmxlIiwicHJvcGVydHlOYW1lIiwiX2p1c3RDaGFuZ2VkIiwiYXR0YWNoZXMiLCJyaW5saW5lalF1ZXJ5Iiwicm5vc2hpbWNhY2hlIiwicnhodG1sVGFnIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyc2NyaXB0VHlwZU1hc2tlZCIsInJjbGVhblNjcmlwdCIsInNhZmVGcmFnbWVudCIsImZyYWdtZW50RGl2IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0Iiwib2xkRGF0YSIsImN1ckRhdGEiLCJmaXhDbG9uZU5vZGVJc3N1ZXMiLCJkZWZhdWx0U2VsZWN0ZWQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsImRlc3RFbGVtZW50cyIsInNyY0VsZW1lbnRzIiwiaW5QYWdlIiwiZm9yY2VBY2NlcHREYXRhIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsImluc2VydCIsImlmcmFtZSIsImVsZW1kaXNwbGF5IiwiSFRNTCIsIkJPRFkiLCJhY3R1YWxEaXNwbGF5IiwiZGlzcGxheSIsImRlZmF1bHREaXNwbGF5Iiwid3JpdGUiLCJjbG9zZSIsInJtYXJnaW4iLCJybnVtbm9ucHgiLCJzd2FwIiwib2xkIiwicGl4ZWxQb3NpdGlvblZhbCIsInBpeGVsTWFyZ2luUmlnaHRWYWwiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsInJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCIsInJlbGlhYmxlTWFyZ2luUmlnaHRWYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJvcGFjaXR5IiwiY3NzRmxvYXQiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImJveFNpemluZyIsIk1vekJveFNpemluZyIsIldlYmtpdEJveFNpemluZyIsInJlbGlhYmxlSGlkZGVuT2Zmc2V0cyIsImNvbXB1dGVTdHlsZVRlc3RzIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbE1hcmdpblJpZ2h0IiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luUmlnaHQiLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJkaXZTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJnZXRDbGllbnRSZWN0cyIsIm9mZnNldEhlaWdodCIsImdldFN0eWxlcyIsImN1ckNTUyIsInJwb3NpdGlvbiIsInZpZXciLCJvcGVuZXIiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY3VycmVudFN0eWxlIiwibGVmdCIsInJzIiwicnNMZWZ0IiwicnVudGltZVN0eWxlIiwicGl4ZWxMZWZ0IiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJyYWxwaGEiLCJyb3BhY2l0eSIsInJkaXNwbGF5c3dhcCIsInJudW1zcGxpdCIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsInNob3dIaWRlIiwic2hvdyIsImhpZGRlbiIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsIm1zRnVsbHNjcmVlbkVsZW1lbnQiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNzc0hvb2tzIiwiY3NzUHJvcHMiLCJvcmlnTmFtZSIsInNldCIsImlzRmluaXRlIiwiJDEiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm9yZGVyIiwicHJlZml4Iiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsImhpZGUiLCJ0b2dnbGUiLCJUd2VlbiIsImVhc2luZyIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwic3RlcCIsImZ4IiwibGluZWFyIiwicCIsInN3aW5nIiwiY29zIiwiUEkiLCJmeE5vdyIsInRpbWVySWQiLCJyZnh0eXBlcyIsInJydW4iLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsImNoZWNrRGlzcGxheSIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwicHJlZmlsdGVycyIsInRpY2siLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJyZWplY3RXaXRoIiwidGltZXIiLCJjb21wbGV0ZSIsInR3ZWVuZXIiLCJwcmVmaWx0ZXIiLCJzcGVlZCIsIm9wdCIsInNwZWVkcyIsImZhZGVUbyIsInRvIiwiYW5pbWF0ZSIsIm9wdGFsbCIsImRvQW5pbWF0aW9uIiwiZmluaXNoIiwic3RvcFF1ZXVlIiwidGltZXJzIiwiY3NzRm4iLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0U2V0QXR0cmlidXRlIiwiaHJlZk5vcm1hbGl6ZWQiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJlbmN0eXBlIiwib3B0RGlzYWJsZWQiLCJyYWRpb1ZhbHVlIiwicnJldHVybiIsInJzcGFjZXMiLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsInNjcm9sbEhlaWdodCIsIm5vZGVIb29rIiwiYm9vbEhvb2siLCJydXNlRGVmYXVsdCIsImdldFNldElucHV0IiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsInByb3BOYW1lIiwiYXR0ck5hbWVzIiwicHJvcEZpeCIsImdldHRlciIsInNldEF0dHJpYnV0ZU5vZGUiLCJjcmVhdGVBdHRyaWJ1dGUiLCJjb29yZHMiLCJjb250ZW50ZWRpdGFibGUiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJ0YWJpbmRleCIsInBhcnNlSW50IiwicmNsYXNzIiwiZ2V0Q2xhc3MiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJjdXJWYWx1ZSIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJub25jZSIsInJxdWVyeSIsInJ2YWxpZHRva2VucyIsIkpTT04iLCJwYXJzZSIsInJlcXVpcmVOb25Db21tYSIsImRlcHRoIiwic3RyIiwiY29tbWEiLCJvcGVuIiwiRnVuY3Rpb24iLCJwYXJzZVhNTCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsIkFjdGl2ZVhPYmplY3QiLCJhc3luYyIsImxvYWRYTUwiLCJyaGFzaCIsInJ0cyIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwicnVybCIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsImFqYXhMb2NhdGlvbiIsImFqYXhMb2NQYXJ0cyIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJzIiwicmVzcG9uc2VzIiwiZmlyc3REYXRhVHlwZSIsImN0IiwiZmluYWxEYXRhVHlwZSIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJjb252ZXJ0ZXJzIiwiYWpheENvbnZlcnQiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsImNvbnYyIiwiY3VycmVudCIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwidXJsIiwiaXNMb2NhbCIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJhY2NlcHRzIiwianNvbiIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJhamF4IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJ0aW1lb3V0VGltZXIiLCJmaXJlR2xvYmFscyIsInRyYW5zcG9ydCIsInJlc3BvbnNlSGVhZGVycyIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibG5hbWUiLCJvdmVycmlkZU1pbWVUeXBlIiwiY29kZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsInN1Y2Nlc3MiLCJtZXRob2QiLCJjcm9zc0RvbWFpbiIsInRyYWRpdGlvbmFsIiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsIndyYXBJbm5lciIsInVud3JhcCIsImdldERpc3BsYXkiLCJmaWx0ZXJIaWRkZW4iLCJ2aXNpYmxlIiwicjIwIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidiIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwieGhyIiwiY3JlYXRlQWN0aXZlWEhSIiwiZG9jdW1lbnRNb2RlIiwiY3JlYXRlU3RhbmRhcmRYSFIiLCJ4aHJJZCIsInhockNhbGxiYWNrcyIsInhoclN1cHBvcnRlZCIsImNvcnMiLCJ1c2VybmFtZSIsInhockZpZWxkcyIsImlzQWJvcnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVRleHQiLCJYTUxIdHRwUmVxdWVzdCIsInNjcmlwdCIsImhlYWQiLCJzY3JpcHRDaGFyc2V0IiwiY2hhcnNldCIsIm9ubG9hZCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsIl9sb2FkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJnZXRXaW5kb3ciLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJ3aW4iLCJib3giLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0Iiwib2Zmc2V0UGFyZW50IiwicGFyZW50T2Zmc2V0Iiwic2Nyb2xsVG8iLCJIZWlnaHQiLCJXaWR0aCIsImRlZmF1bHRFeHRyYSIsImZ1bmNOYW1lIiwiYmluZCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsInNpemUiLCJhbmRTZWxmIiwiZGVmaW5lIiwiYW1kIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/jquery-1.12.3.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/jquery-1.12.3.js");
/******/ 	
/******/ })()
;